# This module contains Scheduling functions.

from .Utilities import *

import pandas as pd

import json

import re


def getEveryAppleSchoolManagerConfig(searchConditions = [], EntityID = 1, returnAppleSchoolManagerConfigID = False, returnAsOfDateSetting = False, returnAsOfDateSettingCode = False, returnCreatedTime = False, returnDistrictID = False, returnEntityIDSelectedList = False, returnExportUncPathOverride = False, returnFTPConnectionID = False, returnMediaID = False, returnModifiedTime = False, returnSaveToFtp = False, returnSchoolYearID = False, returnSpecifiedAsOfDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnZipFileName = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every AppleSchoolManagerConfig in the district.

    This function returns a dataframe of every AppleSchoolManagerConfig in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AppleSchoolManagerConfig/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AppleSchoolManagerConfig/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getAppleSchoolManagerConfig(AppleSchoolManagerConfigID, EntityID = 1, returnAppleSchoolManagerConfigID = False, returnAsOfDateSetting = False, returnAsOfDateSettingCode = False, returnCreatedTime = False, returnDistrictID = False, returnEntityIDSelectedList = False, returnExportUncPathOverride = False, returnFTPConnectionID = False, returnMediaID = False, returnModifiedTime = False, returnSaveToFtp = False, returnSchoolYearID = False, returnSpecifiedAsOfDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnZipFileName = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AppleSchoolManagerConfig/" + str(AppleSchoolManagerConfigID), verb = "get", return_params_list = return_params)

def modifyAppleSchoolManagerConfig(AppleSchoolManagerConfigID, EntityID = 1, setAppleSchoolManagerConfigID = None, setAsOfDateSetting = None, setAsOfDateSettingCode = None, setCreatedTime = None, setDistrictID = None, setEntityIDSelectedList = None, setExportUncPathOverride = None, setFTPConnectionID = None, setMediaID = None, setModifiedTime = None, setSaveToFtp = None, setSchoolYearID = None, setSpecifiedAsOfDate = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setZipFileName = None, returnAppleSchoolManagerConfigID = False, returnAsOfDateSetting = False, returnAsOfDateSettingCode = False, returnCreatedTime = False, returnDistrictID = False, returnEntityIDSelectedList = False, returnExportUncPathOverride = False, returnFTPConnectionID = False, returnMediaID = False, returnModifiedTime = False, returnSaveToFtp = False, returnSchoolYearID = False, returnSpecifiedAsOfDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnZipFileName = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AppleSchoolManagerConfig/" + str(AppleSchoolManagerConfigID), verb = "post", return_params_list = return_params, payload = payload_params)

def createAppleSchoolManagerConfig(EntityID = 1, setAppleSchoolManagerConfigID = None, setAsOfDateSetting = None, setAsOfDateSettingCode = None, setCreatedTime = None, setDistrictID = None, setEntityIDSelectedList = None, setExportUncPathOverride = None, setFTPConnectionID = None, setMediaID = None, setModifiedTime = None, setSaveToFtp = None, setSchoolYearID = None, setSpecifiedAsOfDate = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setZipFileName = None, returnAppleSchoolManagerConfigID = False, returnAsOfDateSetting = False, returnAsOfDateSettingCode = False, returnCreatedTime = False, returnDistrictID = False, returnEntityIDSelectedList = False, returnExportUncPathOverride = False, returnFTPConnectionID = False, returnMediaID = False, returnModifiedTime = False, returnSaveToFtp = False, returnSchoolYearID = False, returnSpecifiedAsOfDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnZipFileName = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AppleSchoolManagerConfig/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteAppleSchoolManagerConfig(AppleSchoolManagerConfigID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AppleSchoolManagerConfig/" + str(AppleSchoolManagerConfigID), verb = "delete")


def getEveryAvailabilityCourseFilter(searchConditions = [], EntityID = 1, returnAvailabilityCourseFilterID = False, returnAvailabilityCourseFilterIDClonedFrom = False, returnAvailabilityCourseFilterIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCourseTypeIDInclusionList = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnFilter = False, returnGradeLevelFilterType = False, returnGradeLevelFilterTypeCode = False, returnGradeReferenceIDInclusionList = False, returnIncludeCategoryLunch = False, returnIncludeCategoryRegular = False, returnIncludeCategoryStudyHall = False, returnIncludeCoursesWithNoCourseType = False, returnIncludeElective = False, returnIncludeInactiveCourses = False, returnIncludeOfferedCourses = False, returnIncludeRequired = False, returnIncludeSchedulingTypeManuallyScheduled = False, returnIncludeSchedulingTypeNormal = False, returnIncludeSchedulingTypeSpecialEducation = False, returnModifiedTime = False, returnSchoolYearID = False, returnSkywardID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every AvailabilityCourseFilter in the district.

    This function returns a dataframe of every AvailabilityCourseFilter in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityCourseFilter/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityCourseFilter/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getAvailabilityCourseFilter(AvailabilityCourseFilterID, EntityID = 1, returnAvailabilityCourseFilterID = False, returnAvailabilityCourseFilterIDClonedFrom = False, returnAvailabilityCourseFilterIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCourseTypeIDInclusionList = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnFilter = False, returnGradeLevelFilterType = False, returnGradeLevelFilterTypeCode = False, returnGradeReferenceIDInclusionList = False, returnIncludeCategoryLunch = False, returnIncludeCategoryRegular = False, returnIncludeCategoryStudyHall = False, returnIncludeCoursesWithNoCourseType = False, returnIncludeElective = False, returnIncludeInactiveCourses = False, returnIncludeOfferedCourses = False, returnIncludeRequired = False, returnIncludeSchedulingTypeManuallyScheduled = False, returnIncludeSchedulingTypeNormal = False, returnIncludeSchedulingTypeSpecialEducation = False, returnModifiedTime = False, returnSchoolYearID = False, returnSkywardID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityCourseFilter/" + str(AvailabilityCourseFilterID), verb = "get", return_params_list = return_params)

def modifyAvailabilityCourseFilter(AvailabilityCourseFilterID, EntityID = 1, setAvailabilityCourseFilterID = None, setAvailabilityCourseFilterIDClonedFrom = None, setAvailabilityCourseFilterIDClonedTo = None, setCode = None, setCodeDescription = None, setCourseTypeIDInclusionList = None, setCreatedTime = None, setDescription = None, setEntityID = None, setFilter = None, setGradeLevelFilterType = None, setGradeLevelFilterTypeCode = None, setGradeReferenceIDInclusionList = None, setIncludeCategoryLunch = None, setIncludeCategoryRegular = None, setIncludeCategoryStudyHall = None, setIncludeCoursesWithNoCourseType = None, setIncludeElective = None, setIncludeInactiveCourses = None, setIncludeOfferedCourses = None, setIncludeRequired = None, setIncludeSchedulingTypeManuallyScheduled = None, setIncludeSchedulingTypeNormal = None, setIncludeSchedulingTypeSpecialEducation = None, setModifiedTime = None, setSchoolYearID = None, setSkywardID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityCourseFilterID = False, returnAvailabilityCourseFilterIDClonedFrom = False, returnAvailabilityCourseFilterIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCourseTypeIDInclusionList = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnFilter = False, returnGradeLevelFilterType = False, returnGradeLevelFilterTypeCode = False, returnGradeReferenceIDInclusionList = False, returnIncludeCategoryLunch = False, returnIncludeCategoryRegular = False, returnIncludeCategoryStudyHall = False, returnIncludeCoursesWithNoCourseType = False, returnIncludeElective = False, returnIncludeInactiveCourses = False, returnIncludeOfferedCourses = False, returnIncludeRequired = False, returnIncludeSchedulingTypeManuallyScheduled = False, returnIncludeSchedulingTypeNormal = False, returnIncludeSchedulingTypeSpecialEducation = False, returnModifiedTime = False, returnSchoolYearID = False, returnSkywardID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityCourseFilter/" + str(AvailabilityCourseFilterID), verb = "post", return_params_list = return_params, payload = payload_params)

def createAvailabilityCourseFilter(EntityID = 1, setAvailabilityCourseFilterID = None, setAvailabilityCourseFilterIDClonedFrom = None, setAvailabilityCourseFilterIDClonedTo = None, setCode = None, setCodeDescription = None, setCourseTypeIDInclusionList = None, setCreatedTime = None, setDescription = None, setEntityID = None, setFilter = None, setGradeLevelFilterType = None, setGradeLevelFilterTypeCode = None, setGradeReferenceIDInclusionList = None, setIncludeCategoryLunch = None, setIncludeCategoryRegular = None, setIncludeCategoryStudyHall = None, setIncludeCoursesWithNoCourseType = None, setIncludeElective = None, setIncludeInactiveCourses = None, setIncludeOfferedCourses = None, setIncludeRequired = None, setIncludeSchedulingTypeManuallyScheduled = None, setIncludeSchedulingTypeNormal = None, setIncludeSchedulingTypeSpecialEducation = None, setModifiedTime = None, setSchoolYearID = None, setSkywardID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityCourseFilterID = False, returnAvailabilityCourseFilterIDClonedFrom = False, returnAvailabilityCourseFilterIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCourseTypeIDInclusionList = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnFilter = False, returnGradeLevelFilterType = False, returnGradeLevelFilterTypeCode = False, returnGradeReferenceIDInclusionList = False, returnIncludeCategoryLunch = False, returnIncludeCategoryRegular = False, returnIncludeCategoryStudyHall = False, returnIncludeCoursesWithNoCourseType = False, returnIncludeElective = False, returnIncludeInactiveCourses = False, returnIncludeOfferedCourses = False, returnIncludeRequired = False, returnIncludeSchedulingTypeManuallyScheduled = False, returnIncludeSchedulingTypeNormal = False, returnIncludeSchedulingTypeSpecialEducation = False, returnModifiedTime = False, returnSchoolYearID = False, returnSkywardID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityCourseFilter/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteAvailabilityCourseFilter(AvailabilityCourseFilterID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityCourseFilter/" + str(AvailabilityCourseFilterID), verb = "delete")


def getEveryAvailabilityFilterArenaSchedulingSetting(searchConditions = [], EntityID = 1, returnAvailabilityFilterArenaSchedulingSettingID = False, returnAutoSchedulerCourseSelection = False, returnAutoSchedulerCourseSelectionCode = False, returnAvailabilityFilterCourseStudentID = False, returnAvailableEndDate = False, returnAvailableStartDate = False, returnCreatedTime = False, returnEnableAutoSchedule = False, returnHideRoom = False, returnHideStaff = False, returnLockAfterSubmission = False, returnModifiedTime = False, returnSchedulingEntryEndDate = False, returnSchedulingEntryEndDateTime = False, returnSchedulingEntryEndTime = False, returnSchedulingEntryStartDate = False, returnSchedulingEntryStartDateTime = False, returnSchedulingEntryStartTime = False, returnShowAllClasses = False, returnShowMyAlternateRequests = False, returnShowMyRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every AvailabilityFilterArenaSchedulingSetting in the district.

    This function returns a dataframe of every AvailabilityFilterArenaSchedulingSetting in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterArenaSchedulingSetting/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterArenaSchedulingSetting/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getAvailabilityFilterArenaSchedulingSetting(AvailabilityFilterArenaSchedulingSettingID, EntityID = 1, returnAvailabilityFilterArenaSchedulingSettingID = False, returnAutoSchedulerCourseSelection = False, returnAutoSchedulerCourseSelectionCode = False, returnAvailabilityFilterCourseStudentID = False, returnAvailableEndDate = False, returnAvailableStartDate = False, returnCreatedTime = False, returnEnableAutoSchedule = False, returnHideRoom = False, returnHideStaff = False, returnLockAfterSubmission = False, returnModifiedTime = False, returnSchedulingEntryEndDate = False, returnSchedulingEntryEndDateTime = False, returnSchedulingEntryEndTime = False, returnSchedulingEntryStartDate = False, returnSchedulingEntryStartDateTime = False, returnSchedulingEntryStartTime = False, returnShowAllClasses = False, returnShowMyAlternateRequests = False, returnShowMyRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterArenaSchedulingSetting/" + str(AvailabilityFilterArenaSchedulingSettingID), verb = "get", return_params_list = return_params)

def modifyAvailabilityFilterArenaSchedulingSetting(AvailabilityFilterArenaSchedulingSettingID, EntityID = 1, setAvailabilityFilterArenaSchedulingSettingID = None, setAutoSchedulerCourseSelection = None, setAutoSchedulerCourseSelectionCode = None, setAvailabilityFilterCourseStudentID = None, setAvailableEndDate = None, setAvailableStartDate = None, setCreatedTime = None, setEnableAutoSchedule = None, setHideRoom = None, setHideStaff = None, setLockAfterSubmission = None, setModifiedTime = None, setSchedulingEntryEndDate = None, setSchedulingEntryEndDateTime = None, setSchedulingEntryEndTime = None, setSchedulingEntryStartDate = None, setSchedulingEntryStartDateTime = None, setSchedulingEntryStartTime = None, setShowAllClasses = None, setShowMyAlternateRequests = None, setShowMyRequests = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityFilterArenaSchedulingSettingID = False, returnAutoSchedulerCourseSelection = False, returnAutoSchedulerCourseSelectionCode = False, returnAvailabilityFilterCourseStudentID = False, returnAvailableEndDate = False, returnAvailableStartDate = False, returnCreatedTime = False, returnEnableAutoSchedule = False, returnHideRoom = False, returnHideStaff = False, returnLockAfterSubmission = False, returnModifiedTime = False, returnSchedulingEntryEndDate = False, returnSchedulingEntryEndDateTime = False, returnSchedulingEntryEndTime = False, returnSchedulingEntryStartDate = False, returnSchedulingEntryStartDateTime = False, returnSchedulingEntryStartTime = False, returnShowAllClasses = False, returnShowMyAlternateRequests = False, returnShowMyRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterArenaSchedulingSetting/" + str(AvailabilityFilterArenaSchedulingSettingID), verb = "post", return_params_list = return_params, payload = payload_params)

def createAvailabilityFilterArenaSchedulingSetting(EntityID = 1, setAvailabilityFilterArenaSchedulingSettingID = None, setAutoSchedulerCourseSelection = None, setAutoSchedulerCourseSelectionCode = None, setAvailabilityFilterCourseStudentID = None, setAvailableEndDate = None, setAvailableStartDate = None, setCreatedTime = None, setEnableAutoSchedule = None, setHideRoom = None, setHideStaff = None, setLockAfterSubmission = None, setModifiedTime = None, setSchedulingEntryEndDate = None, setSchedulingEntryEndDateTime = None, setSchedulingEntryEndTime = None, setSchedulingEntryStartDate = None, setSchedulingEntryStartDateTime = None, setSchedulingEntryStartTime = None, setShowAllClasses = None, setShowMyAlternateRequests = None, setShowMyRequests = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityFilterArenaSchedulingSettingID = False, returnAutoSchedulerCourseSelection = False, returnAutoSchedulerCourseSelectionCode = False, returnAvailabilityFilterCourseStudentID = False, returnAvailableEndDate = False, returnAvailableStartDate = False, returnCreatedTime = False, returnEnableAutoSchedule = False, returnHideRoom = False, returnHideStaff = False, returnLockAfterSubmission = False, returnModifiedTime = False, returnSchedulingEntryEndDate = False, returnSchedulingEntryEndDateTime = False, returnSchedulingEntryEndTime = False, returnSchedulingEntryStartDate = False, returnSchedulingEntryStartDateTime = False, returnSchedulingEntryStartTime = False, returnShowAllClasses = False, returnShowMyAlternateRequests = False, returnShowMyRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterArenaSchedulingSetting/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteAvailabilityFilterArenaSchedulingSetting(AvailabilityFilterArenaSchedulingSettingID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterArenaSchedulingSetting/" + str(AvailabilityFilterArenaSchedulingSettingID), verb = "delete")


def getEveryAvailabilityFilterCourseRequestSetting(searchConditions = [], EntityID = 1, returnAvailabilityFilterCourseRequestSettingID = False, returnAvailabilityFilterCourseStudentID = False, returnAvailableEndDate = False, returnAvailableStartDate = False, returnCreatedTime = False, returnMaximumAlternateCourseRequests = False, returnMaximumAlternateCredits = False, returnMaximumCourseRequests = False, returnMaximumCredits = False, returnModifiedTime = False, returnRequestEntryEndDate = False, returnRequestEntryEndDateTime = False, returnRequestEntryEndTime = False, returnRequestEntryStartDate = False, returnRequestEntryStartDateTime = False, returnRequestEntryStartTime = False, returnUseCourseRequestCountMaximum = False, returnUseCreditsMaximum = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every AvailabilityFilterCourseRequestSetting in the district.

    This function returns a dataframe of every AvailabilityFilterCourseRequestSetting in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseRequestSetting/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseRequestSetting/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getAvailabilityFilterCourseRequestSetting(AvailabilityFilterCourseRequestSettingID, EntityID = 1, returnAvailabilityFilterCourseRequestSettingID = False, returnAvailabilityFilterCourseStudentID = False, returnAvailableEndDate = False, returnAvailableStartDate = False, returnCreatedTime = False, returnMaximumAlternateCourseRequests = False, returnMaximumAlternateCredits = False, returnMaximumCourseRequests = False, returnMaximumCredits = False, returnModifiedTime = False, returnRequestEntryEndDate = False, returnRequestEntryEndDateTime = False, returnRequestEntryEndTime = False, returnRequestEntryStartDate = False, returnRequestEntryStartDateTime = False, returnRequestEntryStartTime = False, returnUseCourseRequestCountMaximum = False, returnUseCreditsMaximum = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseRequestSetting/" + str(AvailabilityFilterCourseRequestSettingID), verb = "get", return_params_list = return_params)

def modifyAvailabilityFilterCourseRequestSetting(AvailabilityFilterCourseRequestSettingID, EntityID = 1, setAvailabilityFilterCourseRequestSettingID = None, setAvailabilityFilterCourseStudentID = None, setAvailableEndDate = None, setAvailableStartDate = None, setCreatedTime = None, setMaximumAlternateCourseRequests = None, setMaximumAlternateCredits = None, setMaximumCourseRequests = None, setMaximumCredits = None, setModifiedTime = None, setRequestEntryEndDate = None, setRequestEntryEndDateTime = None, setRequestEntryEndTime = None, setRequestEntryStartDate = None, setRequestEntryStartDateTime = None, setRequestEntryStartTime = None, setUseCourseRequestCountMaximum = None, setUseCreditsMaximum = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityFilterCourseRequestSettingID = False, returnAvailabilityFilterCourseStudentID = False, returnAvailableEndDate = False, returnAvailableStartDate = False, returnCreatedTime = False, returnMaximumAlternateCourseRequests = False, returnMaximumAlternateCredits = False, returnMaximumCourseRequests = False, returnMaximumCredits = False, returnModifiedTime = False, returnRequestEntryEndDate = False, returnRequestEntryEndDateTime = False, returnRequestEntryEndTime = False, returnRequestEntryStartDate = False, returnRequestEntryStartDateTime = False, returnRequestEntryStartTime = False, returnUseCourseRequestCountMaximum = False, returnUseCreditsMaximum = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseRequestSetting/" + str(AvailabilityFilterCourseRequestSettingID), verb = "post", return_params_list = return_params, payload = payload_params)

def createAvailabilityFilterCourseRequestSetting(EntityID = 1, setAvailabilityFilterCourseRequestSettingID = None, setAvailabilityFilterCourseStudentID = None, setAvailableEndDate = None, setAvailableStartDate = None, setCreatedTime = None, setMaximumAlternateCourseRequests = None, setMaximumAlternateCredits = None, setMaximumCourseRequests = None, setMaximumCredits = None, setModifiedTime = None, setRequestEntryEndDate = None, setRequestEntryEndDateTime = None, setRequestEntryEndTime = None, setRequestEntryStartDate = None, setRequestEntryStartDateTime = None, setRequestEntryStartTime = None, setUseCourseRequestCountMaximum = None, setUseCreditsMaximum = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityFilterCourseRequestSettingID = False, returnAvailabilityFilterCourseStudentID = False, returnAvailableEndDate = False, returnAvailableStartDate = False, returnCreatedTime = False, returnMaximumAlternateCourseRequests = False, returnMaximumAlternateCredits = False, returnMaximumCourseRequests = False, returnMaximumCredits = False, returnModifiedTime = False, returnRequestEntryEndDate = False, returnRequestEntryEndDateTime = False, returnRequestEntryEndTime = False, returnRequestEntryStartDate = False, returnRequestEntryStartDateTime = False, returnRequestEntryStartTime = False, returnUseCourseRequestCountMaximum = False, returnUseCreditsMaximum = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseRequestSetting/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteAvailabilityFilterCourseRequestSetting(AvailabilityFilterCourseRequestSettingID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseRequestSetting/" + str(AvailabilityFilterCourseRequestSettingID), verb = "delete")


def getEveryAvailabilityFilterCourseStudent(searchConditions = [], EntityID = 1, returnAvailabilityFilterCourseStudentID = False, returnArenaSchedulingStartDate = False, returnAvailabilityCourseFilterID = False, returnAvailabilityFilterCourseStudentIDClonedFrom = False, returnAvailabilityStudentFilterID = False, returnCourseRequestStartDate = False, returnCreatedTime = False, returnDescription = False, returnExcludeAvailabilityListBoolUpdatedManually = False, returnExcludeAvailabilityListInNightlyUpdateTask = False, returnModifiedTime = False, returnUseForArenaScheduling = False, returnUseForCourseRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every AvailabilityFilterCourseStudent in the district.

    This function returns a dataframe of every AvailabilityFilterCourseStudent in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudent/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudent/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getAvailabilityFilterCourseStudent(AvailabilityFilterCourseStudentID, EntityID = 1, returnAvailabilityFilterCourseStudentID = False, returnArenaSchedulingStartDate = False, returnAvailabilityCourseFilterID = False, returnAvailabilityFilterCourseStudentIDClonedFrom = False, returnAvailabilityStudentFilterID = False, returnCourseRequestStartDate = False, returnCreatedTime = False, returnDescription = False, returnExcludeAvailabilityListBoolUpdatedManually = False, returnExcludeAvailabilityListInNightlyUpdateTask = False, returnModifiedTime = False, returnUseForArenaScheduling = False, returnUseForCourseRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudent/" + str(AvailabilityFilterCourseStudentID), verb = "get", return_params_list = return_params)

def modifyAvailabilityFilterCourseStudent(AvailabilityFilterCourseStudentID, EntityID = 1, setAvailabilityFilterCourseStudentID = None, setArenaSchedulingStartDate = None, setAvailabilityCourseFilterID = None, setAvailabilityFilterCourseStudentIDClonedFrom = None, setAvailabilityStudentFilterID = None, setCourseRequestStartDate = None, setCreatedTime = None, setDescription = None, setExcludeAvailabilityListBoolUpdatedManually = None, setExcludeAvailabilityListInNightlyUpdateTask = None, setModifiedTime = None, setUseForArenaScheduling = None, setUseForCourseRequests = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityFilterCourseStudentID = False, returnArenaSchedulingStartDate = False, returnAvailabilityCourseFilterID = False, returnAvailabilityFilterCourseStudentIDClonedFrom = False, returnAvailabilityStudentFilterID = False, returnCourseRequestStartDate = False, returnCreatedTime = False, returnDescription = False, returnExcludeAvailabilityListBoolUpdatedManually = False, returnExcludeAvailabilityListInNightlyUpdateTask = False, returnModifiedTime = False, returnUseForArenaScheduling = False, returnUseForCourseRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudent/" + str(AvailabilityFilterCourseStudentID), verb = "post", return_params_list = return_params, payload = payload_params)

def createAvailabilityFilterCourseStudent(EntityID = 1, setAvailabilityFilterCourseStudentID = None, setArenaSchedulingStartDate = None, setAvailabilityCourseFilterID = None, setAvailabilityFilterCourseStudentIDClonedFrom = None, setAvailabilityStudentFilterID = None, setCourseRequestStartDate = None, setCreatedTime = None, setDescription = None, setExcludeAvailabilityListBoolUpdatedManually = None, setExcludeAvailabilityListInNightlyUpdateTask = None, setModifiedTime = None, setUseForArenaScheduling = None, setUseForCourseRequests = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityFilterCourseStudentID = False, returnArenaSchedulingStartDate = False, returnAvailabilityCourseFilterID = False, returnAvailabilityFilterCourseStudentIDClonedFrom = False, returnAvailabilityStudentFilterID = False, returnCourseRequestStartDate = False, returnCreatedTime = False, returnDescription = False, returnExcludeAvailabilityListBoolUpdatedManually = False, returnExcludeAvailabilityListInNightlyUpdateTask = False, returnModifiedTime = False, returnUseForArenaScheduling = False, returnUseForCourseRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudent/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteAvailabilityFilterCourseStudent(AvailabilityFilterCourseStudentID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudent/" + str(AvailabilityFilterCourseStudentID), verb = "delete")


def getEveryAvailabilityFilterCourseStudentCourse(searchConditions = [], EntityID = 1, returnAvailabilityFilterCourseStudentCourseID = False, returnAvailabilityFilterCourseStudentID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every AvailabilityFilterCourseStudentCourse in the district.

    This function returns a dataframe of every AvailabilityFilterCourseStudentCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getAvailabilityFilterCourseStudentCourse(AvailabilityFilterCourseStudentCourseID, EntityID = 1, returnAvailabilityFilterCourseStudentCourseID = False, returnAvailabilityFilterCourseStudentID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentCourse/" + str(AvailabilityFilterCourseStudentCourseID), verb = "get", return_params_list = return_params)

def modifyAvailabilityFilterCourseStudentCourse(AvailabilityFilterCourseStudentCourseID, EntityID = 1, setAvailabilityFilterCourseStudentCourseID = None, setAvailabilityFilterCourseStudentID = None, setCourseID = None, setCreatedTime = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityFilterCourseStudentCourseID = False, returnAvailabilityFilterCourseStudentID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentCourse/" + str(AvailabilityFilterCourseStudentCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createAvailabilityFilterCourseStudentCourse(EntityID = 1, setAvailabilityFilterCourseStudentCourseID = None, setAvailabilityFilterCourseStudentID = None, setCourseID = None, setCreatedTime = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityFilterCourseStudentCourseID = False, returnAvailabilityFilterCourseStudentID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteAvailabilityFilterCourseStudentCourse(AvailabilityFilterCourseStudentCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentCourse/" + str(AvailabilityFilterCourseStudentCourseID), verb = "delete")


def getEveryAvailabilityFilterCourseStudentStudent(searchConditions = [], EntityID = 1, returnAvailabilityFilterCourseStudentStudentID = False, returnArenaSchedulingStatus = False, returnArenaSchedulingStatusCode = False, returnAvailabilityFilterCourseStudentID = False, returnCreatedTime = False, returnModifiedTime = False, returnStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every AvailabilityFilterCourseStudentStudent in the district.

    This function returns a dataframe of every AvailabilityFilterCourseStudentStudent in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentStudent/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentStudent/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getAvailabilityFilterCourseStudentStudent(AvailabilityFilterCourseStudentStudentID, EntityID = 1, returnAvailabilityFilterCourseStudentStudentID = False, returnArenaSchedulingStatus = False, returnArenaSchedulingStatusCode = False, returnAvailabilityFilterCourseStudentID = False, returnCreatedTime = False, returnModifiedTime = False, returnStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentStudent/" + str(AvailabilityFilterCourseStudentStudentID), verb = "get", return_params_list = return_params)

def modifyAvailabilityFilterCourseStudentStudent(AvailabilityFilterCourseStudentStudentID, EntityID = 1, setAvailabilityFilterCourseStudentStudentID = None, setArenaSchedulingStatus = None, setArenaSchedulingStatusCode = None, setAvailabilityFilterCourseStudentID = None, setCreatedTime = None, setModifiedTime = None, setStudentID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityFilterCourseStudentStudentID = False, returnArenaSchedulingStatus = False, returnArenaSchedulingStatusCode = False, returnAvailabilityFilterCourseStudentID = False, returnCreatedTime = False, returnModifiedTime = False, returnStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentStudent/" + str(AvailabilityFilterCourseStudentStudentID), verb = "post", return_params_list = return_params, payload = payload_params)

def createAvailabilityFilterCourseStudentStudent(EntityID = 1, setAvailabilityFilterCourseStudentStudentID = None, setArenaSchedulingStatus = None, setArenaSchedulingStatusCode = None, setAvailabilityFilterCourseStudentID = None, setCreatedTime = None, setModifiedTime = None, setStudentID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityFilterCourseStudentStudentID = False, returnArenaSchedulingStatus = False, returnArenaSchedulingStatusCode = False, returnAvailabilityFilterCourseStudentID = False, returnCreatedTime = False, returnModifiedTime = False, returnStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentStudent/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteAvailabilityFilterCourseStudentStudent(AvailabilityFilterCourseStudentStudentID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityFilterCourseStudentStudent/" + str(AvailabilityFilterCourseStudentStudentID), verb = "delete")


def getEveryAvailabilityStudentFilter(searchConditions = [], EntityID = 1, returnAvailabilityStudentFilterID = False, returnAvailabilityStudentFilterIDClonedFrom = False, returnAvailabilityStudentFilterIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnFilter = False, returnGradeReferenceIDInclusionList = False, returnModifiedTime = False, returnSchoolYearID = False, returnSkywardID = False, returnStudentTypeIDInclusionList = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every AvailabilityStudentFilter in the district.

    This function returns a dataframe of every AvailabilityStudentFilter in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityStudentFilter/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityStudentFilter/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getAvailabilityStudentFilter(AvailabilityStudentFilterID, EntityID = 1, returnAvailabilityStudentFilterID = False, returnAvailabilityStudentFilterIDClonedFrom = False, returnAvailabilityStudentFilterIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnFilter = False, returnGradeReferenceIDInclusionList = False, returnModifiedTime = False, returnSchoolYearID = False, returnSkywardID = False, returnStudentTypeIDInclusionList = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityStudentFilter/" + str(AvailabilityStudentFilterID), verb = "get", return_params_list = return_params)

def modifyAvailabilityStudentFilter(AvailabilityStudentFilterID, EntityID = 1, setAvailabilityStudentFilterID = None, setAvailabilityStudentFilterIDClonedFrom = None, setAvailabilityStudentFilterIDClonedTo = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEntityID = None, setFilter = None, setGradeReferenceIDInclusionList = None, setModifiedTime = None, setSchoolYearID = None, setSkywardID = None, setStudentTypeIDInclusionList = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityStudentFilterID = False, returnAvailabilityStudentFilterIDClonedFrom = False, returnAvailabilityStudentFilterIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnFilter = False, returnGradeReferenceIDInclusionList = False, returnModifiedTime = False, returnSchoolYearID = False, returnSkywardID = False, returnStudentTypeIDInclusionList = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityStudentFilter/" + str(AvailabilityStudentFilterID), verb = "post", return_params_list = return_params, payload = payload_params)

def createAvailabilityStudentFilter(EntityID = 1, setAvailabilityStudentFilterID = None, setAvailabilityStudentFilterIDClonedFrom = None, setAvailabilityStudentFilterIDClonedTo = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEntityID = None, setFilter = None, setGradeReferenceIDInclusionList = None, setModifiedTime = None, setSchoolYearID = None, setSkywardID = None, setStudentTypeIDInclusionList = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnAvailabilityStudentFilterID = False, returnAvailabilityStudentFilterIDClonedFrom = False, returnAvailabilityStudentFilterIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnFilter = False, returnGradeReferenceIDInclusionList = False, returnModifiedTime = False, returnSchoolYearID = False, returnSkywardID = False, returnStudentTypeIDInclusionList = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityStudentFilter/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteAvailabilityStudentFilter(AvailabilityStudentFilterID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/AvailabilityStudentFilter/" + str(AvailabilityStudentFilterID), verb = "delete")


def getEveryBaseRunAnalysis(searchConditions = [], EntityID = 1, returnBaseRunAnalysisID = False, returnCreatedTime = False, returnEntityID = False, returnModifiedTime = False, returnRunType = False, returnRunTypeCode = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every BaseRunAnalysis in the district.

    This function returns a dataframe of every BaseRunAnalysis in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BaseRunAnalysis/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BaseRunAnalysis/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getBaseRunAnalysis(BaseRunAnalysisID, EntityID = 1, returnBaseRunAnalysisID = False, returnCreatedTime = False, returnEntityID = False, returnModifiedTime = False, returnRunType = False, returnRunTypeCode = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BaseRunAnalysis/" + str(BaseRunAnalysisID), verb = "get", return_params_list = return_params)

def modifyBaseRunAnalysis(BaseRunAnalysisID, EntityID = 1, setBaseRunAnalysisID = None, setCreatedTime = None, setEntityID = None, setModifiedTime = None, setRunType = None, setRunTypeCode = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUserIDPerformer = None, returnBaseRunAnalysisID = False, returnCreatedTime = False, returnEntityID = False, returnModifiedTime = False, returnRunType = False, returnRunTypeCode = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BaseRunAnalysis/" + str(BaseRunAnalysisID), verb = "post", return_params_list = return_params, payload = payload_params)

def createBaseRunAnalysis(EntityID = 1, setBaseRunAnalysisID = None, setCreatedTime = None, setEntityID = None, setModifiedTime = None, setRunType = None, setRunTypeCode = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUserIDPerformer = None, returnBaseRunAnalysisID = False, returnCreatedTime = False, returnEntityID = False, returnModifiedTime = False, returnRunType = False, returnRunTypeCode = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BaseRunAnalysis/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteBaseRunAnalysis(BaseRunAnalysisID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BaseRunAnalysis/" + str(BaseRunAnalysisID), verb = "delete")


def getEveryBlockPeriod(searchConditions = [], EntityID = 1, returnBlockPeriodID = False, returnBlockPeriodIDClonedFrom = False, returnBlockPeriodIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnHasDisplayPeriods = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every BlockPeriod in the district.

    This function returns a dataframe of every BlockPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getBlockPeriod(BlockPeriodID, EntityID = 1, returnBlockPeriodID = False, returnBlockPeriodIDClonedFrom = False, returnBlockPeriodIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnHasDisplayPeriods = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriod/" + str(BlockPeriodID), verb = "get", return_params_list = return_params)

def modifyBlockPeriod(BlockPeriodID, EntityID = 1, setBlockPeriodID = None, setBlockPeriodIDClonedFrom = None, setBlockPeriodIDClonedTo = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEntityID = None, setHasDisplayPeriods = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnBlockPeriodID = False, returnBlockPeriodIDClonedFrom = False, returnBlockPeriodIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnHasDisplayPeriods = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriod/" + str(BlockPeriodID), verb = "post", return_params_list = return_params, payload = payload_params)

def createBlockPeriod(EntityID = 1, setBlockPeriodID = None, setBlockPeriodIDClonedFrom = None, setBlockPeriodIDClonedTo = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEntityID = None, setHasDisplayPeriods = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnBlockPeriodID = False, returnBlockPeriodIDClonedFrom = False, returnBlockPeriodIDClonedTo = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnHasDisplayPeriods = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteBlockPeriod(BlockPeriodID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriod/" + str(BlockPeriodID), verb = "delete")


def getEveryBlockPeriodDisplayPeriod(searchConditions = [], EntityID = 1, returnBlockPeriodDisplayPeriodID = False, returnBlockPeriodDisplayPeriodIDClonedFrom = False, returnBlockPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every BlockPeriodDisplayPeriod in the district.

    This function returns a dataframe of every BlockPeriodDisplayPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriodDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriodDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getBlockPeriodDisplayPeriod(BlockPeriodDisplayPeriodID, EntityID = 1, returnBlockPeriodDisplayPeriodID = False, returnBlockPeriodDisplayPeriodIDClonedFrom = False, returnBlockPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriodDisplayPeriod/" + str(BlockPeriodDisplayPeriodID), verb = "get", return_params_list = return_params)

def modifyBlockPeriodDisplayPeriod(BlockPeriodDisplayPeriodID, EntityID = 1, setBlockPeriodDisplayPeriodID = None, setBlockPeriodDisplayPeriodIDClonedFrom = None, setBlockPeriodID = None, setCreatedTime = None, setDisplayPeriodID = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnBlockPeriodDisplayPeriodID = False, returnBlockPeriodDisplayPeriodIDClonedFrom = False, returnBlockPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriodDisplayPeriod/" + str(BlockPeriodDisplayPeriodID), verb = "post", return_params_list = return_params, payload = payload_params)

def createBlockPeriodDisplayPeriod(EntityID = 1, setBlockPeriodDisplayPeriodID = None, setBlockPeriodDisplayPeriodIDClonedFrom = None, setBlockPeriodID = None, setCreatedTime = None, setDisplayPeriodID = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnBlockPeriodDisplayPeriodID = False, returnBlockPeriodDisplayPeriodIDClonedFrom = False, returnBlockPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriodDisplayPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteBlockPeriodDisplayPeriod(BlockPeriodDisplayPeriodID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/BlockPeriodDisplayPeriod/" + str(BlockPeriodDisplayPeriodID), verb = "delete")


def getEveryConfigEntityYear(searchConditions = [], EntityID = 1, returnConfigEntityYearID = False, returnArenaSchedulingConfirmationScreenMessage = False, returnConfigEntityYearIDClonedFrom = False, returnCreatedTime = False, returnEnableArenaSchedulingConfirmationScreen = False, returnEnableValidationOfRoomCapacityDuringStudentSectionEnrollment = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every ConfigEntityYear in the district.

    This function returns a dataframe of every ConfigEntityYear in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ConfigEntityYear/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ConfigEntityYear/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getConfigEntityYear(ConfigEntityYearID, EntityID = 1, returnConfigEntityYearID = False, returnArenaSchedulingConfirmationScreenMessage = False, returnConfigEntityYearIDClonedFrom = False, returnCreatedTime = False, returnEnableArenaSchedulingConfirmationScreen = False, returnEnableValidationOfRoomCapacityDuringStudentSectionEnrollment = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ConfigEntityYear/" + str(ConfigEntityYearID), verb = "get", return_params_list = return_params)

def modifyConfigEntityYear(ConfigEntityYearID, EntityID = 1, setConfigEntityYearID = None, setArenaSchedulingConfirmationScreenMessage = None, setConfigEntityYearIDClonedFrom = None, setCreatedTime = None, setEnableArenaSchedulingConfirmationScreen = None, setEnableValidationOfRoomCapacityDuringStudentSectionEnrollment = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnConfigEntityYearID = False, returnArenaSchedulingConfirmationScreenMessage = False, returnConfigEntityYearIDClonedFrom = False, returnCreatedTime = False, returnEnableArenaSchedulingConfirmationScreen = False, returnEnableValidationOfRoomCapacityDuringStudentSectionEnrollment = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ConfigEntityYear/" + str(ConfigEntityYearID), verb = "post", return_params_list = return_params, payload = payload_params)

def createConfigEntityYear(EntityID = 1, setConfigEntityYearID = None, setArenaSchedulingConfirmationScreenMessage = None, setConfigEntityYearIDClonedFrom = None, setCreatedTime = None, setEnableArenaSchedulingConfirmationScreen = None, setEnableValidationOfRoomCapacityDuringStudentSectionEnrollment = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnConfigEntityYearID = False, returnArenaSchedulingConfirmationScreenMessage = False, returnConfigEntityYearIDClonedFrom = False, returnCreatedTime = False, returnEnableArenaSchedulingConfirmationScreen = False, returnEnableValidationOfRoomCapacityDuringStudentSectionEnrollment = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ConfigEntityYear/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteConfigEntityYear(ConfigEntityYearID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ConfigEntityYear/" + str(ConfigEntityYearID), verb = "delete")


def getEveryCourseAlternate(searchConditions = [], EntityID = 1, returnCourseAlternateID = False, returnCourseAlternateIDClonedFrom = False, returnCourseIDAlternate = False, returnCourseIDPrimary = False, returnCreatedTime = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseAlternate in the district.

    This function returns a dataframe of every CourseAlternate in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseAlternate/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseAlternate/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseAlternate(CourseAlternateID, EntityID = 1, returnCourseAlternateID = False, returnCourseAlternateIDClonedFrom = False, returnCourseIDAlternate = False, returnCourseIDPrimary = False, returnCreatedTime = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseAlternate/" + str(CourseAlternateID), verb = "get", return_params_list = return_params)

def modifyCourseAlternate(CourseAlternateID, EntityID = 1, setCourseAlternateID = None, setCourseAlternateIDClonedFrom = None, setCourseIDAlternate = None, setCourseIDPrimary = None, setCreatedTime = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseAlternateID = False, returnCourseAlternateIDClonedFrom = False, returnCourseIDAlternate = False, returnCourseIDPrimary = False, returnCreatedTime = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseAlternate/" + str(CourseAlternateID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseAlternate(EntityID = 1, setCourseAlternateID = None, setCourseAlternateIDClonedFrom = None, setCourseIDAlternate = None, setCourseIDPrimary = None, setCreatedTime = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseAlternateID = False, returnCourseAlternateIDClonedFrom = False, returnCourseIDAlternate = False, returnCourseIDPrimary = False, returnCreatedTime = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseAlternate/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseAlternate(CourseAlternateID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseAlternate/" + str(CourseAlternateID), verb = "delete")


def getEveryCourseCorequisiteGroup(searchConditions = [], EntityID = 1, returnCourseCorequisiteGroupID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnCourseCorequisiteGroupIDClonedFrom = False, returnCourseCorequisiteGroupIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnDisplayPeriodMatch = False, returnDisplayPeriodMatchCode = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnOverlap = False, returnOverlapCode = False, returnScheduleAllCoursesInGroupOrNone = False, returnSchoolYearID = False, returnStaffMatch = False, returnStaffMatchCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseCorequisiteGroup in the district.

    This function returns a dataframe of every CourseCorequisiteGroup in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroup/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroup/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseCorequisiteGroup(CourseCorequisiteGroupID, EntityID = 1, returnCourseCorequisiteGroupID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnCourseCorequisiteGroupIDClonedFrom = False, returnCourseCorequisiteGroupIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnDisplayPeriodMatch = False, returnDisplayPeriodMatchCode = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnOverlap = False, returnOverlapCode = False, returnScheduleAllCoursesInGroupOrNone = False, returnSchoolYearID = False, returnStaffMatch = False, returnStaffMatchCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroup/" + str(CourseCorequisiteGroupID), verb = "get", return_params_list = return_params)

def modifyCourseCorequisiteGroup(CourseCorequisiteGroupID, EntityID = 1, setCourseCorequisiteGroupID = None, setAutomaticRequestSetting = None, setAutomaticRequestSettingCode = None, setCourseCorequisiteGroupIDClonedFrom = None, setCourseCorequisiteGroupIDClonedTo = None, setCreatedTime = None, setDescription = None, setDisplayPeriodMatch = None, setDisplayPeriodMatchCode = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setName = None, setNameDescription = None, setOverlap = None, setOverlapCode = None, setScheduleAllCoursesInGroupOrNone = None, setSchoolYearID = None, setStaffMatch = None, setStaffMatchCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseCorequisiteGroupID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnCourseCorequisiteGroupIDClonedFrom = False, returnCourseCorequisiteGroupIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnDisplayPeriodMatch = False, returnDisplayPeriodMatchCode = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnOverlap = False, returnOverlapCode = False, returnScheduleAllCoursesInGroupOrNone = False, returnSchoolYearID = False, returnStaffMatch = False, returnStaffMatchCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroup/" + str(CourseCorequisiteGroupID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseCorequisiteGroup(EntityID = 1, setCourseCorequisiteGroupID = None, setAutomaticRequestSetting = None, setAutomaticRequestSettingCode = None, setCourseCorequisiteGroupIDClonedFrom = None, setCourseCorequisiteGroupIDClonedTo = None, setCreatedTime = None, setDescription = None, setDisplayPeriodMatch = None, setDisplayPeriodMatchCode = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setName = None, setNameDescription = None, setOverlap = None, setOverlapCode = None, setScheduleAllCoursesInGroupOrNone = None, setSchoolYearID = None, setStaffMatch = None, setStaffMatchCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseCorequisiteGroupID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnCourseCorequisiteGroupIDClonedFrom = False, returnCourseCorequisiteGroupIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnDisplayPeriodMatch = False, returnDisplayPeriodMatchCode = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnOverlap = False, returnOverlapCode = False, returnScheduleAllCoursesInGroupOrNone = False, returnSchoolYearID = False, returnStaffMatch = False, returnStaffMatchCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroup/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseCorequisiteGroup(CourseCorequisiteGroupID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroup/" + str(CourseCorequisiteGroupID), verb = "delete")


def getEveryCourseCorequisiteGroupCourse(searchConditions = [], EntityID = 1, returnCourseCorequisiteGroupCourseID = False, returnCourseCorequisiteGroupCourseIDClonedFrom = False, returnCourseCorequisiteGroupID = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseCorequisiteGroupCourse in the district.

    This function returns a dataframe of every CourseCorequisiteGroupCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroupCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroupCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseCorequisiteGroupCourse(CourseCorequisiteGroupCourseID, EntityID = 1, returnCourseCorequisiteGroupCourseID = False, returnCourseCorequisiteGroupCourseIDClonedFrom = False, returnCourseCorequisiteGroupID = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroupCourse/" + str(CourseCorequisiteGroupCourseID), verb = "get", return_params_list = return_params)

def modifyCourseCorequisiteGroupCourse(CourseCorequisiteGroupCourseID, EntityID = 1, setCourseCorequisiteGroupCourseID = None, setCourseCorequisiteGroupCourseIDClonedFrom = None, setCourseCorequisiteGroupID = None, setCourseID = None, setCreatedTime = None, setEntityGroupKey = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseCorequisiteGroupCourseID = False, returnCourseCorequisiteGroupCourseIDClonedFrom = False, returnCourseCorequisiteGroupID = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroupCourse/" + str(CourseCorequisiteGroupCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseCorequisiteGroupCourse(EntityID = 1, setCourseCorequisiteGroupCourseID = None, setCourseCorequisiteGroupCourseIDClonedFrom = None, setCourseCorequisiteGroupID = None, setCourseID = None, setCreatedTime = None, setEntityGroupKey = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseCorequisiteGroupCourseID = False, returnCourseCorequisiteGroupCourseIDClonedFrom = False, returnCourseCorequisiteGroupID = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroupCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseCorequisiteGroupCourse(CourseCorequisiteGroupCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCorequisiteGroupCourse/" + str(CourseCorequisiteGroupCourseID), verb = "delete")


def getEveryCourseCustomRequirement(searchConditions = [], EntityID = 1, returnCourseCustomRequirementID = False, returnCourseCustomRequirementIDClonedFrom = False, returnCourseID = False, returnCreatedTime = False, returnCustomRequirementID = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseCustomRequirement in the district.

    This function returns a dataframe of every CourseCustomRequirement in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCustomRequirement/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCustomRequirement/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseCustomRequirement(CourseCustomRequirementID, EntityID = 1, returnCourseCustomRequirementID = False, returnCourseCustomRequirementIDClonedFrom = False, returnCourseID = False, returnCreatedTime = False, returnCustomRequirementID = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCustomRequirement/" + str(CourseCustomRequirementID), verb = "get", return_params_list = return_params)

def modifyCourseCustomRequirement(CourseCustomRequirementID, EntityID = 1, setCourseCustomRequirementID = None, setCourseCustomRequirementIDClonedFrom = None, setCourseID = None, setCreatedTime = None, setCustomRequirementID = None, setEntityGroupKey = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseCustomRequirementID = False, returnCourseCustomRequirementIDClonedFrom = False, returnCourseID = False, returnCreatedTime = False, returnCustomRequirementID = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCustomRequirement/" + str(CourseCustomRequirementID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseCustomRequirement(EntityID = 1, setCourseCustomRequirementID = None, setCourseCustomRequirementIDClonedFrom = None, setCourseID = None, setCreatedTime = None, setCustomRequirementID = None, setEntityGroupKey = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseCustomRequirementID = False, returnCourseCustomRequirementIDClonedFrom = False, returnCourseID = False, returnCreatedTime = False, returnCustomRequirementID = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCustomRequirement/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseCustomRequirement(CourseCustomRequirementID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseCustomRequirement/" + str(CourseCustomRequirementID), verb = "delete")


def getEveryCourseEntityOfferedTo(searchConditions = [], EntityID = 1, returnCourseEntityOfferedToID = False, returnActiveSections = False, returnActiveSectionsOpen = False, returnCourseCode = False, returnCourseEntityOfferedToIDClonedFrom = False, returnCourseEntityOfferedToIDClonedTo = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnEntityIDOfferedTo = False, returnHasStudentCourseRequestsEntity = False, returnIsActive = False, returnIsAutoOffering = False, returnIsCurrentSchoolYearEntity = False, returnIsHomeCourse = False, returnIsOfferedCourse = False, returnIsRequired = False, returnIsRequiredOverride = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequestsEntity = False, returnNumberOfCourseRequestsEntity = False, returnNumberOfCourseRequestsFemalesEntity = False, returnNumberOfCourseRequestsMalesEntity = False, returnNumberOfSeatsRemainingEntity = False, returnNumberTransferStudentSectionsEntity = False, returnRequired = False, returnSchedulingPriorityCode = False, returnSchedulingPriorityOverride = False, returnSchedulingPriorityOverrideCode = False, returnSchedulingTypeCode = False, returnSchedulingTypeOverride = False, returnSchedulingTypeOverrideCode = False, returnSchoolYearID = False, returnTotalSeatsAvailable = False, returnTotalSectionCountEntity = False, returnTotalStudentCourseRequestSectionLengthSubsetCountEntity = False, returnTotalStudentSectionCountEntity = False, returnUseIsRequiredOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUseSchedulingPriorityOverride = False, returnUseSchedulingTypeOverride = False, returnViewingFromOfferedEntity = False, returnViewingFromOfferingEntity = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseEntityOfferedTo in the district.

    This function returns a dataframe of every CourseEntityOfferedTo in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedTo/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedTo/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseEntityOfferedTo(CourseEntityOfferedToID, EntityID = 1, returnCourseEntityOfferedToID = False, returnActiveSections = False, returnActiveSectionsOpen = False, returnCourseCode = False, returnCourseEntityOfferedToIDClonedFrom = False, returnCourseEntityOfferedToIDClonedTo = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnEntityIDOfferedTo = False, returnHasStudentCourseRequestsEntity = False, returnIsActive = False, returnIsAutoOffering = False, returnIsCurrentSchoolYearEntity = False, returnIsHomeCourse = False, returnIsOfferedCourse = False, returnIsRequired = False, returnIsRequiredOverride = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequestsEntity = False, returnNumberOfCourseRequestsEntity = False, returnNumberOfCourseRequestsFemalesEntity = False, returnNumberOfCourseRequestsMalesEntity = False, returnNumberOfSeatsRemainingEntity = False, returnNumberTransferStudentSectionsEntity = False, returnRequired = False, returnSchedulingPriorityCode = False, returnSchedulingPriorityOverride = False, returnSchedulingPriorityOverrideCode = False, returnSchedulingTypeCode = False, returnSchedulingTypeOverride = False, returnSchedulingTypeOverrideCode = False, returnSchoolYearID = False, returnTotalSeatsAvailable = False, returnTotalSectionCountEntity = False, returnTotalStudentCourseRequestSectionLengthSubsetCountEntity = False, returnTotalStudentSectionCountEntity = False, returnUseIsRequiredOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUseSchedulingPriorityOverride = False, returnUseSchedulingTypeOverride = False, returnViewingFromOfferedEntity = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedTo/" + str(CourseEntityOfferedToID), verb = "get", return_params_list = return_params)

def modifyCourseEntityOfferedTo(CourseEntityOfferedToID, EntityID = 1, setCourseEntityOfferedToID = None, setActiveSections = None, setActiveSectionsOpen = None, setCourseCode = None, setCourseEntityOfferedToIDClonedFrom = None, setCourseEntityOfferedToIDClonedTo = None, setCourseID = None, setCreatedTime = None, setEntityGroupKey = None, setEntityIDOfferedTo = None, setHasStudentCourseRequestsEntity = None, setIsActive = None, setIsAutoOffering = None, setIsCurrentSchoolYearEntity = None, setIsHomeCourse = None, setIsOfferedCourse = None, setIsRequired = None, setIsRequiredOverride = None, setModifiedTime = None, setNumberOfAlternateCourseRequestsEntity = None, setNumberOfCourseRequestsEntity = None, setNumberOfCourseRequestsFemalesEntity = None, setNumberOfCourseRequestsMalesEntity = None, setNumberOfSeatsRemainingEntity = None, setNumberTransferStudentSectionsEntity = None, setRequired = None, setSchedulingPriorityCode = None, setSchedulingPriorityOverride = None, setSchedulingPriorityOverrideCode = None, setSchedulingTypeCode = None, setSchedulingTypeOverride = None, setSchedulingTypeOverrideCode = None, setSchoolYearID = None, setTotalSeatsAvailable = None, setTotalSectionCountEntity = None, setTotalStudentCourseRequestSectionLengthSubsetCountEntity = None, setTotalStudentSectionCountEntity = None, setUseIsRequiredOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUseSchedulingPriorityOverride = None, setUseSchedulingTypeOverride = None, setViewingFromOfferedEntity = None, setViewingFromOfferingEntity = None, returnCourseEntityOfferedToID = False, returnActiveSections = False, returnActiveSectionsOpen = False, returnCourseCode = False, returnCourseEntityOfferedToIDClonedFrom = False, returnCourseEntityOfferedToIDClonedTo = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnEntityIDOfferedTo = False, returnHasStudentCourseRequestsEntity = False, returnIsActive = False, returnIsAutoOffering = False, returnIsCurrentSchoolYearEntity = False, returnIsHomeCourse = False, returnIsOfferedCourse = False, returnIsRequired = False, returnIsRequiredOverride = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequestsEntity = False, returnNumberOfCourseRequestsEntity = False, returnNumberOfCourseRequestsFemalesEntity = False, returnNumberOfCourseRequestsMalesEntity = False, returnNumberOfSeatsRemainingEntity = False, returnNumberTransferStudentSectionsEntity = False, returnRequired = False, returnSchedulingPriorityCode = False, returnSchedulingPriorityOverride = False, returnSchedulingPriorityOverrideCode = False, returnSchedulingTypeCode = False, returnSchedulingTypeOverride = False, returnSchedulingTypeOverrideCode = False, returnSchoolYearID = False, returnTotalSeatsAvailable = False, returnTotalSectionCountEntity = False, returnTotalStudentCourseRequestSectionLengthSubsetCountEntity = False, returnTotalStudentSectionCountEntity = False, returnUseIsRequiredOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUseSchedulingPriorityOverride = False, returnUseSchedulingTypeOverride = False, returnViewingFromOfferedEntity = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedTo/" + str(CourseEntityOfferedToID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseEntityOfferedTo(EntityID = 1, setCourseEntityOfferedToID = None, setActiveSections = None, setActiveSectionsOpen = None, setCourseCode = None, setCourseEntityOfferedToIDClonedFrom = None, setCourseEntityOfferedToIDClonedTo = None, setCourseID = None, setCreatedTime = None, setEntityGroupKey = None, setEntityIDOfferedTo = None, setHasStudentCourseRequestsEntity = None, setIsActive = None, setIsAutoOffering = None, setIsCurrentSchoolYearEntity = None, setIsHomeCourse = None, setIsOfferedCourse = None, setIsRequired = None, setIsRequiredOverride = None, setModifiedTime = None, setNumberOfAlternateCourseRequestsEntity = None, setNumberOfCourseRequestsEntity = None, setNumberOfCourseRequestsFemalesEntity = None, setNumberOfCourseRequestsMalesEntity = None, setNumberOfSeatsRemainingEntity = None, setNumberTransferStudentSectionsEntity = None, setRequired = None, setSchedulingPriorityCode = None, setSchedulingPriorityOverride = None, setSchedulingPriorityOverrideCode = None, setSchedulingTypeCode = None, setSchedulingTypeOverride = None, setSchedulingTypeOverrideCode = None, setSchoolYearID = None, setTotalSeatsAvailable = None, setTotalSectionCountEntity = None, setTotalStudentCourseRequestSectionLengthSubsetCountEntity = None, setTotalStudentSectionCountEntity = None, setUseIsRequiredOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUseSchedulingPriorityOverride = None, setUseSchedulingTypeOverride = None, setViewingFromOfferedEntity = None, setViewingFromOfferingEntity = None, returnCourseEntityOfferedToID = False, returnActiveSections = False, returnActiveSectionsOpen = False, returnCourseCode = False, returnCourseEntityOfferedToIDClonedFrom = False, returnCourseEntityOfferedToIDClonedTo = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnEntityIDOfferedTo = False, returnHasStudentCourseRequestsEntity = False, returnIsActive = False, returnIsAutoOffering = False, returnIsCurrentSchoolYearEntity = False, returnIsHomeCourse = False, returnIsOfferedCourse = False, returnIsRequired = False, returnIsRequiredOverride = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequestsEntity = False, returnNumberOfCourseRequestsEntity = False, returnNumberOfCourseRequestsFemalesEntity = False, returnNumberOfCourseRequestsMalesEntity = False, returnNumberOfSeatsRemainingEntity = False, returnNumberTransferStudentSectionsEntity = False, returnRequired = False, returnSchedulingPriorityCode = False, returnSchedulingPriorityOverride = False, returnSchedulingPriorityOverrideCode = False, returnSchedulingTypeCode = False, returnSchedulingTypeOverride = False, returnSchedulingTypeOverrideCode = False, returnSchoolYearID = False, returnTotalSeatsAvailable = False, returnTotalSectionCountEntity = False, returnTotalStudentCourseRequestSectionLengthSubsetCountEntity = False, returnTotalStudentSectionCountEntity = False, returnUseIsRequiredOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUseSchedulingPriorityOverride = False, returnUseSchedulingTypeOverride = False, returnViewingFromOfferedEntity = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedTo/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseEntityOfferedTo(CourseEntityOfferedToID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedTo/" + str(CourseEntityOfferedToID), verb = "delete")


def getEveryCourseEntityOfferedToSection(searchConditions = [], EntityID = 1, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToID = False, returnCourseEntityOfferedToSectionIDClonedFrom = False, returnCourseEntityOfferedToSectionIDClonedTo = False, returnCourseID = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnHasMeetDisplayPeriodOverrides = False, returnIsActive = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnRoomSeatsAvailable = False, returnSchoolYearID = False, returnSeatsAvailableEntity = False, returnSectionID = False, returnStudentEnrollmentEntity = False, returnTotalEnrollmentCountEntity = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferedEntity = False, returnViewingFromOfferingEntity = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseEntityOfferedToSection in the district.

    This function returns a dataframe of every CourseEntityOfferedToSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseEntityOfferedToSection(CourseEntityOfferedToSectionID, EntityID = 1, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToID = False, returnCourseEntityOfferedToSectionIDClonedFrom = False, returnCourseEntityOfferedToSectionIDClonedTo = False, returnCourseID = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnHasMeetDisplayPeriodOverrides = False, returnIsActive = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnRoomSeatsAvailable = False, returnSchoolYearID = False, returnSeatsAvailableEntity = False, returnSectionID = False, returnStudentEnrollmentEntity = False, returnTotalEnrollmentCountEntity = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferedEntity = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSection/" + str(CourseEntityOfferedToSectionID), verb = "get", return_params_list = return_params)

def modifyCourseEntityOfferedToSection(CourseEntityOfferedToSectionID, EntityID = 1, setCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToID = None, setCourseEntityOfferedToSectionIDClonedFrom = None, setCourseEntityOfferedToSectionIDClonedTo = None, setCourseID = None, setCreatedTime = None, setEntityIDOfferedTo = None, setHasMeetDisplayPeriodOverrides = None, setIsActive = None, setMaximumStudentCount = None, setModifiedTime = None, setRoomSeatsAvailable = None, setSchoolYearID = None, setSeatsAvailableEntity = None, setSectionID = None, setStudentEnrollmentEntity = None, setTotalEnrollmentCountEntity = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferedEntity = None, setViewingFromOfferingEntity = None, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToID = False, returnCourseEntityOfferedToSectionIDClonedFrom = False, returnCourseEntityOfferedToSectionIDClonedTo = False, returnCourseID = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnHasMeetDisplayPeriodOverrides = False, returnIsActive = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnRoomSeatsAvailable = False, returnSchoolYearID = False, returnSeatsAvailableEntity = False, returnSectionID = False, returnStudentEnrollmentEntity = False, returnTotalEnrollmentCountEntity = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferedEntity = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSection/" + str(CourseEntityOfferedToSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseEntityOfferedToSection(EntityID = 1, setCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToID = None, setCourseEntityOfferedToSectionIDClonedFrom = None, setCourseEntityOfferedToSectionIDClonedTo = None, setCourseID = None, setCreatedTime = None, setEntityIDOfferedTo = None, setHasMeetDisplayPeriodOverrides = None, setIsActive = None, setMaximumStudentCount = None, setModifiedTime = None, setRoomSeatsAvailable = None, setSchoolYearID = None, setSeatsAvailableEntity = None, setSectionID = None, setStudentEnrollmentEntity = None, setTotalEnrollmentCountEntity = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferedEntity = None, setViewingFromOfferingEntity = None, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToID = False, returnCourseEntityOfferedToSectionIDClonedFrom = False, returnCourseEntityOfferedToSectionIDClonedTo = False, returnCourseID = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnHasMeetDisplayPeriodOverrides = False, returnIsActive = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnRoomSeatsAvailable = False, returnSchoolYearID = False, returnSeatsAvailableEntity = False, returnSectionID = False, returnStudentEnrollmentEntity = False, returnTotalEnrollmentCountEntity = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferedEntity = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseEntityOfferedToSection(CourseEntityOfferedToSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSection/" + str(CourseEntityOfferedToSectionID), verb = "delete")


def getEveryCourseEntityOfferedToSectionMeet(searchConditions = [], EntityID = 1, returnCourseEntityOfferedToSectionMeetID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionMeetIDClonedFrom = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnMeetID = False, returnModifiedTime = False, returnRoomID = False, returnSchoolYearID = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseEntityOfferedToSectionMeet in the district.

    This function returns a dataframe of every CourseEntityOfferedToSectionMeet in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeet/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeet/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseEntityOfferedToSectionMeet(CourseEntityOfferedToSectionMeetID, EntityID = 1, returnCourseEntityOfferedToSectionMeetID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionMeetIDClonedFrom = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnMeetID = False, returnModifiedTime = False, returnRoomID = False, returnSchoolYearID = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeet/" + str(CourseEntityOfferedToSectionMeetID), verb = "get", return_params_list = return_params)

def modifyCourseEntityOfferedToSectionMeet(CourseEntityOfferedToSectionMeetID, EntityID = 1, setCourseEntityOfferedToSectionMeetID = None, setCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToSectionMeetIDClonedFrom = None, setCreatedTime = None, setEntityIDOfferedTo = None, setMeetID = None, setModifiedTime = None, setRoomID = None, setSchoolYearID = None, setSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseEntityOfferedToSectionMeetID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionMeetIDClonedFrom = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnMeetID = False, returnModifiedTime = False, returnRoomID = False, returnSchoolYearID = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeet/" + str(CourseEntityOfferedToSectionMeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseEntityOfferedToSectionMeet(EntityID = 1, setCourseEntityOfferedToSectionMeetID = None, setCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToSectionMeetIDClonedFrom = None, setCreatedTime = None, setEntityIDOfferedTo = None, setMeetID = None, setModifiedTime = None, setRoomID = None, setSchoolYearID = None, setSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseEntityOfferedToSectionMeetID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionMeetIDClonedFrom = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnMeetID = False, returnModifiedTime = False, returnRoomID = False, returnSchoolYearID = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeet/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseEntityOfferedToSectionMeet(CourseEntityOfferedToSectionMeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeet/" + str(CourseEntityOfferedToSectionMeetID), verb = "delete")


def getEveryCourseEntityOfferedToSectionMeetDisplayPeriod(searchConditions = [], EntityID = 1, returnCourseEntityOfferedToSectionMeetDisplayPeriodID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionMeetDisplayPeriodIDClonedFrom = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnMeetID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseEntityOfferedToSectionMeetDisplayPeriod in the district.

    This function returns a dataframe of every CourseEntityOfferedToSectionMeetDisplayPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeetDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeetDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseEntityOfferedToSectionMeetDisplayPeriod(CourseEntityOfferedToSectionMeetDisplayPeriodID, EntityID = 1, returnCourseEntityOfferedToSectionMeetDisplayPeriodID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionMeetDisplayPeriodIDClonedFrom = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnMeetID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeetDisplayPeriod/" + str(CourseEntityOfferedToSectionMeetDisplayPeriodID), verb = "get", return_params_list = return_params)

def modifyCourseEntityOfferedToSectionMeetDisplayPeriod(CourseEntityOfferedToSectionMeetDisplayPeriodID, EntityID = 1, setCourseEntityOfferedToSectionMeetDisplayPeriodID = None, setCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToSectionMeetDisplayPeriodIDClonedFrom = None, setCreatedTime = None, setDisplayPeriodID = None, setHideMeetDisplayPeriod = None, setIsPrimary = None, setMeetID = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseEntityOfferedToSectionMeetDisplayPeriodID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionMeetDisplayPeriodIDClonedFrom = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnMeetID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeetDisplayPeriod/" + str(CourseEntityOfferedToSectionMeetDisplayPeriodID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseEntityOfferedToSectionMeetDisplayPeriod(EntityID = 1, setCourseEntityOfferedToSectionMeetDisplayPeriodID = None, setCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToSectionMeetDisplayPeriodIDClonedFrom = None, setCreatedTime = None, setDisplayPeriodID = None, setHideMeetDisplayPeriod = None, setIsPrimary = None, setMeetID = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseEntityOfferedToSectionMeetDisplayPeriodID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionMeetDisplayPeriodIDClonedFrom = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnMeetID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeetDisplayPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseEntityOfferedToSectionMeetDisplayPeriod(CourseEntityOfferedToSectionMeetDisplayPeriodID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionMeetDisplayPeriod/" + str(CourseEntityOfferedToSectionMeetDisplayPeriodID), verb = "delete")


def getEveryCourseEntityOfferedToSectionStaffMeet(searchConditions = [], EntityID = 1, returnCourseEntityOfferedToSectionStaffMeetID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionStaffMeetIDClonedFrom = False, returnCreatedTime = False, returnMeetID = False, returnModifiedTime = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseEntityOfferedToSectionStaffMeet in the district.

    This function returns a dataframe of every CourseEntityOfferedToSectionStaffMeet in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionStaffMeet/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionStaffMeet/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseEntityOfferedToSectionStaffMeet(CourseEntityOfferedToSectionStaffMeetID, EntityID = 1, returnCourseEntityOfferedToSectionStaffMeetID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionStaffMeetIDClonedFrom = False, returnCreatedTime = False, returnMeetID = False, returnModifiedTime = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionStaffMeet/" + str(CourseEntityOfferedToSectionStaffMeetID), verb = "get", return_params_list = return_params)

def modifyCourseEntityOfferedToSectionStaffMeet(CourseEntityOfferedToSectionStaffMeetID, EntityID = 1, setCourseEntityOfferedToSectionStaffMeetID = None, setCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToSectionStaffMeetIDClonedFrom = None, setCreatedTime = None, setMeetID = None, setModifiedTime = None, setStaffID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseEntityOfferedToSectionStaffMeetID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionStaffMeetIDClonedFrom = False, returnCreatedTime = False, returnMeetID = False, returnModifiedTime = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionStaffMeet/" + str(CourseEntityOfferedToSectionStaffMeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseEntityOfferedToSectionStaffMeet(EntityID = 1, setCourseEntityOfferedToSectionStaffMeetID = None, setCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToSectionStaffMeetIDClonedFrom = None, setCreatedTime = None, setMeetID = None, setModifiedTime = None, setStaffID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseEntityOfferedToSectionStaffMeetID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionStaffMeetIDClonedFrom = False, returnCreatedTime = False, returnMeetID = False, returnModifiedTime = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionStaffMeet/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseEntityOfferedToSectionStaffMeet(CourseEntityOfferedToSectionStaffMeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseEntityOfferedToSectionStaffMeet/" + str(CourseEntityOfferedToSectionStaffMeetID), verb = "delete")


def getEveryCourseGradeReference(searchConditions = [], EntityID = 1, returnCourseGradeReferenceID = False, returnCourseGradeReferenceIDClonedFrom = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfAlternateCourseRequestsEntity = False, returnNumberOfCourseRequests = False, returnNumberOfCourseRequestsEntity = False, returnNumberOfCourseRequestsFemales = False, returnNumberOfCourseRequestsFemalesEntity = False, returnNumberOfCourseRequestsMales = False, returnNumberOfCourseRequestsMalesEntity = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseGradeReference in the district.

    This function returns a dataframe of every CourseGradeReference in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReference/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReference/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseGradeReference(CourseGradeReferenceID, EntityID = 1, returnCourseGradeReferenceID = False, returnCourseGradeReferenceIDClonedFrom = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfAlternateCourseRequestsEntity = False, returnNumberOfCourseRequests = False, returnNumberOfCourseRequestsEntity = False, returnNumberOfCourseRequestsFemales = False, returnNumberOfCourseRequestsFemalesEntity = False, returnNumberOfCourseRequestsMales = False, returnNumberOfCourseRequestsMalesEntity = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReference/" + str(CourseGradeReferenceID), verb = "get", return_params_list = return_params)

def modifyCourseGradeReference(CourseGradeReferenceID, EntityID = 1, setCourseGradeReferenceID = None, setCourseGradeReferenceIDClonedFrom = None, setCourseID = None, setCreatedTime = None, setEntityGroupKey = None, setGradeReferenceID = None, setModifiedTime = None, setNumberOfAlternateCourseRequests = None, setNumberOfAlternateCourseRequestsEntity = None, setNumberOfCourseRequests = None, setNumberOfCourseRequestsEntity = None, setNumberOfCourseRequestsFemales = None, setNumberOfCourseRequestsFemalesEntity = None, setNumberOfCourseRequestsMales = None, setNumberOfCourseRequestsMalesEntity = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseGradeReferenceID = False, returnCourseGradeReferenceIDClonedFrom = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfAlternateCourseRequestsEntity = False, returnNumberOfCourseRequests = False, returnNumberOfCourseRequestsEntity = False, returnNumberOfCourseRequestsFemales = False, returnNumberOfCourseRequestsFemalesEntity = False, returnNumberOfCourseRequestsMales = False, returnNumberOfCourseRequestsMalesEntity = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReference/" + str(CourseGradeReferenceID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseGradeReference(EntityID = 1, setCourseGradeReferenceID = None, setCourseGradeReferenceIDClonedFrom = None, setCourseID = None, setCreatedTime = None, setEntityGroupKey = None, setGradeReferenceID = None, setModifiedTime = None, setNumberOfAlternateCourseRequests = None, setNumberOfAlternateCourseRequestsEntity = None, setNumberOfCourseRequests = None, setNumberOfCourseRequestsEntity = None, setNumberOfCourseRequestsFemales = None, setNumberOfCourseRequestsFemalesEntity = None, setNumberOfCourseRequestsMales = None, setNumberOfCourseRequestsMalesEntity = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseGradeReferenceID = False, returnCourseGradeReferenceIDClonedFrom = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfAlternateCourseRequestsEntity = False, returnNumberOfCourseRequests = False, returnNumberOfCourseRequestsEntity = False, returnNumberOfCourseRequestsFemales = False, returnNumberOfCourseRequestsFemalesEntity = False, returnNumberOfCourseRequestsMales = False, returnNumberOfCourseRequestsMalesEntity = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReference/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseGradeReference(CourseGradeReferenceID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReference/" + str(CourseGradeReferenceID), verb = "delete")


def getEveryCourseGradeReferenceSummary(searchConditions = [], EntityID = 1, returnCourseID = False, returnGradeLevelIDSummary = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseGradeReferenceSummary in the district.

    This function returns a dataframe of every CourseGradeReferenceSummary in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReferenceSummary/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReferenceSummary/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseGradeReferenceSummary(CourseID, EntityID = 1, returnCourseID = False, returnGradeLevelIDSummary = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReferenceSummary/" + str(CourseID), verb = "get", return_params_list = return_params)

def modifyCourseGradeReferenceSummary(CourseID, EntityID = 1, setCourseID = None, setGradeLevelIDSummary = None, returnCourseID = False, returnGradeLevelIDSummary = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReferenceSummary/" + str(CourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseGradeReferenceSummary(EntityID = 1, setCourseID = None, setGradeLevelIDSummary = None, returnCourseID = False, returnGradeLevelIDSummary = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReferenceSummary/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseGradeReferenceSummary(CourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGradeReferenceSummary/" + str(CourseID), verb = "delete")


def getEveryCourseGroup(searchConditions = [], EntityID = 1, returnCourseGroupID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDistrictGroupKey = False, returnDistrictID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseGroup in the district.

    This function returns a dataframe of every CourseGroup in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroup/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroup/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseGroup(CourseGroupID, EntityID = 1, returnCourseGroupID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDistrictGroupKey = False, returnDistrictID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroup/" + str(CourseGroupID), verb = "get", return_params_list = return_params)

def modifyCourseGroup(CourseGroupID, EntityID = 1, setCourseGroupID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setDistrictGroupKey = None, setDistrictID = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseGroupID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDistrictGroupKey = False, returnDistrictID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroup/" + str(CourseGroupID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseGroup(EntityID = 1, setCourseGroupID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setDistrictGroupKey = None, setDistrictID = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseGroupID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDistrictGroupKey = False, returnDistrictID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroup/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseGroup(CourseGroupID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroup/" + str(CourseGroupID), verb = "delete")


def getEveryCourseGroupCourse(searchConditions = [], EntityID = 1, returnCourseGroupCourseID = False, returnCourseGroupCourseIDClonedFrom = False, returnCourseGroupID = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseGroupCourse in the district.

    This function returns a dataframe of every CourseGroupCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroupCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroupCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseGroupCourse(CourseGroupCourseID, EntityID = 1, returnCourseGroupCourseID = False, returnCourseGroupCourseIDClonedFrom = False, returnCourseGroupID = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroupCourse/" + str(CourseGroupCourseID), verb = "get", return_params_list = return_params)

def modifyCourseGroupCourse(CourseGroupCourseID, EntityID = 1, setCourseGroupCourseID = None, setCourseGroupCourseIDClonedFrom = None, setCourseGroupID = None, setCourseID = None, setCreatedTime = None, setEntityGroupKey = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseGroupCourseID = False, returnCourseGroupCourseIDClonedFrom = False, returnCourseGroupID = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroupCourse/" + str(CourseGroupCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseGroupCourse(EntityID = 1, setCourseGroupCourseID = None, setCourseGroupCourseIDClonedFrom = None, setCourseGroupID = None, setCourseID = None, setCreatedTime = None, setEntityGroupKey = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseGroupCourseID = False, returnCourseGroupCourseIDClonedFrom = False, returnCourseGroupID = False, returnCourseID = False, returnCreatedTime = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroupCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseGroupCourse(CourseGroupCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseGroupCourse/" + str(CourseGroupCourseID), verb = "delete")


def getEveryCourseLength(searchConditions = [], EntityID = 1, returnCourseLengthID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthIDClonedFrom = False, returnCourseLengthIDClonedTo = False, returnCreatedTime = False, returnDefaultEarnedCredits = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnSectionLengthCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseLength in the district.

    This function returns a dataframe of every CourseLength in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLength/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLength/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseLength(CourseLengthID, EntityID = 1, returnCourseLengthID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthIDClonedFrom = False, returnCourseLengthIDClonedTo = False, returnCreatedTime = False, returnDefaultEarnedCredits = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnSectionLengthCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLength/" + str(CourseLengthID), verb = "get", return_params_list = return_params)

def modifyCourseLength(CourseLengthID, EntityID = 1, setCourseLengthID = None, setCode = None, setCodeDescription = None, setCourseLengthIDClonedFrom = None, setCourseLengthIDClonedTo = None, setCreatedTime = None, setDefaultEarnedCredits = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setSectionLengthCount = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseLengthID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthIDClonedFrom = False, returnCourseLengthIDClonedTo = False, returnCreatedTime = False, returnDefaultEarnedCredits = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnSectionLengthCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLength/" + str(CourseLengthID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseLength(EntityID = 1, setCourseLengthID = None, setCode = None, setCodeDescription = None, setCourseLengthIDClonedFrom = None, setCourseLengthIDClonedTo = None, setCreatedTime = None, setDefaultEarnedCredits = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setSectionLengthCount = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseLengthID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthIDClonedFrom = False, returnCourseLengthIDClonedTo = False, returnCreatedTime = False, returnDefaultEarnedCredits = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnSectionLengthCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLength/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseLength(CourseLengthID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLength/" + str(CourseLengthID), verb = "delete")


def getEveryCourseLevelMN(searchConditions = [], EntityID = 1, returnCourseLevelMNID = False, returnCode = False, returnCreatedTime = False, returnCredits = False, returnCurriculumYearID = False, returnInstitutionID = False, returnModifiedTime = False, returnStateCollegeCourseLevelMNID = False, returnTitle = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseLevelMN in the district.

    This function returns a dataframe of every CourseLevelMN in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLevelMN/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLevelMN/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseLevelMN(CourseLevelMNID, EntityID = 1, returnCourseLevelMNID = False, returnCode = False, returnCreatedTime = False, returnCredits = False, returnCurriculumYearID = False, returnInstitutionID = False, returnModifiedTime = False, returnStateCollegeCourseLevelMNID = False, returnTitle = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLevelMN/" + str(CourseLevelMNID), verb = "get", return_params_list = return_params)

def modifyCourseLevelMN(CourseLevelMNID, EntityID = 1, setCourseLevelMNID = None, setCode = None, setCreatedTime = None, setCredits = None, setCurriculumYearID = None, setInstitutionID = None, setModifiedTime = None, setStateCollegeCourseLevelMNID = None, setTitle = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseLevelMNID = False, returnCode = False, returnCreatedTime = False, returnCredits = False, returnCurriculumYearID = False, returnInstitutionID = False, returnModifiedTime = False, returnStateCollegeCourseLevelMNID = False, returnTitle = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLevelMN/" + str(CourseLevelMNID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseLevelMN(EntityID = 1, setCourseLevelMNID = None, setCode = None, setCreatedTime = None, setCredits = None, setCurriculumYearID = None, setInstitutionID = None, setModifiedTime = None, setStateCollegeCourseLevelMNID = None, setTitle = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseLevelMNID = False, returnCode = False, returnCreatedTime = False, returnCredits = False, returnCurriculumYearID = False, returnInstitutionID = False, returnModifiedTime = False, returnStateCollegeCourseLevelMNID = False, returnTitle = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLevelMN/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseLevelMN(CourseLevelMNID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseLevelMN/" + str(CourseLevelMNID), verb = "delete")


def getEveryCourseMasterMassUpdate(searchConditions = [], EntityID = 1, returnCourseMasterMassUpdateID = False, returnCreatedTime = False, returnEntityID = False, returnFilterParameters = False, returnModifiedTime = False, returnRunReason = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDRanBy = False, returnValueParameters = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseMasterMassUpdate in the district.

    This function returns a dataframe of every CourseMasterMassUpdate in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseMasterMassUpdate/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseMasterMassUpdate/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseMasterMassUpdate(CourseMasterMassUpdateID, EntityID = 1, returnCourseMasterMassUpdateID = False, returnCreatedTime = False, returnEntityID = False, returnFilterParameters = False, returnModifiedTime = False, returnRunReason = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDRanBy = False, returnValueParameters = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseMasterMassUpdate/" + str(CourseMasterMassUpdateID), verb = "get", return_params_list = return_params)

def modifyCourseMasterMassUpdate(CourseMasterMassUpdateID, EntityID = 1, setCourseMasterMassUpdateID = None, setCreatedTime = None, setEntityID = None, setFilterParameters = None, setModifiedTime = None, setRunReason = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUserIDRanBy = None, setValueParameters = None, returnCourseMasterMassUpdateID = False, returnCreatedTime = False, returnEntityID = False, returnFilterParameters = False, returnModifiedTime = False, returnRunReason = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDRanBy = False, returnValueParameters = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseMasterMassUpdate/" + str(CourseMasterMassUpdateID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseMasterMassUpdate(EntityID = 1, setCourseMasterMassUpdateID = None, setCreatedTime = None, setEntityID = None, setFilterParameters = None, setModifiedTime = None, setRunReason = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUserIDRanBy = None, setValueParameters = None, returnCourseMasterMassUpdateID = False, returnCreatedTime = False, returnEntityID = False, returnFilterParameters = False, returnModifiedTime = False, returnRunReason = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDRanBy = False, returnValueParameters = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseMasterMassUpdate/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseMasterMassUpdate(CourseMasterMassUpdateID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseMasterMassUpdate/" + str(CourseMasterMassUpdateID), verb = "delete")


def getEveryCourse(searchConditions = [], EntityID = 1, returnCourseID = False, returnAcademicMinutes = False, returnActiveSections = False, returnActiveSectionsOpen = False, returnActivityID = False, returnAllowTeachersToAddAssignments = False, returnCanBeOfferedToAnotherEntity = False, returnCategory = False, returnCategoryCode = False, returnCodeDescription = False, returnCourseCloned = False, returnCourseCode = False, returnCourseGradeLevelCodes = False, returnCourseGroupDescriptions = False, returnCourseIDClonedFrom = False, returnCourseIDClonedTo = False, returnCourseIDHash = False, returnCourseLengthID = False, returnCourseMNID = False, returnCourseSubjectID = False, returnCourseTypeID = False, returnCreatedTime = False, returnCurriculumID = False, returnDepartmentID = False, returnDescription = False, returnEarnedCredits = False, returnEdFiCourseLevelCharacteristicID = False, returnEdFiSubjectTypeID = False, returnEntityGroupKey = False, returnEntityID = False, returnEstimatedNumberOfSections = False, returnExcludeFromSTAR = False, returnExcludeFromStudentSectionLink = False, returnGradeCourse = False, returnGradeLevelIDSummary = False, returnGradeLevelSummary = False, returnGradingPeriodSetID = False, returnHasAttachedStandards = False, returnHasCourseRequestsInCommonWithCourse = False, returnHasNonAlternateStudentCourseRequests = False, returnHasOfferedCourseEntity = False, returnHasStudentCourseRequests = False, returnHasSubjects = False, returnHideFromArenaScheduling = False, returnHideFromRequestEntry = False, returnIsActive = False, returnIsActiveForEntity = False, returnIsAHistoricRecord = False, returnIsCoreAcademic = False, returnIsCurrentSchoolYear = False, returnIsDirectPay = False, returnIsHonors = False, returnIsOffered = False, returnIsRepeatable = False, returnIsRequired = False, returnIsRequiredOverride = False, returnIsWritingEmphasis = False, returnKeepAttendance = False, returnLengthOfPeriod = False, returnLockCourseFromSectionScheduler = False, returnMaximumPercentageOfSectionsInSingleDisplayPeriod = False, returnMaxRequestedCount = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfCourseRequestsFemales = False, returnNumberOfCourseRequestsInCommonWithCourse = False, returnNumberOfCourseRequestsMales = False, returnNumberOfSeatsAvailable = False, returnNumberOfSeatsRemaining = False, returnNumberOfTransferStudentSections = False, returnOfferingEntity = False, returnOverrideStudentSectionLinkByCourse = False, returnPeriodsPerWeek = False, returnPreventDrop = False, returnPreventMultipleSectionsUsingSingleDisplayPeriod = False, returnRequestLimitPerStudent = False, returnRequired = False, returnSchedulingPriority = False, returnSchedulingPriorityCode = False, returnSchedulingPriorityCodeOverride = False, returnSchedulingPriorityOverride = False, returnSchedulingTeamMode = False, returnSchedulingTeamModeCode = False, returnSchedulingType = False, returnSchedulingTypeCode = False, returnSchedulingTypeCodeOverride = False, returnSchedulingTypeOverride = False, returnSchoolYearID = False, returnSectionSchedulerManualProcessingOrder = False, returnSequenceLimit = False, returnSequenceNumber = False, returnSpecificStudentRequests = False, returnStateCarlPerkinsProgramCodeMNID = False, returnStateSTARAssignmentCodeMNID = False, returnStateSTARGradeLevelMNID = False, returnSumTotalActiveSectionsOptimalStudentCount = False, returnTotalEntitiesOfferedTo = False, returnTotalSectionCount = False, returnTotalStudentCourseRequestSectionLengthSubsetCount = False, returnTotalStudentSectionCount = False, returnUseRequiredOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUseSchedulingPriorityOverride = False, returnUseSchedulingTypeOverride = False, returnViewingFromOfferingEntity = False, returnWebsite = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every Course in the district.

    This function returns a dataframe of every Course in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Course/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Course/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourse(CourseID, EntityID = 1, returnCourseID = False, returnAcademicMinutes = False, returnActiveSections = False, returnActiveSectionsOpen = False, returnActivityID = False, returnAllowTeachersToAddAssignments = False, returnCanBeOfferedToAnotherEntity = False, returnCategory = False, returnCategoryCode = False, returnCodeDescription = False, returnCourseCloned = False, returnCourseCode = False, returnCourseGradeLevelCodes = False, returnCourseGroupDescriptions = False, returnCourseIDClonedFrom = False, returnCourseIDClonedTo = False, returnCourseIDHash = False, returnCourseLengthID = False, returnCourseMNID = False, returnCourseSubjectID = False, returnCourseTypeID = False, returnCreatedTime = False, returnCurriculumID = False, returnDepartmentID = False, returnDescription = False, returnEarnedCredits = False, returnEdFiCourseLevelCharacteristicID = False, returnEdFiSubjectTypeID = False, returnEntityGroupKey = False, returnEntityID = False, returnEstimatedNumberOfSections = False, returnExcludeFromSTAR = False, returnExcludeFromStudentSectionLink = False, returnGradeCourse = False, returnGradeLevelIDSummary = False, returnGradeLevelSummary = False, returnGradingPeriodSetID = False, returnHasAttachedStandards = False, returnHasCourseRequestsInCommonWithCourse = False, returnHasNonAlternateStudentCourseRequests = False, returnHasOfferedCourseEntity = False, returnHasStudentCourseRequests = False, returnHasSubjects = False, returnHideFromArenaScheduling = False, returnHideFromRequestEntry = False, returnIsActive = False, returnIsActiveForEntity = False, returnIsAHistoricRecord = False, returnIsCoreAcademic = False, returnIsCurrentSchoolYear = False, returnIsDirectPay = False, returnIsHonors = False, returnIsOffered = False, returnIsRepeatable = False, returnIsRequired = False, returnIsRequiredOverride = False, returnIsWritingEmphasis = False, returnKeepAttendance = False, returnLengthOfPeriod = False, returnLockCourseFromSectionScheduler = False, returnMaximumPercentageOfSectionsInSingleDisplayPeriod = False, returnMaxRequestedCount = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfCourseRequestsFemales = False, returnNumberOfCourseRequestsInCommonWithCourse = False, returnNumberOfCourseRequestsMales = False, returnNumberOfSeatsAvailable = False, returnNumberOfSeatsRemaining = False, returnNumberOfTransferStudentSections = False, returnOfferingEntity = False, returnOverrideStudentSectionLinkByCourse = False, returnPeriodsPerWeek = False, returnPreventDrop = False, returnPreventMultipleSectionsUsingSingleDisplayPeriod = False, returnRequestLimitPerStudent = False, returnRequired = False, returnSchedulingPriority = False, returnSchedulingPriorityCode = False, returnSchedulingPriorityCodeOverride = False, returnSchedulingPriorityOverride = False, returnSchedulingTeamMode = False, returnSchedulingTeamModeCode = False, returnSchedulingType = False, returnSchedulingTypeCode = False, returnSchedulingTypeCodeOverride = False, returnSchedulingTypeOverride = False, returnSchoolYearID = False, returnSectionSchedulerManualProcessingOrder = False, returnSequenceLimit = False, returnSequenceNumber = False, returnSpecificStudentRequests = False, returnStateCarlPerkinsProgramCodeMNID = False, returnStateSTARAssignmentCodeMNID = False, returnStateSTARGradeLevelMNID = False, returnSumTotalActiveSectionsOptimalStudentCount = False, returnTotalEntitiesOfferedTo = False, returnTotalSectionCount = False, returnTotalStudentCourseRequestSectionLengthSubsetCount = False, returnTotalStudentSectionCount = False, returnUseRequiredOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUseSchedulingPriorityOverride = False, returnUseSchedulingTypeOverride = False, returnViewingFromOfferingEntity = False, returnWebsite = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Course/" + str(CourseID), verb = "get", return_params_list = return_params)

def modifyCourse(CourseID, EntityID = 1, setCourseID = None, setAcademicMinutes = None, setActiveSections = None, setActiveSectionsOpen = None, setActivityID = None, setAllowTeachersToAddAssignments = None, setCanBeOfferedToAnotherEntity = None, setCategory = None, setCategoryCode = None, setCodeDescription = None, setCourseCloned = None, setCourseCode = None, setCourseGradeLevelCodes = None, setCourseGroupDescriptions = None, setCourseIDClonedFrom = None, setCourseIDClonedTo = None, setCourseIDHash = None, setCourseLengthID = None, setCourseMNID = None, setCourseSubjectID = None, setCourseTypeID = None, setCreatedTime = None, setCurriculumID = None, setDepartmentID = None, setDescription = None, setEarnedCredits = None, setEdFiCourseLevelCharacteristicID = None, setEdFiSubjectTypeID = None, setEntityGroupKey = None, setEntityID = None, setEstimatedNumberOfSections = None, setExcludeFromSTAR = None, setExcludeFromStudentSectionLink = None, setGradeCourse = None, setGradeLevelIDSummary = None, setGradeLevelSummary = None, setGradingPeriodSetID = None, setHasAttachedStandards = None, setHasCourseRequestsInCommonWithCourse = None, setHasNonAlternateStudentCourseRequests = None, setHasOfferedCourseEntity = None, setHasStudentCourseRequests = None, setHasSubjects = None, setHideFromArenaScheduling = None, setHideFromRequestEntry = None, setIsActive = None, setIsActiveForEntity = None, setIsAHistoricRecord = None, setIsCoreAcademic = None, setIsCurrentSchoolYear = None, setIsDirectPay = None, setIsHonors = None, setIsOffered = None, setIsRepeatable = None, setIsRequired = None, setIsRequiredOverride = None, setIsWritingEmphasis = None, setKeepAttendance = None, setLengthOfPeriod = None, setLockCourseFromSectionScheduler = None, setMaximumPercentageOfSectionsInSingleDisplayPeriod = None, setMaxRequestedCount = None, setModifiedTime = None, setNumberOfAlternateCourseRequests = None, setNumberOfCourseRequests = None, setNumberOfCourseRequestsFemales = None, setNumberOfCourseRequestsInCommonWithCourse = None, setNumberOfCourseRequestsMales = None, setNumberOfSeatsAvailable = None, setNumberOfSeatsRemaining = None, setNumberOfTransferStudentSections = None, setOfferingEntity = None, setOverrideStudentSectionLinkByCourse = None, setPeriodsPerWeek = None, setPreventDrop = None, setPreventMultipleSectionsUsingSingleDisplayPeriod = None, setRequestLimitPerStudent = None, setRequired = None, setSchedulingPriority = None, setSchedulingPriorityCode = None, setSchedulingPriorityCodeOverride = None, setSchedulingPriorityOverride = None, setSchedulingTeamMode = None, setSchedulingTeamModeCode = None, setSchedulingType = None, setSchedulingTypeCode = None, setSchedulingTypeCodeOverride = None, setSchedulingTypeOverride = None, setSchoolYearID = None, setSectionSchedulerManualProcessingOrder = None, setSequenceLimit = None, setSequenceNumber = None, setSpecificStudentRequests = None, setStateCarlPerkinsProgramCodeMNID = None, setStateSTARAssignmentCodeMNID = None, setStateSTARGradeLevelMNID = None, setSumTotalActiveSectionsOptimalStudentCount = None, setTotalEntitiesOfferedTo = None, setTotalSectionCount = None, setTotalStudentCourseRequestSectionLengthSubsetCount = None, setTotalStudentSectionCount = None, setUseRequiredOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUseSchedulingPriorityOverride = None, setUseSchedulingTypeOverride = None, setViewingFromOfferingEntity = None, setWebsite = None, returnCourseID = False, returnAcademicMinutes = False, returnActiveSections = False, returnActiveSectionsOpen = False, returnActivityID = False, returnAllowTeachersToAddAssignments = False, returnCanBeOfferedToAnotherEntity = False, returnCategory = False, returnCategoryCode = False, returnCodeDescription = False, returnCourseCloned = False, returnCourseCode = False, returnCourseGradeLevelCodes = False, returnCourseGroupDescriptions = False, returnCourseIDClonedFrom = False, returnCourseIDClonedTo = False, returnCourseIDHash = False, returnCourseLengthID = False, returnCourseMNID = False, returnCourseSubjectID = False, returnCourseTypeID = False, returnCreatedTime = False, returnCurriculumID = False, returnDepartmentID = False, returnDescription = False, returnEarnedCredits = False, returnEdFiCourseLevelCharacteristicID = False, returnEdFiSubjectTypeID = False, returnEntityGroupKey = False, returnEntityID = False, returnEstimatedNumberOfSections = False, returnExcludeFromSTAR = False, returnExcludeFromStudentSectionLink = False, returnGradeCourse = False, returnGradeLevelIDSummary = False, returnGradeLevelSummary = False, returnGradingPeriodSetID = False, returnHasAttachedStandards = False, returnHasCourseRequestsInCommonWithCourse = False, returnHasNonAlternateStudentCourseRequests = False, returnHasOfferedCourseEntity = False, returnHasStudentCourseRequests = False, returnHasSubjects = False, returnHideFromArenaScheduling = False, returnHideFromRequestEntry = False, returnIsActive = False, returnIsActiveForEntity = False, returnIsAHistoricRecord = False, returnIsCoreAcademic = False, returnIsCurrentSchoolYear = False, returnIsDirectPay = False, returnIsHonors = False, returnIsOffered = False, returnIsRepeatable = False, returnIsRequired = False, returnIsRequiredOverride = False, returnIsWritingEmphasis = False, returnKeepAttendance = False, returnLengthOfPeriod = False, returnLockCourseFromSectionScheduler = False, returnMaximumPercentageOfSectionsInSingleDisplayPeriod = False, returnMaxRequestedCount = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfCourseRequestsFemales = False, returnNumberOfCourseRequestsInCommonWithCourse = False, returnNumberOfCourseRequestsMales = False, returnNumberOfSeatsAvailable = False, returnNumberOfSeatsRemaining = False, returnNumberOfTransferStudentSections = False, returnOfferingEntity = False, returnOverrideStudentSectionLinkByCourse = False, returnPeriodsPerWeek = False, returnPreventDrop = False, returnPreventMultipleSectionsUsingSingleDisplayPeriod = False, returnRequestLimitPerStudent = False, returnRequired = False, returnSchedulingPriority = False, returnSchedulingPriorityCode = False, returnSchedulingPriorityCodeOverride = False, returnSchedulingPriorityOverride = False, returnSchedulingTeamMode = False, returnSchedulingTeamModeCode = False, returnSchedulingType = False, returnSchedulingTypeCode = False, returnSchedulingTypeCodeOverride = False, returnSchedulingTypeOverride = False, returnSchoolYearID = False, returnSectionSchedulerManualProcessingOrder = False, returnSequenceLimit = False, returnSequenceNumber = False, returnSpecificStudentRequests = False, returnStateCarlPerkinsProgramCodeMNID = False, returnStateSTARAssignmentCodeMNID = False, returnStateSTARGradeLevelMNID = False, returnSumTotalActiveSectionsOptimalStudentCount = False, returnTotalEntitiesOfferedTo = False, returnTotalSectionCount = False, returnTotalStudentCourseRequestSectionLengthSubsetCount = False, returnTotalStudentSectionCount = False, returnUseRequiredOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUseSchedulingPriorityOverride = False, returnUseSchedulingTypeOverride = False, returnViewingFromOfferingEntity = False, returnWebsite = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Course/" + str(CourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourse(EntityID = 1, setCourseID = None, setAcademicMinutes = None, setActiveSections = None, setActiveSectionsOpen = None, setActivityID = None, setAllowTeachersToAddAssignments = None, setCanBeOfferedToAnotherEntity = None, setCategory = None, setCategoryCode = None, setCodeDescription = None, setCourseCloned = None, setCourseCode = None, setCourseGradeLevelCodes = None, setCourseGroupDescriptions = None, setCourseIDClonedFrom = None, setCourseIDClonedTo = None, setCourseIDHash = None, setCourseLengthID = None, setCourseMNID = None, setCourseSubjectID = None, setCourseTypeID = None, setCreatedTime = None, setCurriculumID = None, setDepartmentID = None, setDescription = None, setEarnedCredits = None, setEdFiCourseLevelCharacteristicID = None, setEdFiSubjectTypeID = None, setEntityGroupKey = None, setEntityID = None, setEstimatedNumberOfSections = None, setExcludeFromSTAR = None, setExcludeFromStudentSectionLink = None, setGradeCourse = None, setGradeLevelIDSummary = None, setGradeLevelSummary = None, setGradingPeriodSetID = None, setHasAttachedStandards = None, setHasCourseRequestsInCommonWithCourse = None, setHasNonAlternateStudentCourseRequests = None, setHasOfferedCourseEntity = None, setHasStudentCourseRequests = None, setHasSubjects = None, setHideFromArenaScheduling = None, setHideFromRequestEntry = None, setIsActive = None, setIsActiveForEntity = None, setIsAHistoricRecord = None, setIsCoreAcademic = None, setIsCurrentSchoolYear = None, setIsDirectPay = None, setIsHonors = None, setIsOffered = None, setIsRepeatable = None, setIsRequired = None, setIsRequiredOverride = None, setIsWritingEmphasis = None, setKeepAttendance = None, setLengthOfPeriod = None, setLockCourseFromSectionScheduler = None, setMaximumPercentageOfSectionsInSingleDisplayPeriod = None, setMaxRequestedCount = None, setModifiedTime = None, setNumberOfAlternateCourseRequests = None, setNumberOfCourseRequests = None, setNumberOfCourseRequestsFemales = None, setNumberOfCourseRequestsInCommonWithCourse = None, setNumberOfCourseRequestsMales = None, setNumberOfSeatsAvailable = None, setNumberOfSeatsRemaining = None, setNumberOfTransferStudentSections = None, setOfferingEntity = None, setOverrideStudentSectionLinkByCourse = None, setPeriodsPerWeek = None, setPreventDrop = None, setPreventMultipleSectionsUsingSingleDisplayPeriod = None, setRequestLimitPerStudent = None, setRequired = None, setSchedulingPriority = None, setSchedulingPriorityCode = None, setSchedulingPriorityCodeOverride = None, setSchedulingPriorityOverride = None, setSchedulingTeamMode = None, setSchedulingTeamModeCode = None, setSchedulingType = None, setSchedulingTypeCode = None, setSchedulingTypeCodeOverride = None, setSchedulingTypeOverride = None, setSchoolYearID = None, setSectionSchedulerManualProcessingOrder = None, setSequenceLimit = None, setSequenceNumber = None, setSpecificStudentRequests = None, setStateCarlPerkinsProgramCodeMNID = None, setStateSTARAssignmentCodeMNID = None, setStateSTARGradeLevelMNID = None, setSumTotalActiveSectionsOptimalStudentCount = None, setTotalEntitiesOfferedTo = None, setTotalSectionCount = None, setTotalStudentCourseRequestSectionLengthSubsetCount = None, setTotalStudentSectionCount = None, setUseRequiredOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUseSchedulingPriorityOverride = None, setUseSchedulingTypeOverride = None, setViewingFromOfferingEntity = None, setWebsite = None, returnCourseID = False, returnAcademicMinutes = False, returnActiveSections = False, returnActiveSectionsOpen = False, returnActivityID = False, returnAllowTeachersToAddAssignments = False, returnCanBeOfferedToAnotherEntity = False, returnCategory = False, returnCategoryCode = False, returnCodeDescription = False, returnCourseCloned = False, returnCourseCode = False, returnCourseGradeLevelCodes = False, returnCourseGroupDescriptions = False, returnCourseIDClonedFrom = False, returnCourseIDClonedTo = False, returnCourseIDHash = False, returnCourseLengthID = False, returnCourseMNID = False, returnCourseSubjectID = False, returnCourseTypeID = False, returnCreatedTime = False, returnCurriculumID = False, returnDepartmentID = False, returnDescription = False, returnEarnedCredits = False, returnEdFiCourseLevelCharacteristicID = False, returnEdFiSubjectTypeID = False, returnEntityGroupKey = False, returnEntityID = False, returnEstimatedNumberOfSections = False, returnExcludeFromSTAR = False, returnExcludeFromStudentSectionLink = False, returnGradeCourse = False, returnGradeLevelIDSummary = False, returnGradeLevelSummary = False, returnGradingPeriodSetID = False, returnHasAttachedStandards = False, returnHasCourseRequestsInCommonWithCourse = False, returnHasNonAlternateStudentCourseRequests = False, returnHasOfferedCourseEntity = False, returnHasStudentCourseRequests = False, returnHasSubjects = False, returnHideFromArenaScheduling = False, returnHideFromRequestEntry = False, returnIsActive = False, returnIsActiveForEntity = False, returnIsAHistoricRecord = False, returnIsCoreAcademic = False, returnIsCurrentSchoolYear = False, returnIsDirectPay = False, returnIsHonors = False, returnIsOffered = False, returnIsRepeatable = False, returnIsRequired = False, returnIsRequiredOverride = False, returnIsWritingEmphasis = False, returnKeepAttendance = False, returnLengthOfPeriod = False, returnLockCourseFromSectionScheduler = False, returnMaximumPercentageOfSectionsInSingleDisplayPeriod = False, returnMaxRequestedCount = False, returnModifiedTime = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfCourseRequestsFemales = False, returnNumberOfCourseRequestsInCommonWithCourse = False, returnNumberOfCourseRequestsMales = False, returnNumberOfSeatsAvailable = False, returnNumberOfSeatsRemaining = False, returnNumberOfTransferStudentSections = False, returnOfferingEntity = False, returnOverrideStudentSectionLinkByCourse = False, returnPeriodsPerWeek = False, returnPreventDrop = False, returnPreventMultipleSectionsUsingSingleDisplayPeriod = False, returnRequestLimitPerStudent = False, returnRequired = False, returnSchedulingPriority = False, returnSchedulingPriorityCode = False, returnSchedulingPriorityCodeOverride = False, returnSchedulingPriorityOverride = False, returnSchedulingTeamMode = False, returnSchedulingTeamModeCode = False, returnSchedulingType = False, returnSchedulingTypeCode = False, returnSchedulingTypeCodeOverride = False, returnSchedulingTypeOverride = False, returnSchoolYearID = False, returnSectionSchedulerManualProcessingOrder = False, returnSequenceLimit = False, returnSequenceNumber = False, returnSpecificStudentRequests = False, returnStateCarlPerkinsProgramCodeMNID = False, returnStateSTARAssignmentCodeMNID = False, returnStateSTARGradeLevelMNID = False, returnSumTotalActiveSectionsOptimalStudentCount = False, returnTotalEntitiesOfferedTo = False, returnTotalSectionCount = False, returnTotalStudentCourseRequestSectionLengthSubsetCount = False, returnTotalStudentSectionCount = False, returnUseRequiredOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUseSchedulingPriorityOverride = False, returnUseSchedulingTypeOverride = False, returnViewingFromOfferingEntity = False, returnWebsite = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Course/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourse(CourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Course/" + str(CourseID), verb = "delete")


def getEveryCoursePrerequisite(searchConditions = [], EntityID = 1, returnCoursePrerequisiteID = False, returnCourseID = False, returnCurriculumCode = False, returnCurriculumDescription = False, returnCurriculumID = False, returnEarnedCredits = False, returnEntityID = False, returnHasPrequisiteCurriculums = False, returnNumericYearCourse = False, returnNumericYearCurrent = False, returnPrerequisiteCode = False, returnPrerequisiteID = False, returnSchoolYearHigh = False, returnSchoolYearID = False, returnSchoolYearLow = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CoursePrerequisite in the district.

    This function returns a dataframe of every CoursePrerequisite in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisite/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisite/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCoursePrerequisite(CoursePrerequisiteID, EntityID = 1, returnCoursePrerequisiteID = False, returnCourseID = False, returnCurriculumCode = False, returnCurriculumDescription = False, returnCurriculumID = False, returnEarnedCredits = False, returnEntityID = False, returnHasPrequisiteCurriculums = False, returnNumericYearCourse = False, returnNumericYearCurrent = False, returnPrerequisiteCode = False, returnPrerequisiteID = False, returnSchoolYearHigh = False, returnSchoolYearID = False, returnSchoolYearLow = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisite/" + str(CoursePrerequisiteID), verb = "get", return_params_list = return_params)

def modifyCoursePrerequisite(CoursePrerequisiteID, EntityID = 1, setCoursePrerequisiteID = None, setCourseID = None, setCurriculumCode = None, setCurriculumDescription = None, setCurriculumID = None, setEarnedCredits = None, setEntityID = None, setHasPrequisiteCurriculums = None, setNumericYearCourse = None, setNumericYearCurrent = None, setPrerequisiteCode = None, setPrerequisiteID = None, setSchoolYearHigh = None, setSchoolYearID = None, setSchoolYearLow = None, returnCoursePrerequisiteID = False, returnCourseID = False, returnCurriculumCode = False, returnCurriculumDescription = False, returnCurriculumID = False, returnEarnedCredits = False, returnEntityID = False, returnHasPrequisiteCurriculums = False, returnNumericYearCourse = False, returnNumericYearCurrent = False, returnPrerequisiteCode = False, returnPrerequisiteID = False, returnSchoolYearHigh = False, returnSchoolYearID = False, returnSchoolYearLow = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisite/" + str(CoursePrerequisiteID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCoursePrerequisite(EntityID = 1, setCoursePrerequisiteID = None, setCourseID = None, setCurriculumCode = None, setCurriculumDescription = None, setCurriculumID = None, setEarnedCredits = None, setEntityID = None, setHasPrequisiteCurriculums = None, setNumericYearCourse = None, setNumericYearCurrent = None, setPrerequisiteCode = None, setPrerequisiteID = None, setSchoolYearHigh = None, setSchoolYearID = None, setSchoolYearLow = None, returnCoursePrerequisiteID = False, returnCourseID = False, returnCurriculumCode = False, returnCurriculumDescription = False, returnCurriculumID = False, returnEarnedCredits = False, returnEntityID = False, returnHasPrequisiteCurriculums = False, returnNumericYearCourse = False, returnNumericYearCurrent = False, returnPrerequisiteCode = False, returnPrerequisiteID = False, returnSchoolYearHigh = False, returnSchoolYearID = False, returnSchoolYearLow = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisite/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCoursePrerequisite(CoursePrerequisiteID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisite/" + str(CoursePrerequisiteID), verb = "delete")


def getEveryCoursePrerequisiteCurriculumCourse(searchConditions = [], EntityID = 1, returnCoursePrerequisiteCurriculumCourseID = False, returnCourseIDFor = False, returnCourseIDRequired = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnEntityIDFor = False, returnEntityIDRequired = False, returnNumericYearCourse = False, returnNumericYearCurrentFor = False, returnNumericYearRequired = False, returnPrerequisiteCurriculumID = False, returnPrerequisiteID = False, returnSchoolYearIDFor = False, returnSchoolYearIDRequired = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CoursePrerequisiteCurriculumCourse in the district.

    This function returns a dataframe of every CoursePrerequisiteCurriculumCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCoursePrerequisiteCurriculumCourse(CoursePrerequisiteCurriculumCourseID, EntityID = 1, returnCoursePrerequisiteCurriculumCourseID = False, returnCourseIDFor = False, returnCourseIDRequired = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnEntityIDFor = False, returnEntityIDRequired = False, returnNumericYearCourse = False, returnNumericYearCurrentFor = False, returnNumericYearRequired = False, returnPrerequisiteCurriculumID = False, returnPrerequisiteID = False, returnSchoolYearIDFor = False, returnSchoolYearIDRequired = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourse/" + str(CoursePrerequisiteCurriculumCourseID), verb = "get", return_params_list = return_params)

def modifyCoursePrerequisiteCurriculumCourse(CoursePrerequisiteCurriculumCourseID, EntityID = 1, setCoursePrerequisiteCurriculumCourseID = None, setCourseIDFor = None, setCourseIDRequired = None, setCurriculumIDFor = None, setCurriculumIDRequired = None, setEntityIDFor = None, setEntityIDRequired = None, setNumericYearCourse = None, setNumericYearCurrentFor = None, setNumericYearRequired = None, setPrerequisiteCurriculumID = None, setPrerequisiteID = None, setSchoolYearIDFor = None, setSchoolYearIDRequired = None, returnCoursePrerequisiteCurriculumCourseID = False, returnCourseIDFor = False, returnCourseIDRequired = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnEntityIDFor = False, returnEntityIDRequired = False, returnNumericYearCourse = False, returnNumericYearCurrentFor = False, returnNumericYearRequired = False, returnPrerequisiteCurriculumID = False, returnPrerequisiteID = False, returnSchoolYearIDFor = False, returnSchoolYearIDRequired = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourse/" + str(CoursePrerequisiteCurriculumCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCoursePrerequisiteCurriculumCourse(EntityID = 1, setCoursePrerequisiteCurriculumCourseID = None, setCourseIDFor = None, setCourseIDRequired = None, setCurriculumIDFor = None, setCurriculumIDRequired = None, setEntityIDFor = None, setEntityIDRequired = None, setNumericYearCourse = None, setNumericYearCurrentFor = None, setNumericYearRequired = None, setPrerequisiteCurriculumID = None, setPrerequisiteID = None, setSchoolYearIDFor = None, setSchoolYearIDRequired = None, returnCoursePrerequisiteCurriculumCourseID = False, returnCourseIDFor = False, returnCourseIDRequired = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnEntityIDFor = False, returnEntityIDRequired = False, returnNumericYearCourse = False, returnNumericYearCurrentFor = False, returnNumericYearRequired = False, returnPrerequisiteCurriculumID = False, returnPrerequisiteID = False, returnSchoolYearIDFor = False, returnSchoolYearIDRequired = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCoursePrerequisiteCurriculumCourse(CoursePrerequisiteCurriculumCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourse/" + str(CoursePrerequisiteCurriculumCourseID), verb = "delete")


def getEveryCoursePrerequisiteCurriculumCourseStudentCourseRequest(searchConditions = [], EntityID = 1, returnCoursePrerequisiteCurriculumCourseStudentCourseRequestID = False, returnCourseIDFor = False, returnCourseIDRequired = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnPrerequisiteID = False, returnStatus = False, returnStatusCode = False, returnStudentCourseRequestID = False, returnStudentID = False, returnStudentSectionID = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CoursePrerequisiteCurriculumCourseStudentCourseRequest in the district.

    This function returns a dataframe of every CoursePrerequisiteCurriculumCourseStudentCourseRequest in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourseStudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourseStudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCoursePrerequisiteCurriculumCourseStudentCourseRequest(CoursePrerequisiteCurriculumCourseStudentCourseRequestID, EntityID = 1, returnCoursePrerequisiteCurriculumCourseStudentCourseRequestID = False, returnCourseIDFor = False, returnCourseIDRequired = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnPrerequisiteID = False, returnStatus = False, returnStatusCode = False, returnStudentCourseRequestID = False, returnStudentID = False, returnStudentSectionID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourseStudentCourseRequest/" + str(CoursePrerequisiteCurriculumCourseStudentCourseRequestID), verb = "get", return_params_list = return_params)

def modifyCoursePrerequisiteCurriculumCourseStudentCourseRequest(CoursePrerequisiteCurriculumCourseStudentCourseRequestID, EntityID = 1, setCoursePrerequisiteCurriculumCourseStudentCourseRequestID = None, setCourseIDFor = None, setCourseIDRequired = None, setCurriculumIDFor = None, setCurriculumIDRequired = None, setPrerequisiteID = None, setStatus = None, setStatusCode = None, setStudentCourseRequestID = None, setStudentID = None, setStudentSectionID = None, returnCoursePrerequisiteCurriculumCourseStudentCourseRequestID = False, returnCourseIDFor = False, returnCourseIDRequired = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnPrerequisiteID = False, returnStatus = False, returnStatusCode = False, returnStudentCourseRequestID = False, returnStudentID = False, returnStudentSectionID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourseStudentCourseRequest/" + str(CoursePrerequisiteCurriculumCourseStudentCourseRequestID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCoursePrerequisiteCurriculumCourseStudentCourseRequest(EntityID = 1, setCoursePrerequisiteCurriculumCourseStudentCourseRequestID = None, setCourseIDFor = None, setCourseIDRequired = None, setCurriculumIDFor = None, setCurriculumIDRequired = None, setPrerequisiteID = None, setStatus = None, setStatusCode = None, setStudentCourseRequestID = None, setStudentID = None, setStudentSectionID = None, returnCoursePrerequisiteCurriculumCourseStudentCourseRequestID = False, returnCourseIDFor = False, returnCourseIDRequired = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnPrerequisiteID = False, returnStatus = False, returnStatusCode = False, returnStudentCourseRequestID = False, returnStudentID = False, returnStudentSectionID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourseStudentCourseRequest/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCoursePrerequisiteCurriculumCourseStudentCourseRequest(CoursePrerequisiteCurriculumCourseStudentCourseRequestID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CoursePrerequisiteCurriculumCourseStudentCourseRequest/" + str(CoursePrerequisiteCurriculumCourseStudentCourseRequestID), verb = "delete")


def getEveryCourseSectionLengthExclude(searchConditions = [], EntityID = 1, returnCourseSectionLengthExcludeID = False, returnCourseID = False, returnCreatedTime = False, returnDistributionPercent = False, returnEntityGroupKey = False, returnModifiedTime = False, returnSectionLengthID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseSectionLengthExclude in the district.

    This function returns a dataframe of every CourseSectionLengthExclude in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSectionLengthExclude/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSectionLengthExclude/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseSectionLengthExclude(CourseSectionLengthExcludeID, EntityID = 1, returnCourseSectionLengthExcludeID = False, returnCourseID = False, returnCreatedTime = False, returnDistributionPercent = False, returnEntityGroupKey = False, returnModifiedTime = False, returnSectionLengthID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSectionLengthExclude/" + str(CourseSectionLengthExcludeID), verb = "get", return_params_list = return_params)

def modifyCourseSectionLengthExclude(CourseSectionLengthExcludeID, EntityID = 1, setCourseSectionLengthExcludeID = None, setCourseID = None, setCreatedTime = None, setDistributionPercent = None, setEntityGroupKey = None, setModifiedTime = None, setSectionLengthID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseSectionLengthExcludeID = False, returnCourseID = False, returnCreatedTime = False, returnDistributionPercent = False, returnEntityGroupKey = False, returnModifiedTime = False, returnSectionLengthID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSectionLengthExclude/" + str(CourseSectionLengthExcludeID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseSectionLengthExclude(EntityID = 1, setCourseSectionLengthExcludeID = None, setCourseID = None, setCreatedTime = None, setDistributionPercent = None, setEntityGroupKey = None, setModifiedTime = None, setSectionLengthID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseSectionLengthExcludeID = False, returnCourseID = False, returnCreatedTime = False, returnDistributionPercent = False, returnEntityGroupKey = False, returnModifiedTime = False, returnSectionLengthID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSectionLengthExclude/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseSectionLengthExclude(CourseSectionLengthExcludeID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSectionLengthExclude/" + str(CourseSectionLengthExcludeID), verb = "delete")


def getEveryCourseSubject(searchConditions = [], EntityID = 1, returnCourseSubjectID = False, returnCode = False, returnCodeDescription = False, returnCourseSubjectIDClonedFrom = False, returnCourseSubjectIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseSubject in the district.

    This function returns a dataframe of every CourseSubject in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSubject/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSubject/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseSubject(CourseSubjectID, EntityID = 1, returnCourseSubjectID = False, returnCode = False, returnCodeDescription = False, returnCourseSubjectIDClonedFrom = False, returnCourseSubjectIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSubject/" + str(CourseSubjectID), verb = "get", return_params_list = return_params)

def modifyCourseSubject(CourseSubjectID, EntityID = 1, setCourseSubjectID = None, setCode = None, setCodeDescription = None, setCourseSubjectIDClonedFrom = None, setCourseSubjectIDClonedTo = None, setCreatedTime = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseSubjectID = False, returnCode = False, returnCodeDescription = False, returnCourseSubjectIDClonedFrom = False, returnCourseSubjectIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSubject/" + str(CourseSubjectID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseSubject(EntityID = 1, setCourseSubjectID = None, setCode = None, setCodeDescription = None, setCourseSubjectIDClonedFrom = None, setCourseSubjectIDClonedTo = None, setCreatedTime = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseSubjectID = False, returnCode = False, returnCodeDescription = False, returnCourseSubjectIDClonedFrom = False, returnCourseSubjectIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSubject/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseSubject(CourseSubjectID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseSubject/" + str(CourseSubjectID), verb = "delete")


def getEveryCourseType(searchConditions = [], EntityID = 1, returnCourseTypeID = False, returnCode = False, returnCodeDescription = False, returnCourseTypeIDClonedFrom = False, returnCourseTypeIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CourseType in the district.

    This function returns a dataframe of every CourseType in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseType/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseType/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCourseType(CourseTypeID, EntityID = 1, returnCourseTypeID = False, returnCode = False, returnCodeDescription = False, returnCourseTypeIDClonedFrom = False, returnCourseTypeIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseType/" + str(CourseTypeID), verb = "get", return_params_list = return_params)

def modifyCourseType(CourseTypeID, EntityID = 1, setCourseTypeID = None, setCode = None, setCodeDescription = None, setCourseTypeIDClonedFrom = None, setCourseTypeIDClonedTo = None, setCreatedTime = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseTypeID = False, returnCode = False, returnCodeDescription = False, returnCourseTypeIDClonedFrom = False, returnCourseTypeIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseType/" + str(CourseTypeID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCourseType(EntityID = 1, setCourseTypeID = None, setCode = None, setCodeDescription = None, setCourseTypeIDClonedFrom = None, setCourseTypeIDClonedTo = None, setCreatedTime = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCourseTypeID = False, returnCode = False, returnCodeDescription = False, returnCourseTypeIDClonedFrom = False, returnCourseTypeIDClonedTo = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseType/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCourseType(CourseTypeID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CourseType/" + str(CourseTypeID), verb = "delete")


def getEveryCustomRequirement(searchConditions = [], EntityID = 1, returnCustomRequirementID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDistrictGroupKey = False, returnDistrictID = False, returnModifiedTime = False, returnStudentCondition = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every CustomRequirement in the district.

    This function returns a dataframe of every CustomRequirement in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CustomRequirement/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CustomRequirement/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getCustomRequirement(CustomRequirementID, EntityID = 1, returnCustomRequirementID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDistrictGroupKey = False, returnDistrictID = False, returnModifiedTime = False, returnStudentCondition = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CustomRequirement/" + str(CustomRequirementID), verb = "get", return_params_list = return_params)

def modifyCustomRequirement(CustomRequirementID, EntityID = 1, setCustomRequirementID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setDistrictGroupKey = None, setDistrictID = None, setModifiedTime = None, setStudentCondition = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCustomRequirementID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDistrictGroupKey = False, returnDistrictID = False, returnModifiedTime = False, returnStudentCondition = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CustomRequirement/" + str(CustomRequirementID), verb = "post", return_params_list = return_params, payload = payload_params)

def createCustomRequirement(EntityID = 1, setCustomRequirementID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setDistrictGroupKey = None, setDistrictID = None, setModifiedTime = None, setStudentCondition = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnCustomRequirementID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDistrictGroupKey = False, returnDistrictID = False, returnModifiedTime = False, returnStudentCondition = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CustomRequirement/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteCustomRequirement(CustomRequirementID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/CustomRequirement/" + str(CustomRequirementID), verb = "delete")


def getEveryDateRangePreset(searchConditions = [], EntityID = 1, returnDateRangePresetID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDateRangePresetIDClonedFrom = False, returnDateRangePresetIDClonedTo = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnHighDate = False, returnLowDate = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every DateRangePreset in the district.

    This function returns a dataframe of every DateRangePreset in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DateRangePreset/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DateRangePreset/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getDateRangePreset(DateRangePresetID, EntityID = 1, returnDateRangePresetID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDateRangePresetIDClonedFrom = False, returnDateRangePresetIDClonedTo = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnHighDate = False, returnLowDate = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DateRangePreset/" + str(DateRangePresetID), verb = "get", return_params_list = return_params)

def modifyDateRangePreset(DateRangePresetID, EntityID = 1, setDateRangePresetID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDateRangePresetIDClonedFrom = None, setDateRangePresetIDClonedTo = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setHighDate = None, setLowDate = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDateRangePresetID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDateRangePresetIDClonedFrom = False, returnDateRangePresetIDClonedTo = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnHighDate = False, returnLowDate = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DateRangePreset/" + str(DateRangePresetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createDateRangePreset(EntityID = 1, setDateRangePresetID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDateRangePresetIDClonedFrom = None, setDateRangePresetIDClonedTo = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setHighDate = None, setLowDate = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDateRangePresetID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDateRangePresetIDClonedFrom = False, returnDateRangePresetIDClonedTo = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnHighDate = False, returnLowDate = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DateRangePreset/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteDateRangePreset(DateRangePresetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DateRangePreset/" + str(DateRangePresetID), verb = "delete")


def getEveryDayRotation(searchConditions = [], EntityID = 1, returnDayRotationID = False, returnCode = False, returnConsecutiveTeachingHourLimit = False, returnCreatedTime = False, returnDayRotationIDClonedFrom = False, returnDayRotationIDClonedTo = False, returnEntityGroupKey = False, returnEntityID = False, returnMaximumTeachingHourLimit = False, returnModifiedTime = False, returnSchoolYearID = False, returnSortNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every DayRotation in the district.

    This function returns a dataframe of every DayRotation in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DayRotation/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DayRotation/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getDayRotation(DayRotationID, EntityID = 1, returnDayRotationID = False, returnCode = False, returnConsecutiveTeachingHourLimit = False, returnCreatedTime = False, returnDayRotationIDClonedFrom = False, returnDayRotationIDClonedTo = False, returnEntityGroupKey = False, returnEntityID = False, returnMaximumTeachingHourLimit = False, returnModifiedTime = False, returnSchoolYearID = False, returnSortNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DayRotation/" + str(DayRotationID), verb = "get", return_params_list = return_params)

def modifyDayRotation(DayRotationID, EntityID = 1, setDayRotationID = None, setCode = None, setConsecutiveTeachingHourLimit = None, setCreatedTime = None, setDayRotationIDClonedFrom = None, setDayRotationIDClonedTo = None, setEntityGroupKey = None, setEntityID = None, setMaximumTeachingHourLimit = None, setModifiedTime = None, setSchoolYearID = None, setSortNumber = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDayRotationID = False, returnCode = False, returnConsecutiveTeachingHourLimit = False, returnCreatedTime = False, returnDayRotationIDClonedFrom = False, returnDayRotationIDClonedTo = False, returnEntityGroupKey = False, returnEntityID = False, returnMaximumTeachingHourLimit = False, returnModifiedTime = False, returnSchoolYearID = False, returnSortNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DayRotation/" + str(DayRotationID), verb = "post", return_params_list = return_params, payload = payload_params)

def createDayRotation(EntityID = 1, setDayRotationID = None, setCode = None, setConsecutiveTeachingHourLimit = None, setCreatedTime = None, setDayRotationIDClonedFrom = None, setDayRotationIDClonedTo = None, setEntityGroupKey = None, setEntityID = None, setMaximumTeachingHourLimit = None, setModifiedTime = None, setSchoolYearID = None, setSortNumber = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDayRotationID = False, returnCode = False, returnConsecutiveTeachingHourLimit = False, returnCreatedTime = False, returnDayRotationIDClonedFrom = False, returnDayRotationIDClonedTo = False, returnEntityGroupKey = False, returnEntityID = False, returnMaximumTeachingHourLimit = False, returnModifiedTime = False, returnSchoolYearID = False, returnSortNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DayRotation/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteDayRotation(DayRotationID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DayRotation/" + str(DayRotationID), verb = "delete")


def getEveryDisplayPeriod(searchConditions = [], EntityID = 1, returnDisplayPeriodID = False, returnAttendancePeriodID = False, returnCode = False, returnCodeDescription = False, returnCodeDescriptionDayRotation = False, returnCreatedTime = False, returnDayRotationID = False, returnDescription = False, returnDisplayPeriodCodeDayRotationCode = False, returnDisplayPeriodEndTime = False, returnDisplayPeriodIDClonedFrom = False, returnDisplayPeriodIDClonedTo = False, returnDisplayPeriodStartTime = False, returnEntityGroupKey = False, returnIsLunchPeriod = False, returnIsOutsideRegularSchoolDay = False, returnModifiedTime = False, returnSortNumber = False, returnTeachingHourEquivalent = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every DisplayPeriod in the district.

    This function returns a dataframe of every DisplayPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getDisplayPeriod(DisplayPeriodID, EntityID = 1, returnDisplayPeriodID = False, returnAttendancePeriodID = False, returnCode = False, returnCodeDescription = False, returnCodeDescriptionDayRotation = False, returnCreatedTime = False, returnDayRotationID = False, returnDescription = False, returnDisplayPeriodCodeDayRotationCode = False, returnDisplayPeriodEndTime = False, returnDisplayPeriodIDClonedFrom = False, returnDisplayPeriodIDClonedTo = False, returnDisplayPeriodStartTime = False, returnEntityGroupKey = False, returnIsLunchPeriod = False, returnIsOutsideRegularSchoolDay = False, returnModifiedTime = False, returnSortNumber = False, returnTeachingHourEquivalent = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriod/" + str(DisplayPeriodID), verb = "get", return_params_list = return_params)

def modifyDisplayPeriod(DisplayPeriodID, EntityID = 1, setDisplayPeriodID = None, setAttendancePeriodID = None, setCode = None, setCodeDescription = None, setCodeDescriptionDayRotation = None, setCreatedTime = None, setDayRotationID = None, setDescription = None, setDisplayPeriodCodeDayRotationCode = None, setDisplayPeriodEndTime = None, setDisplayPeriodIDClonedFrom = None, setDisplayPeriodIDClonedTo = None, setDisplayPeriodStartTime = None, setEntityGroupKey = None, setIsLunchPeriod = None, setIsOutsideRegularSchoolDay = None, setModifiedTime = None, setSortNumber = None, setTeachingHourEquivalent = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDisplayPeriodID = False, returnAttendancePeriodID = False, returnCode = False, returnCodeDescription = False, returnCodeDescriptionDayRotation = False, returnCreatedTime = False, returnDayRotationID = False, returnDescription = False, returnDisplayPeriodCodeDayRotationCode = False, returnDisplayPeriodEndTime = False, returnDisplayPeriodIDClonedFrom = False, returnDisplayPeriodIDClonedTo = False, returnDisplayPeriodStartTime = False, returnEntityGroupKey = False, returnIsLunchPeriod = False, returnIsOutsideRegularSchoolDay = False, returnModifiedTime = False, returnSortNumber = False, returnTeachingHourEquivalent = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriod/" + str(DisplayPeriodID), verb = "post", return_params_list = return_params, payload = payload_params)

def createDisplayPeriod(EntityID = 1, setDisplayPeriodID = None, setAttendancePeriodID = None, setCode = None, setCodeDescription = None, setCodeDescriptionDayRotation = None, setCreatedTime = None, setDayRotationID = None, setDescription = None, setDisplayPeriodCodeDayRotationCode = None, setDisplayPeriodEndTime = None, setDisplayPeriodIDClonedFrom = None, setDisplayPeriodIDClonedTo = None, setDisplayPeriodStartTime = None, setEntityGroupKey = None, setIsLunchPeriod = None, setIsOutsideRegularSchoolDay = None, setModifiedTime = None, setSortNumber = None, setTeachingHourEquivalent = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDisplayPeriodID = False, returnAttendancePeriodID = False, returnCode = False, returnCodeDescription = False, returnCodeDescriptionDayRotation = False, returnCreatedTime = False, returnDayRotationID = False, returnDescription = False, returnDisplayPeriodCodeDayRotationCode = False, returnDisplayPeriodEndTime = False, returnDisplayPeriodIDClonedFrom = False, returnDisplayPeriodIDClonedTo = False, returnDisplayPeriodStartTime = False, returnEntityGroupKey = False, returnIsLunchPeriod = False, returnIsOutsideRegularSchoolDay = False, returnModifiedTime = False, returnSortNumber = False, returnTeachingHourEquivalent = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteDisplayPeriod(DisplayPeriodID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriod/" + str(DisplayPeriodID), verb = "delete")


def getEveryDisplayPeriodConflict(searchConditions = [], EntityID = 1, returnDisplayPeriodConflictID = False, returnCreatedTime = False, returnDisplayPeriodIDBase = False, returnDisplayPeriodIDConflicting = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every DisplayPeriodConflict in the district.

    This function returns a dataframe of every DisplayPeriodConflict in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodConflict/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodConflict/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getDisplayPeriodConflict(DisplayPeriodConflictID, EntityID = 1, returnDisplayPeriodConflictID = False, returnCreatedTime = False, returnDisplayPeriodIDBase = False, returnDisplayPeriodIDConflicting = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodConflict/" + str(DisplayPeriodConflictID), verb = "get", return_params_list = return_params)

def modifyDisplayPeriodConflict(DisplayPeriodConflictID, EntityID = 1, setDisplayPeriodConflictID = None, setCreatedTime = None, setDisplayPeriodIDBase = None, setDisplayPeriodIDConflicting = None, setEntityGroupKey = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDisplayPeriodConflictID = False, returnCreatedTime = False, returnDisplayPeriodIDBase = False, returnDisplayPeriodIDConflicting = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodConflict/" + str(DisplayPeriodConflictID), verb = "post", return_params_list = return_params, payload = payload_params)

def createDisplayPeriodConflict(EntityID = 1, setDisplayPeriodConflictID = None, setCreatedTime = None, setDisplayPeriodIDBase = None, setDisplayPeriodIDConflicting = None, setEntityGroupKey = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDisplayPeriodConflictID = False, returnCreatedTime = False, returnDisplayPeriodIDBase = False, returnDisplayPeriodIDConflicting = False, returnEntityGroupKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodConflict/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteDisplayPeriodConflict(DisplayPeriodConflictID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodConflict/" + str(DisplayPeriodConflictID), verb = "delete")


def getEveryDisplayPeriodRotation(searchConditions = [], EntityID = 1, returnDisplayPeriodRotationID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDisplayPeriodRotationIDClonedFrom = False, returnDisplayPeriodRotationIDClonedTo = False, returnDisplayPeriodSummary = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every DisplayPeriodRotation in the district.

    This function returns a dataframe of every DisplayPeriodRotation in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotation/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotation/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getDisplayPeriodRotation(DisplayPeriodRotationID, EntityID = 1, returnDisplayPeriodRotationID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDisplayPeriodRotationIDClonedFrom = False, returnDisplayPeriodRotationIDClonedTo = False, returnDisplayPeriodSummary = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotation/" + str(DisplayPeriodRotationID), verb = "get", return_params_list = return_params)

def modifyDisplayPeriodRotation(DisplayPeriodRotationID, EntityID = 1, setDisplayPeriodRotationID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setDisplayPeriodRotationIDClonedFrom = None, setDisplayPeriodRotationIDClonedTo = None, setDisplayPeriodSummary = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDisplayPeriodRotationID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDisplayPeriodRotationIDClonedFrom = False, returnDisplayPeriodRotationIDClonedTo = False, returnDisplayPeriodSummary = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotation/" + str(DisplayPeriodRotationID), verb = "post", return_params_list = return_params, payload = payload_params)

def createDisplayPeriodRotation(EntityID = 1, setDisplayPeriodRotationID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setDisplayPeriodRotationIDClonedFrom = None, setDisplayPeriodRotationIDClonedTo = None, setDisplayPeriodSummary = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDisplayPeriodRotationID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnDisplayPeriodRotationIDClonedFrom = False, returnDisplayPeriodRotationIDClonedTo = False, returnDisplayPeriodSummary = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotation/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteDisplayPeriodRotation(DisplayPeriodRotationID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotation/" + str(DisplayPeriodRotationID), verb = "delete")


def getEveryDisplayPeriodRotationDisplayPeriod(searchConditions = [], EntityID = 1, returnDisplayPeriodRotationDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnDisplayPeriodRotationDisplayPeriodIDClonedFrom = False, returnDisplayPeriodRotationID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every DisplayPeriodRotationDisplayPeriod in the district.

    This function returns a dataframe of every DisplayPeriodRotationDisplayPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotationDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotationDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getDisplayPeriodRotationDisplayPeriod(DisplayPeriodRotationDisplayPeriodID, EntityID = 1, returnDisplayPeriodRotationDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnDisplayPeriodRotationDisplayPeriodIDClonedFrom = False, returnDisplayPeriodRotationID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotationDisplayPeriod/" + str(DisplayPeriodRotationDisplayPeriodID), verb = "get", return_params_list = return_params)

def modifyDisplayPeriodRotationDisplayPeriod(DisplayPeriodRotationDisplayPeriodID, EntityID = 1, setDisplayPeriodRotationDisplayPeriodID = None, setCreatedTime = None, setDisplayPeriodID = None, setDisplayPeriodRotationDisplayPeriodIDClonedFrom = None, setDisplayPeriodRotationID = None, setHideMeetDisplayPeriod = None, setIsPrimary = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDisplayPeriodRotationDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnDisplayPeriodRotationDisplayPeriodIDClonedFrom = False, returnDisplayPeriodRotationID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotationDisplayPeriod/" + str(DisplayPeriodRotationDisplayPeriodID), verb = "post", return_params_list = return_params, payload = payload_params)

def createDisplayPeriodRotationDisplayPeriod(EntityID = 1, setDisplayPeriodRotationDisplayPeriodID = None, setCreatedTime = None, setDisplayPeriodID = None, setDisplayPeriodRotationDisplayPeriodIDClonedFrom = None, setDisplayPeriodRotationID = None, setHideMeetDisplayPeriod = None, setIsPrimary = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnDisplayPeriodRotationDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnDisplayPeriodRotationDisplayPeriodIDClonedFrom = False, returnDisplayPeriodRotationID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotationDisplayPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteDisplayPeriodRotationDisplayPeriod(DisplayPeriodRotationDisplayPeriodID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/DisplayPeriodRotationDisplayPeriod/" + str(DisplayPeriodRotationDisplayPeriodID), verb = "delete")


def getEveryEarlyExitReason(searchConditions = [], EntityID = 1, returnEarlyExitReasonID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEarlyExitReasonIDClonedFrom = False, returnEntityGroupKey = False, returnEntityID = False, returnIsConsideredDrop = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every EarlyExitReason in the district.

    This function returns a dataframe of every EarlyExitReason in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/EarlyExitReason/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/EarlyExitReason/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getEarlyExitReason(EarlyExitReasonID, EntityID = 1, returnEarlyExitReasonID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEarlyExitReasonIDClonedFrom = False, returnEntityGroupKey = False, returnEntityID = False, returnIsConsideredDrop = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/EarlyExitReason/" + str(EarlyExitReasonID), verb = "get", return_params_list = return_params)

def modifyEarlyExitReason(EarlyExitReasonID, EntityID = 1, setEarlyExitReasonID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEarlyExitReasonIDClonedFrom = None, setEntityGroupKey = None, setEntityID = None, setIsConsideredDrop = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnEarlyExitReasonID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEarlyExitReasonIDClonedFrom = False, returnEntityGroupKey = False, returnEntityID = False, returnIsConsideredDrop = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/EarlyExitReason/" + str(EarlyExitReasonID), verb = "post", return_params_list = return_params, payload = payload_params)

def createEarlyExitReason(EntityID = 1, setEarlyExitReasonID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEarlyExitReasonIDClonedFrom = None, setEntityGroupKey = None, setEntityID = None, setIsConsideredDrop = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnEarlyExitReasonID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEarlyExitReasonIDClonedFrom = False, returnEntityGroupKey = False, returnEntityID = False, returnIsConsideredDrop = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/EarlyExitReason/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteEarlyExitReason(EarlyExitReasonID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/EarlyExitReason/" + str(EarlyExitReasonID), verb = "delete")


def getEveryMassPrintStudentScheduleRunHistory(searchConditions = [], EntityID = 1, returnMassPrintStudentScheduleRunHistoryID = False, returnCreatedTime = False, returnEntityID = False, returnMediaID = False, returnModifiedTime = False, returnParameterData = False, returnParameterDescription = False, returnRequestIdentifier = False, returnRunDescription = False, returnSchoolYearID = False, returnSendMessageOnComplete = False, returnStudentSelectType = False, returnStudentSelectTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowInstanceID = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MassPrintStudentScheduleRunHistory in the district.

    This function returns a dataframe of every MassPrintStudentScheduleRunHistory in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassPrintStudentScheduleRunHistory/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassPrintStudentScheduleRunHistory/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMassPrintStudentScheduleRunHistory(MassPrintStudentScheduleRunHistoryID, EntityID = 1, returnMassPrintStudentScheduleRunHistoryID = False, returnCreatedTime = False, returnEntityID = False, returnMediaID = False, returnModifiedTime = False, returnParameterData = False, returnParameterDescription = False, returnRequestIdentifier = False, returnRunDescription = False, returnSchoolYearID = False, returnSendMessageOnComplete = False, returnStudentSelectType = False, returnStudentSelectTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowInstanceID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassPrintStudentScheduleRunHistory/" + str(MassPrintStudentScheduleRunHistoryID), verb = "get", return_params_list = return_params)

def modifyMassPrintStudentScheduleRunHistory(MassPrintStudentScheduleRunHistoryID, EntityID = 1, setMassPrintStudentScheduleRunHistoryID = None, setCreatedTime = None, setEntityID = None, setMediaID = None, setModifiedTime = None, setParameterData = None, setParameterDescription = None, setRequestIdentifier = None, setRunDescription = None, setSchoolYearID = None, setSendMessageOnComplete = None, setStudentSelectType = None, setStudentSelectTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowInstanceID = None, returnMassPrintStudentScheduleRunHistoryID = False, returnCreatedTime = False, returnEntityID = False, returnMediaID = False, returnModifiedTime = False, returnParameterData = False, returnParameterDescription = False, returnRequestIdentifier = False, returnRunDescription = False, returnSchoolYearID = False, returnSendMessageOnComplete = False, returnStudentSelectType = False, returnStudentSelectTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowInstanceID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassPrintStudentScheduleRunHistory/" + str(MassPrintStudentScheduleRunHistoryID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMassPrintStudentScheduleRunHistory(EntityID = 1, setMassPrintStudentScheduleRunHistoryID = None, setCreatedTime = None, setEntityID = None, setMediaID = None, setModifiedTime = None, setParameterData = None, setParameterDescription = None, setRequestIdentifier = None, setRunDescription = None, setSchoolYearID = None, setSendMessageOnComplete = None, setStudentSelectType = None, setStudentSelectTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowInstanceID = None, returnMassPrintStudentScheduleRunHistoryID = False, returnCreatedTime = False, returnEntityID = False, returnMediaID = False, returnModifiedTime = False, returnParameterData = False, returnParameterDescription = False, returnRequestIdentifier = False, returnRunDescription = False, returnSchoolYearID = False, returnSendMessageOnComplete = False, returnStudentSelectType = False, returnStudentSelectTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowInstanceID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassPrintStudentScheduleRunHistory/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMassPrintStudentScheduleRunHistory(MassPrintStudentScheduleRunHistoryID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassPrintStudentScheduleRunHistory/" + str(MassPrintStudentScheduleRunHistoryID), verb = "delete")


def getEveryMassUpdateSystemDateRunHistory(searchConditions = [], EntityID = 1, returnMassUpdateSystemDateRunHistoryID = False, returnCreatedTime = False, returnDateTemplateXML = False, returnDuration = False, returnEndTime = False, returnEntityID = False, returnErrorCount = False, returnHasErrors = False, returnLocation = False, returnLocationCode = False, returnModifiedTime = False, returnRunDescription = False, returnRunReason = False, returnSchoolYearID = False, returnSourceID = False, returnStartTime = False, returnUpdateSuccessful = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MassUpdateSystemDateRunHistory in the district.

    This function returns a dataframe of every MassUpdateSystemDateRunHistory in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistory/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistory/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMassUpdateSystemDateRunHistory(MassUpdateSystemDateRunHistoryID, EntityID = 1, returnMassUpdateSystemDateRunHistoryID = False, returnCreatedTime = False, returnDateTemplateXML = False, returnDuration = False, returnEndTime = False, returnEntityID = False, returnErrorCount = False, returnHasErrors = False, returnLocation = False, returnLocationCode = False, returnModifiedTime = False, returnRunDescription = False, returnRunReason = False, returnSchoolYearID = False, returnSourceID = False, returnStartTime = False, returnUpdateSuccessful = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistory/" + str(MassUpdateSystemDateRunHistoryID), verb = "get", return_params_list = return_params)

def modifyMassUpdateSystemDateRunHistory(MassUpdateSystemDateRunHistoryID, EntityID = 1, setMassUpdateSystemDateRunHistoryID = None, setCreatedTime = None, setDateTemplateXML = None, setDuration = None, setEndTime = None, setEntityID = None, setErrorCount = None, setHasErrors = None, setLocation = None, setLocationCode = None, setModifiedTime = None, setRunDescription = None, setRunReason = None, setSchoolYearID = None, setSourceID = None, setStartTime = None, setUpdateSuccessful = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMassUpdateSystemDateRunHistoryID = False, returnCreatedTime = False, returnDateTemplateXML = False, returnDuration = False, returnEndTime = False, returnEntityID = False, returnErrorCount = False, returnHasErrors = False, returnLocation = False, returnLocationCode = False, returnModifiedTime = False, returnRunDescription = False, returnRunReason = False, returnSchoolYearID = False, returnSourceID = False, returnStartTime = False, returnUpdateSuccessful = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistory/" + str(MassUpdateSystemDateRunHistoryID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMassUpdateSystemDateRunHistory(EntityID = 1, setMassUpdateSystemDateRunHistoryID = None, setCreatedTime = None, setDateTemplateXML = None, setDuration = None, setEndTime = None, setEntityID = None, setErrorCount = None, setHasErrors = None, setLocation = None, setLocationCode = None, setModifiedTime = None, setRunDescription = None, setRunReason = None, setSchoolYearID = None, setSourceID = None, setStartTime = None, setUpdateSuccessful = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMassUpdateSystemDateRunHistoryID = False, returnCreatedTime = False, returnDateTemplateXML = False, returnDuration = False, returnEndTime = False, returnEntityID = False, returnErrorCount = False, returnHasErrors = False, returnLocation = False, returnLocationCode = False, returnModifiedTime = False, returnRunDescription = False, returnRunReason = False, returnSchoolYearID = False, returnSourceID = False, returnStartTime = False, returnUpdateSuccessful = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistory/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMassUpdateSystemDateRunHistory(MassUpdateSystemDateRunHistoryID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistory/" + str(MassUpdateSystemDateRunHistoryID), verb = "delete")


def getEveryMassUpdateSystemDateRunHistoryDetail(searchConditions = [], EntityID = 1, returnMassUpdateSystemDateRunHistoryDetailID = False, returnCreatedTime = False, returnEndDateFailedCount = False, returnEndDateRecordsProcessedCount = False, returnEndDateSuccessCount = False, returnMassUpdateSystemDateRunHistoryID = False, returnModifiedTime = False, returnSortNumber = False, returnStartDateFailedCount = False, returnStartDateRecordsProcessedCount = False, returnStartDateSuccessCount = False, returnTableType = False, returnTableTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MassUpdateSystemDateRunHistoryDetail in the district.

    This function returns a dataframe of every MassUpdateSystemDateRunHistoryDetail in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryDetail/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryDetail/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMassUpdateSystemDateRunHistoryDetail(MassUpdateSystemDateRunHistoryDetailID, EntityID = 1, returnMassUpdateSystemDateRunHistoryDetailID = False, returnCreatedTime = False, returnEndDateFailedCount = False, returnEndDateRecordsProcessedCount = False, returnEndDateSuccessCount = False, returnMassUpdateSystemDateRunHistoryID = False, returnModifiedTime = False, returnSortNumber = False, returnStartDateFailedCount = False, returnStartDateRecordsProcessedCount = False, returnStartDateSuccessCount = False, returnTableType = False, returnTableTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryDetail/" + str(MassUpdateSystemDateRunHistoryDetailID), verb = "get", return_params_list = return_params)

def modifyMassUpdateSystemDateRunHistoryDetail(MassUpdateSystemDateRunHistoryDetailID, EntityID = 1, setMassUpdateSystemDateRunHistoryDetailID = None, setCreatedTime = None, setEndDateFailedCount = None, setEndDateRecordsProcessedCount = None, setEndDateSuccessCount = None, setMassUpdateSystemDateRunHistoryID = None, setModifiedTime = None, setSortNumber = None, setStartDateFailedCount = None, setStartDateRecordsProcessedCount = None, setStartDateSuccessCount = None, setTableType = None, setTableTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMassUpdateSystemDateRunHistoryDetailID = False, returnCreatedTime = False, returnEndDateFailedCount = False, returnEndDateRecordsProcessedCount = False, returnEndDateSuccessCount = False, returnMassUpdateSystemDateRunHistoryID = False, returnModifiedTime = False, returnSortNumber = False, returnStartDateFailedCount = False, returnStartDateRecordsProcessedCount = False, returnStartDateSuccessCount = False, returnTableType = False, returnTableTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryDetail/" + str(MassUpdateSystemDateRunHistoryDetailID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMassUpdateSystemDateRunHistoryDetail(EntityID = 1, setMassUpdateSystemDateRunHistoryDetailID = None, setCreatedTime = None, setEndDateFailedCount = None, setEndDateRecordsProcessedCount = None, setEndDateSuccessCount = None, setMassUpdateSystemDateRunHistoryID = None, setModifiedTime = None, setSortNumber = None, setStartDateFailedCount = None, setStartDateRecordsProcessedCount = None, setStartDateSuccessCount = None, setTableType = None, setTableTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMassUpdateSystemDateRunHistoryDetailID = False, returnCreatedTime = False, returnEndDateFailedCount = False, returnEndDateRecordsProcessedCount = False, returnEndDateSuccessCount = False, returnMassUpdateSystemDateRunHistoryID = False, returnModifiedTime = False, returnSortNumber = False, returnStartDateFailedCount = False, returnStartDateRecordsProcessedCount = False, returnStartDateSuccessCount = False, returnTableType = False, returnTableTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryDetail/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMassUpdateSystemDateRunHistoryDetail(MassUpdateSystemDateRunHistoryDetailID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryDetail/" + str(MassUpdateSystemDateRunHistoryDetailID), verb = "delete")


def getEveryMassUpdateSystemDateRunHistoryError(searchConditions = [], EntityID = 1, returnMassUpdateSystemDateRunHistoryErrorID = False, returnCreatedTime = False, returnDescription = False, returnErrorDetail = False, returnMassUpdateSystemDateRunHistoryID = False, returnModifiedTime = False, returnObjectID = False, returnParentObjectID = False, returnTableType = False, returnTableTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MassUpdateSystemDateRunHistoryError in the district.

    This function returns a dataframe of every MassUpdateSystemDateRunHistoryError in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryError/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryError/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMassUpdateSystemDateRunHistoryError(MassUpdateSystemDateRunHistoryErrorID, EntityID = 1, returnMassUpdateSystemDateRunHistoryErrorID = False, returnCreatedTime = False, returnDescription = False, returnErrorDetail = False, returnMassUpdateSystemDateRunHistoryID = False, returnModifiedTime = False, returnObjectID = False, returnParentObjectID = False, returnTableType = False, returnTableTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryError/" + str(MassUpdateSystemDateRunHistoryErrorID), verb = "get", return_params_list = return_params)

def modifyMassUpdateSystemDateRunHistoryError(MassUpdateSystemDateRunHistoryErrorID, EntityID = 1, setMassUpdateSystemDateRunHistoryErrorID = None, setCreatedTime = None, setDescription = None, setErrorDetail = None, setMassUpdateSystemDateRunHistoryID = None, setModifiedTime = None, setObjectID = None, setParentObjectID = None, setTableType = None, setTableTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMassUpdateSystemDateRunHistoryErrorID = False, returnCreatedTime = False, returnDescription = False, returnErrorDetail = False, returnMassUpdateSystemDateRunHistoryID = False, returnModifiedTime = False, returnObjectID = False, returnParentObjectID = False, returnTableType = False, returnTableTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryError/" + str(MassUpdateSystemDateRunHistoryErrorID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMassUpdateSystemDateRunHistoryError(EntityID = 1, setMassUpdateSystemDateRunHistoryErrorID = None, setCreatedTime = None, setDescription = None, setErrorDetail = None, setMassUpdateSystemDateRunHistoryID = None, setModifiedTime = None, setObjectID = None, setParentObjectID = None, setTableType = None, setTableTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMassUpdateSystemDateRunHistoryErrorID = False, returnCreatedTime = False, returnDescription = False, returnErrorDetail = False, returnMassUpdateSystemDateRunHistoryID = False, returnModifiedTime = False, returnObjectID = False, returnParentObjectID = False, returnTableType = False, returnTableTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryError/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMassUpdateSystemDateRunHistoryError(MassUpdateSystemDateRunHistoryErrorID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MassUpdateSystemDateRunHistoryError/" + str(MassUpdateSystemDateRunHistoryErrorID), verb = "delete")


def getEveryMaximumTeachingHourOverride(searchConditions = [], EntityID = 1, returnMaximumTeachingHourOverrideID = False, returnCreatedTime = False, returnDayRotationID = False, returnMaximumConsecutiveTeachingHours = False, returnMaximumTeachingHourOverrideIDClonedFrom = False, returnMaximumTotalTeachingHours = False, returnModifiedTime = False, returnStaffEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MaximumTeachingHourOverride in the district.

    This function returns a dataframe of every MaximumTeachingHourOverride in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MaximumTeachingHourOverride/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MaximumTeachingHourOverride/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMaximumTeachingHourOverride(MaximumTeachingHourOverrideID, EntityID = 1, returnMaximumTeachingHourOverrideID = False, returnCreatedTime = False, returnDayRotationID = False, returnMaximumConsecutiveTeachingHours = False, returnMaximumTeachingHourOverrideIDClonedFrom = False, returnMaximumTotalTeachingHours = False, returnModifiedTime = False, returnStaffEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MaximumTeachingHourOverride/" + str(MaximumTeachingHourOverrideID), verb = "get", return_params_list = return_params)

def modifyMaximumTeachingHourOverride(MaximumTeachingHourOverrideID, EntityID = 1, setMaximumTeachingHourOverrideID = None, setCreatedTime = None, setDayRotationID = None, setMaximumConsecutiveTeachingHours = None, setMaximumTeachingHourOverrideIDClonedFrom = None, setMaximumTotalTeachingHours = None, setModifiedTime = None, setStaffEntityYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMaximumTeachingHourOverrideID = False, returnCreatedTime = False, returnDayRotationID = False, returnMaximumConsecutiveTeachingHours = False, returnMaximumTeachingHourOverrideIDClonedFrom = False, returnMaximumTotalTeachingHours = False, returnModifiedTime = False, returnStaffEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MaximumTeachingHourOverride/" + str(MaximumTeachingHourOverrideID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMaximumTeachingHourOverride(EntityID = 1, setMaximumTeachingHourOverrideID = None, setCreatedTime = None, setDayRotationID = None, setMaximumConsecutiveTeachingHours = None, setMaximumTeachingHourOverrideIDClonedFrom = None, setMaximumTotalTeachingHours = None, setModifiedTime = None, setStaffEntityYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMaximumTeachingHourOverrideID = False, returnCreatedTime = False, returnDayRotationID = False, returnMaximumConsecutiveTeachingHours = False, returnMaximumTeachingHourOverrideIDClonedFrom = False, returnMaximumTotalTeachingHours = False, returnModifiedTime = False, returnStaffEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MaximumTeachingHourOverride/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMaximumTeachingHourOverride(MaximumTeachingHourOverrideID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MaximumTeachingHourOverride/" + str(MaximumTeachingHourOverrideID), verb = "delete")


def getEveryMCCCTermGradeBucketMN(searchConditions = [], EntityID = 1, returnMCCCTermGradeBucketMNID = False, returnCreatedTime = False, returnGradeBucketID = False, returnMCCCTermImportID = False, returnModifiedTime = False, returnSectionLengthID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MCCCTermGradeBucketMN in the district.

    This function returns a dataframe of every MCCCTermGradeBucketMN in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MCCCTermGradeBucketMN/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MCCCTermGradeBucketMN/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMCCCTermGradeBucketMN(MCCCTermGradeBucketMNID, EntityID = 1, returnMCCCTermGradeBucketMNID = False, returnCreatedTime = False, returnGradeBucketID = False, returnMCCCTermImportID = False, returnModifiedTime = False, returnSectionLengthID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MCCCTermGradeBucketMN/" + str(MCCCTermGradeBucketMNID), verb = "get", return_params_list = return_params)

def modifyMCCCTermGradeBucketMN(MCCCTermGradeBucketMNID, EntityID = 1, setMCCCTermGradeBucketMNID = None, setCreatedTime = None, setGradeBucketID = None, setMCCCTermImportID = None, setModifiedTime = None, setSectionLengthID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMCCCTermGradeBucketMNID = False, returnCreatedTime = False, returnGradeBucketID = False, returnMCCCTermImportID = False, returnModifiedTime = False, returnSectionLengthID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MCCCTermGradeBucketMN/" + str(MCCCTermGradeBucketMNID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMCCCTermGradeBucketMN(EntityID = 1, setMCCCTermGradeBucketMNID = None, setCreatedTime = None, setGradeBucketID = None, setMCCCTermImportID = None, setModifiedTime = None, setSectionLengthID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMCCCTermGradeBucketMNID = False, returnCreatedTime = False, returnGradeBucketID = False, returnMCCCTermImportID = False, returnModifiedTime = False, returnSectionLengthID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MCCCTermGradeBucketMN/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMCCCTermGradeBucketMN(MCCCTermGradeBucketMNID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MCCCTermGradeBucketMN/" + str(MCCCTermGradeBucketMNID), verb = "delete")


def getEveryMeet(searchConditions = [], EntityID = 1, returnMeetID = False, returnCalendarIDStaff = False, returnCreatedTime = False, returnDisplayPeriodRotationID = False, returnDurationInMinutes = False, returnEndDate = False, returnEntityID = False, returnHasDisplayPeriodRotationAssigned = False, returnIsAssignedToAHomeroomRoom = False, returnIsPrimary = False, returnLockAllMeetDayRotationsFromSectionScheduler = False, returnLockAllMeetDisplayPeriodsFromSectionScheduler = False, returnLockAllStaffMeetsFromSectionScheduler = False, returnLockRoomFromSectionScheduler = False, returnMeetIDClonedFrom = False, returnMeetIDClonedTo = False, returnModifiedTime = False, returnOverridePeriodEndTime = False, returnOverridePeriodStartTime = False, returnRoomID = False, returnRoomSeatsAvailable = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnStartDateEndDateBuildingCodeRoomNumber = False, returnTotalMeetDisplayPeriodCount = False, returnTotalStaffMeetCount = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every Meet in the district.

    This function returns a dataframe of every Meet in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Meet/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Meet/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMeet(MeetID, EntityID = 1, returnMeetID = False, returnCalendarIDStaff = False, returnCreatedTime = False, returnDisplayPeriodRotationID = False, returnDurationInMinutes = False, returnEndDate = False, returnEntityID = False, returnHasDisplayPeriodRotationAssigned = False, returnIsAssignedToAHomeroomRoom = False, returnIsPrimary = False, returnLockAllMeetDayRotationsFromSectionScheduler = False, returnLockAllMeetDisplayPeriodsFromSectionScheduler = False, returnLockAllStaffMeetsFromSectionScheduler = False, returnLockRoomFromSectionScheduler = False, returnMeetIDClonedFrom = False, returnMeetIDClonedTo = False, returnModifiedTime = False, returnOverridePeriodEndTime = False, returnOverridePeriodStartTime = False, returnRoomID = False, returnRoomSeatsAvailable = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnStartDateEndDateBuildingCodeRoomNumber = False, returnTotalMeetDisplayPeriodCount = False, returnTotalStaffMeetCount = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Meet/" + str(MeetID), verb = "get", return_params_list = return_params)

def modifyMeet(MeetID, EntityID = 1, setMeetID = None, setCalendarIDStaff = None, setCreatedTime = None, setDisplayPeriodRotationID = None, setDurationInMinutes = None, setEndDate = None, setEntityID = None, setHasDisplayPeriodRotationAssigned = None, setIsAssignedToAHomeroomRoom = None, setIsPrimary = None, setLockAllMeetDayRotationsFromSectionScheduler = None, setLockAllMeetDisplayPeriodsFromSectionScheduler = None, setLockAllStaffMeetsFromSectionScheduler = None, setLockRoomFromSectionScheduler = None, setMeetIDClonedFrom = None, setMeetIDClonedTo = None, setModifiedTime = None, setOverridePeriodEndTime = None, setOverridePeriodStartTime = None, setRoomID = None, setRoomSeatsAvailable = None, setSchoolYearID = None, setSectionID = None, setStartDate = None, setStartDateEndDateBuildingCodeRoomNumber = None, setTotalMeetDisplayPeriodCount = None, setTotalStaffMeetCount = None, setType = None, setTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferingEntity = None, returnMeetID = False, returnCalendarIDStaff = False, returnCreatedTime = False, returnDisplayPeriodRotationID = False, returnDurationInMinutes = False, returnEndDate = False, returnEntityID = False, returnHasDisplayPeriodRotationAssigned = False, returnIsAssignedToAHomeroomRoom = False, returnIsPrimary = False, returnLockAllMeetDayRotationsFromSectionScheduler = False, returnLockAllMeetDisplayPeriodsFromSectionScheduler = False, returnLockAllStaffMeetsFromSectionScheduler = False, returnLockRoomFromSectionScheduler = False, returnMeetIDClonedFrom = False, returnMeetIDClonedTo = False, returnModifiedTime = False, returnOverridePeriodEndTime = False, returnOverridePeriodStartTime = False, returnRoomID = False, returnRoomSeatsAvailable = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnStartDateEndDateBuildingCodeRoomNumber = False, returnTotalMeetDisplayPeriodCount = False, returnTotalStaffMeetCount = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Meet/" + str(MeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMeet(EntityID = 1, setMeetID = None, setCalendarIDStaff = None, setCreatedTime = None, setDisplayPeriodRotationID = None, setDurationInMinutes = None, setEndDate = None, setEntityID = None, setHasDisplayPeriodRotationAssigned = None, setIsAssignedToAHomeroomRoom = None, setIsPrimary = None, setLockAllMeetDayRotationsFromSectionScheduler = None, setLockAllMeetDisplayPeriodsFromSectionScheduler = None, setLockAllStaffMeetsFromSectionScheduler = None, setLockRoomFromSectionScheduler = None, setMeetIDClonedFrom = None, setMeetIDClonedTo = None, setModifiedTime = None, setOverridePeriodEndTime = None, setOverridePeriodStartTime = None, setRoomID = None, setRoomSeatsAvailable = None, setSchoolYearID = None, setSectionID = None, setStartDate = None, setStartDateEndDateBuildingCodeRoomNumber = None, setTotalMeetDisplayPeriodCount = None, setTotalStaffMeetCount = None, setType = None, setTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferingEntity = None, returnMeetID = False, returnCalendarIDStaff = False, returnCreatedTime = False, returnDisplayPeriodRotationID = False, returnDurationInMinutes = False, returnEndDate = False, returnEntityID = False, returnHasDisplayPeriodRotationAssigned = False, returnIsAssignedToAHomeroomRoom = False, returnIsPrimary = False, returnLockAllMeetDayRotationsFromSectionScheduler = False, returnLockAllMeetDisplayPeriodsFromSectionScheduler = False, returnLockAllStaffMeetsFromSectionScheduler = False, returnLockRoomFromSectionScheduler = False, returnMeetIDClonedFrom = False, returnMeetIDClonedTo = False, returnModifiedTime = False, returnOverridePeriodEndTime = False, returnOverridePeriodStartTime = False, returnRoomID = False, returnRoomSeatsAvailable = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnStartDateEndDateBuildingCodeRoomNumber = False, returnTotalMeetDisplayPeriodCount = False, returnTotalStaffMeetCount = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Meet/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMeet(MeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Meet/" + str(MeetID), verb = "delete")


def getEveryMeetDisplayPeriod(searchConditions = [], EntityID = 1, returnMeetDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnLockDisplayPeriod = False, returnMeetDisplayPeriodEndTime = False, returnMeetDisplayPeriodIDClonedFrom = False, returnMeetDisplayPeriodStartTime = False, returnMeetID = False, returnModifiedTime = False, returnScheduledBySectionScheduler = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MeetDisplayPeriod in the district.

    This function returns a dataframe of every MeetDisplayPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMeetDisplayPeriod(MeetDisplayPeriodID, EntityID = 1, returnMeetDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnLockDisplayPeriod = False, returnMeetDisplayPeriodEndTime = False, returnMeetDisplayPeriodIDClonedFrom = False, returnMeetDisplayPeriodStartTime = False, returnMeetID = False, returnModifiedTime = False, returnScheduledBySectionScheduler = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetDisplayPeriod/" + str(MeetDisplayPeriodID), verb = "get", return_params_list = return_params)

def modifyMeetDisplayPeriod(MeetDisplayPeriodID, EntityID = 1, setMeetDisplayPeriodID = None, setCreatedTime = None, setDisplayPeriodID = None, setHideMeetDisplayPeriod = None, setIsPrimary = None, setLockDisplayPeriod = None, setMeetDisplayPeriodEndTime = None, setMeetDisplayPeriodIDClonedFrom = None, setMeetDisplayPeriodStartTime = None, setMeetID = None, setModifiedTime = None, setScheduledBySectionScheduler = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferingEntity = None, returnMeetDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnLockDisplayPeriod = False, returnMeetDisplayPeriodEndTime = False, returnMeetDisplayPeriodIDClonedFrom = False, returnMeetDisplayPeriodStartTime = False, returnMeetID = False, returnModifiedTime = False, returnScheduledBySectionScheduler = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetDisplayPeriod/" + str(MeetDisplayPeriodID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMeetDisplayPeriod(EntityID = 1, setMeetDisplayPeriodID = None, setCreatedTime = None, setDisplayPeriodID = None, setHideMeetDisplayPeriod = None, setIsPrimary = None, setLockDisplayPeriod = None, setMeetDisplayPeriodEndTime = None, setMeetDisplayPeriodIDClonedFrom = None, setMeetDisplayPeriodStartTime = None, setMeetID = None, setModifiedTime = None, setScheduledBySectionScheduler = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferingEntity = None, returnMeetDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnHideMeetDisplayPeriod = False, returnIsPrimary = False, returnLockDisplayPeriod = False, returnMeetDisplayPeriodEndTime = False, returnMeetDisplayPeriodIDClonedFrom = False, returnMeetDisplayPeriodStartTime = False, returnMeetID = False, returnModifiedTime = False, returnScheduledBySectionScheduler = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetDisplayPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMeetDisplayPeriod(MeetDisplayPeriodID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetDisplayPeriod/" + str(MeetDisplayPeriodID), verb = "delete")


def getEveryMeetEntityRoomPeriod(searchConditions = [], EntityID = 1, returnMeetID = False, returnCalendarID = False, returnDisplayPeriodID = False, returnEndDate = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsDefaultCalendar = False, returnMeetSummaryID = False, returnRoomID = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnUseRoomOverride = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MeetEntityRoomPeriod in the district.

    This function returns a dataframe of every MeetEntityRoomPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMeetEntityRoomPeriod(MeetID, EntityID = 1, returnMeetID = False, returnCalendarID = False, returnDisplayPeriodID = False, returnEndDate = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsDefaultCalendar = False, returnMeetSummaryID = False, returnRoomID = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnUseRoomOverride = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriod/" + str(MeetID), verb = "get", return_params_list = return_params)

def modifyMeetEntityRoomPeriod(MeetID, EntityID = 1, setMeetID = None, setCalendarID = None, setDisplayPeriodID = None, setEndDate = None, setEntityIDCourse = None, setEntityIDFor = None, setEntityIDViewingCalculated = None, setEntityIDViewingMeetSummary = None, setIsDefaultCalendar = None, setMeetSummaryID = None, setRoomID = None, setSchedulingPeriodID = None, setSchoolYearID = None, setSectionID = None, setStartDate = None, setUseRoomOverride = None, returnMeetID = False, returnCalendarID = False, returnDisplayPeriodID = False, returnEndDate = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsDefaultCalendar = False, returnMeetSummaryID = False, returnRoomID = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnUseRoomOverride = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriod/" + str(MeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMeetEntityRoomPeriod(EntityID = 1, setMeetID = None, setCalendarID = None, setDisplayPeriodID = None, setEndDate = None, setEntityIDCourse = None, setEntityIDFor = None, setEntityIDViewingCalculated = None, setEntityIDViewingMeetSummary = None, setIsDefaultCalendar = None, setMeetSummaryID = None, setRoomID = None, setSchedulingPeriodID = None, setSchoolYearID = None, setSectionID = None, setStartDate = None, setUseRoomOverride = None, returnMeetID = False, returnCalendarID = False, returnDisplayPeriodID = False, returnEndDate = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsDefaultCalendar = False, returnMeetSummaryID = False, returnRoomID = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnUseRoomOverride = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMeetEntityRoomPeriod(MeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriod/" + str(MeetID), verb = "delete")


def getEveryMeetEntityRoomPeriodDateSeatsAvailable(searchConditions = [], EntityID = 1, returnMeetID = False, returnCalendarID = False, returnDate = False, returnDisplayPeriodID = False, returnEndDate = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsOfferedMeet = False, returnMaxSeats = False, returnMaxSeatsMeet = False, returnMaxSeatsMeetOverride = False, returnMeetSummaryID = False, returnRoomID = False, returnRoomIDMeet = False, returnRoomIDMeetOverride = False, returnRoomSeatsAvailable = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnUseRoomOverride = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MeetEntityRoomPeriodDateSeatsAvailable in the district.

    This function returns a dataframe of every MeetEntityRoomPeriodDateSeatsAvailable in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriodDateSeatsAvailable/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriodDateSeatsAvailable/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMeetEntityRoomPeriodDateSeatsAvailable(MeetID, EntityID = 1, returnMeetID = False, returnCalendarID = False, returnDate = False, returnDisplayPeriodID = False, returnEndDate = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsOfferedMeet = False, returnMaxSeats = False, returnMaxSeatsMeet = False, returnMaxSeatsMeetOverride = False, returnMeetSummaryID = False, returnRoomID = False, returnRoomIDMeet = False, returnRoomIDMeetOverride = False, returnRoomSeatsAvailable = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnUseRoomOverride = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriodDateSeatsAvailable/" + str(MeetID), verb = "get", return_params_list = return_params)

def modifyMeetEntityRoomPeriodDateSeatsAvailable(MeetID, EntityID = 1, setMeetID = None, setCalendarID = None, setDate = None, setDisplayPeriodID = None, setEndDate = None, setEntityIDCourse = None, setEntityIDFor = None, setEntityIDViewingCalculated = None, setEntityIDViewingMeetSummary = None, setIsOfferedMeet = None, setMaxSeats = None, setMaxSeatsMeet = None, setMaxSeatsMeetOverride = None, setMeetSummaryID = None, setRoomID = None, setRoomIDMeet = None, setRoomIDMeetOverride = None, setRoomSeatsAvailable = None, setSchedulingPeriodID = None, setSchoolYearID = None, setSectionID = None, setStartDate = None, setUseRoomOverride = None, returnMeetID = False, returnCalendarID = False, returnDate = False, returnDisplayPeriodID = False, returnEndDate = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsOfferedMeet = False, returnMaxSeats = False, returnMaxSeatsMeet = False, returnMaxSeatsMeetOverride = False, returnMeetSummaryID = False, returnRoomID = False, returnRoomIDMeet = False, returnRoomIDMeetOverride = False, returnRoomSeatsAvailable = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnUseRoomOverride = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriodDateSeatsAvailable/" + str(MeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMeetEntityRoomPeriodDateSeatsAvailable(EntityID = 1, setMeetID = None, setCalendarID = None, setDate = None, setDisplayPeriodID = None, setEndDate = None, setEntityIDCourse = None, setEntityIDFor = None, setEntityIDViewingCalculated = None, setEntityIDViewingMeetSummary = None, setIsOfferedMeet = None, setMaxSeats = None, setMaxSeatsMeet = None, setMaxSeatsMeetOverride = None, setMeetSummaryID = None, setRoomID = None, setRoomIDMeet = None, setRoomIDMeetOverride = None, setRoomSeatsAvailable = None, setSchedulingPeriodID = None, setSchoolYearID = None, setSectionID = None, setStartDate = None, setUseRoomOverride = None, returnMeetID = False, returnCalendarID = False, returnDate = False, returnDisplayPeriodID = False, returnEndDate = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsOfferedMeet = False, returnMaxSeats = False, returnMaxSeatsMeet = False, returnMaxSeatsMeetOverride = False, returnMeetSummaryID = False, returnRoomID = False, returnRoomIDMeet = False, returnRoomIDMeetOverride = False, returnRoomSeatsAvailable = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDate = False, returnUseRoomOverride = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriodDateSeatsAvailable/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMeetEntityRoomPeriodDateSeatsAvailable(MeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetEntityRoomPeriodDateSeatsAvailable/" + str(MeetID), verb = "delete")


def getEveryMeetRequirement(searchConditions = [], EntityID = 1, returnMeetRequirementID = False, returnAllowMultiplePeriodsPerDayRotation = False, returnCourseID = False, returnCreatedTime = False, returnDaysPerRotation = False, returnForceConsecutivePeriods = False, returnMeetRequirementIDClonedFrom = False, returnMeetRequirementIDClonedTo = False, returnMinutesPerDay = False, returnModifiedTime = False, returnTimeSpanAnalysisType = False, returnTimeSpanAnalysisTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MeetRequirement in the district.

    This function returns a dataframe of every MeetRequirement in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetRequirement/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetRequirement/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMeetRequirement(MeetRequirementID, EntityID = 1, returnMeetRequirementID = False, returnAllowMultiplePeriodsPerDayRotation = False, returnCourseID = False, returnCreatedTime = False, returnDaysPerRotation = False, returnForceConsecutivePeriods = False, returnMeetRequirementIDClonedFrom = False, returnMeetRequirementIDClonedTo = False, returnMinutesPerDay = False, returnModifiedTime = False, returnTimeSpanAnalysisType = False, returnTimeSpanAnalysisTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetRequirement/" + str(MeetRequirementID), verb = "get", return_params_list = return_params)

def modifyMeetRequirement(MeetRequirementID, EntityID = 1, setMeetRequirementID = None, setAllowMultiplePeriodsPerDayRotation = None, setCourseID = None, setCreatedTime = None, setDaysPerRotation = None, setForceConsecutivePeriods = None, setMeetRequirementIDClonedFrom = None, setMeetRequirementIDClonedTo = None, setMinutesPerDay = None, setModifiedTime = None, setTimeSpanAnalysisType = None, setTimeSpanAnalysisTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMeetRequirementID = False, returnAllowMultiplePeriodsPerDayRotation = False, returnCourseID = False, returnCreatedTime = False, returnDaysPerRotation = False, returnForceConsecutivePeriods = False, returnMeetRequirementIDClonedFrom = False, returnMeetRequirementIDClonedTo = False, returnMinutesPerDay = False, returnModifiedTime = False, returnTimeSpanAnalysisType = False, returnTimeSpanAnalysisTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetRequirement/" + str(MeetRequirementID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMeetRequirement(EntityID = 1, setMeetRequirementID = None, setAllowMultiplePeriodsPerDayRotation = None, setCourseID = None, setCreatedTime = None, setDaysPerRotation = None, setForceConsecutivePeriods = None, setMeetRequirementIDClonedFrom = None, setMeetRequirementIDClonedTo = None, setMinutesPerDay = None, setModifiedTime = None, setTimeSpanAnalysisType = None, setTimeSpanAnalysisTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMeetRequirementID = False, returnAllowMultiplePeriodsPerDayRotation = False, returnCourseID = False, returnCreatedTime = False, returnDaysPerRotation = False, returnForceConsecutivePeriods = False, returnMeetRequirementIDClonedFrom = False, returnMeetRequirementIDClonedTo = False, returnMinutesPerDay = False, returnModifiedTime = False, returnTimeSpanAnalysisType = False, returnTimeSpanAnalysisTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetRequirement/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMeetRequirement(MeetRequirementID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetRequirement/" + str(MeetRequirementID), verb = "delete")


def getEveryMeetSummary(searchConditions = [], EntityID = 1, returnMeetSummaryID = False, returnCalculatedDays = False, returnCalculatedDaysStudent = False, returnCalculatedPeriod = False, returnCalculatedPeriodStudent = False, returnCalendarID = False, returnCreatedTime = False, returnDays = False, returnEntityIDViewing = False, returnHasOnlyHiddenDetails = False, returnIsDefaultCalendar = False, returnIsPrimary = False, returnMeetID = False, returnModifiedTime = False, returnPeriod = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MeetSummary in the district.

    This function returns a dataframe of every MeetSummary in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummary/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummary/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMeetSummary(MeetSummaryID, EntityID = 1, returnMeetSummaryID = False, returnCalculatedDays = False, returnCalculatedDaysStudent = False, returnCalculatedPeriod = False, returnCalculatedPeriodStudent = False, returnCalendarID = False, returnCreatedTime = False, returnDays = False, returnEntityIDViewing = False, returnHasOnlyHiddenDetails = False, returnIsDefaultCalendar = False, returnIsPrimary = False, returnMeetID = False, returnModifiedTime = False, returnPeriod = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummary/" + str(MeetSummaryID), verb = "get", return_params_list = return_params)

def modifyMeetSummary(MeetSummaryID, EntityID = 1, setMeetSummaryID = None, setCalculatedDays = None, setCalculatedDaysStudent = None, setCalculatedPeriod = None, setCalculatedPeriodStudent = None, setCalendarID = None, setCreatedTime = None, setDays = None, setEntityIDViewing = None, setHasOnlyHiddenDetails = None, setIsDefaultCalendar = None, setIsPrimary = None, setMeetID = None, setModifiedTime = None, setPeriod = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMeetSummaryID = False, returnCalculatedDays = False, returnCalculatedDaysStudent = False, returnCalculatedPeriod = False, returnCalculatedPeriodStudent = False, returnCalendarID = False, returnCreatedTime = False, returnDays = False, returnEntityIDViewing = False, returnHasOnlyHiddenDetails = False, returnIsDefaultCalendar = False, returnIsPrimary = False, returnMeetID = False, returnModifiedTime = False, returnPeriod = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummary/" + str(MeetSummaryID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMeetSummary(EntityID = 1, setMeetSummaryID = None, setCalculatedDays = None, setCalculatedDaysStudent = None, setCalculatedPeriod = None, setCalculatedPeriodStudent = None, setCalendarID = None, setCreatedTime = None, setDays = None, setEntityIDViewing = None, setHasOnlyHiddenDetails = None, setIsDefaultCalendar = None, setIsPrimary = None, setMeetID = None, setModifiedTime = None, setPeriod = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMeetSummaryID = False, returnCalculatedDays = False, returnCalculatedDaysStudent = False, returnCalculatedPeriod = False, returnCalculatedPeriodStudent = False, returnCalendarID = False, returnCreatedTime = False, returnDays = False, returnEntityIDViewing = False, returnHasOnlyHiddenDetails = False, returnIsDefaultCalendar = False, returnIsPrimary = False, returnMeetID = False, returnModifiedTime = False, returnPeriod = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummary/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMeetSummary(MeetSummaryID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummary/" + str(MeetSummaryID), verb = "delete")


def getEveryMeetSummaryDetail(searchConditions = [], EntityID = 1, returnMeetSummaryDetailID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnIsPrimary = False, returnMeetSummaryID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every MeetSummaryDetail in the district.

    This function returns a dataframe of every MeetSummaryDetail in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummaryDetail/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummaryDetail/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getMeetSummaryDetail(MeetSummaryDetailID, EntityID = 1, returnMeetSummaryDetailID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnIsPrimary = False, returnMeetSummaryID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummaryDetail/" + str(MeetSummaryDetailID), verb = "get", return_params_list = return_params)

def modifyMeetSummaryDetail(MeetSummaryDetailID, EntityID = 1, setMeetSummaryDetailID = None, setCreatedTime = None, setDisplayPeriodID = None, setIsPrimary = None, setMeetSummaryID = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMeetSummaryDetailID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnIsPrimary = False, returnMeetSummaryID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummaryDetail/" + str(MeetSummaryDetailID), verb = "post", return_params_list = return_params, payload = payload_params)

def createMeetSummaryDetail(EntityID = 1, setMeetSummaryDetailID = None, setCreatedTime = None, setDisplayPeriodID = None, setIsPrimary = None, setMeetSummaryID = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnMeetSummaryDetailID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnIsPrimary = False, returnMeetSummaryID = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummaryDetail/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteMeetSummaryDetail(MeetSummaryDetailID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/MeetSummaryDetail/" + str(MeetSummaryDetailID), verb = "delete")


def getEveryOpenPeriodAnalysis(searchConditions = [], EntityID = 1, returnOpenPeriodAnalysisID = False, returnCreatedTime = False, returnEndTime = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnStartTime = False, returnStatus = False, returnStatusCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every OpenPeriodAnalysis in the district.

    This function returns a dataframe of every OpenPeriodAnalysis in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysis/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysis/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getOpenPeriodAnalysis(OpenPeriodAnalysisID, EntityID = 1, returnOpenPeriodAnalysisID = False, returnCreatedTime = False, returnEndTime = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnStartTime = False, returnStatus = False, returnStatusCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysis/" + str(OpenPeriodAnalysisID), verb = "get", return_params_list = return_params)

def modifyOpenPeriodAnalysis(OpenPeriodAnalysisID, EntityID = 1, setOpenPeriodAnalysisID = None, setCreatedTime = None, setEndTime = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setStartTime = None, setStatus = None, setStatusCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUserIDPerformer = None, returnOpenPeriodAnalysisID = False, returnCreatedTime = False, returnEndTime = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnStartTime = False, returnStatus = False, returnStatusCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysis/" + str(OpenPeriodAnalysisID), verb = "post", return_params_list = return_params, payload = payload_params)

def createOpenPeriodAnalysis(EntityID = 1, setOpenPeriodAnalysisID = None, setCreatedTime = None, setEndTime = None, setEntityID = None, setModifiedTime = None, setSchoolYearID = None, setStartTime = None, setStatus = None, setStatusCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUserIDPerformer = None, returnOpenPeriodAnalysisID = False, returnCreatedTime = False, returnEndTime = False, returnEntityID = False, returnModifiedTime = False, returnSchoolYearID = False, returnStartTime = False, returnStatus = False, returnStatusCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysis/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteOpenPeriodAnalysis(OpenPeriodAnalysisID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysis/" + str(OpenPeriodAnalysisID), verb = "delete")


def getEveryOpenPeriodAnalysisStudent(searchConditions = [], EntityID = 1, returnOpenPeriodAnalysisStudentID = False, returnCreatedTime = False, returnFirstName = False, returnGradeLevelCode = False, returnIsActive = False, returnLastName = False, returnMiddleName = False, returnModifiedTime = False, returnOpenPeriodAnalysisID = False, returnStudentID = False, returnStudentNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every OpenPeriodAnalysisStudent in the district.

    This function returns a dataframe of every OpenPeriodAnalysisStudent in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysisStudent/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysisStudent/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getOpenPeriodAnalysisStudent(OpenPeriodAnalysisStudentID, EntityID = 1, returnOpenPeriodAnalysisStudentID = False, returnCreatedTime = False, returnFirstName = False, returnGradeLevelCode = False, returnIsActive = False, returnLastName = False, returnMiddleName = False, returnModifiedTime = False, returnOpenPeriodAnalysisID = False, returnStudentID = False, returnStudentNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysisStudent/" + str(OpenPeriodAnalysisStudentID), verb = "get", return_params_list = return_params)

def modifyOpenPeriodAnalysisStudent(OpenPeriodAnalysisStudentID, EntityID = 1, setOpenPeriodAnalysisStudentID = None, setCreatedTime = None, setFirstName = None, setGradeLevelCode = None, setIsActive = None, setLastName = None, setMiddleName = None, setModifiedTime = None, setOpenPeriodAnalysisID = None, setStudentID = None, setStudentNumber = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnOpenPeriodAnalysisStudentID = False, returnCreatedTime = False, returnFirstName = False, returnGradeLevelCode = False, returnIsActive = False, returnLastName = False, returnMiddleName = False, returnModifiedTime = False, returnOpenPeriodAnalysisID = False, returnStudentID = False, returnStudentNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysisStudent/" + str(OpenPeriodAnalysisStudentID), verb = "post", return_params_list = return_params, payload = payload_params)

def createOpenPeriodAnalysisStudent(EntityID = 1, setOpenPeriodAnalysisStudentID = None, setCreatedTime = None, setFirstName = None, setGradeLevelCode = None, setIsActive = None, setLastName = None, setMiddleName = None, setModifiedTime = None, setOpenPeriodAnalysisID = None, setStudentID = None, setStudentNumber = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnOpenPeriodAnalysisStudentID = False, returnCreatedTime = False, returnFirstName = False, returnGradeLevelCode = False, returnIsActive = False, returnLastName = False, returnMiddleName = False, returnModifiedTime = False, returnOpenPeriodAnalysisID = False, returnStudentID = False, returnStudentNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysisStudent/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteOpenPeriodAnalysisStudent(OpenPeriodAnalysisStudentID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/OpenPeriodAnalysisStudent/" + str(OpenPeriodAnalysisStudentID), verb = "delete")


def getEveryPrerequisiteCurriculumCourse(searchConditions = [], EntityID = 1, returnPrerequisiteCurriculumCourseID = False, returnCourseID = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnEntityID = False, returnNumericYear = False, returnPrerequisiteCurriculumID = False, returnPrerequisiteID = False, returnSchoolYearID = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every PrerequisiteCurriculumCourse in the district.

    This function returns a dataframe of every PrerequisiteCurriculumCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/PrerequisiteCurriculumCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/PrerequisiteCurriculumCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getPrerequisiteCurriculumCourse(PrerequisiteCurriculumCourseID, EntityID = 1, returnPrerequisiteCurriculumCourseID = False, returnCourseID = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnEntityID = False, returnNumericYear = False, returnPrerequisiteCurriculumID = False, returnPrerequisiteID = False, returnSchoolYearID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/PrerequisiteCurriculumCourse/" + str(PrerequisiteCurriculumCourseID), verb = "get", return_params_list = return_params)

def modifyPrerequisiteCurriculumCourse(PrerequisiteCurriculumCourseID, EntityID = 1, setPrerequisiteCurriculumCourseID = None, setCourseID = None, setCurriculumIDFor = None, setCurriculumIDRequired = None, setEntityID = None, setNumericYear = None, setPrerequisiteCurriculumID = None, setPrerequisiteID = None, setSchoolYearID = None, returnPrerequisiteCurriculumCourseID = False, returnCourseID = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnEntityID = False, returnNumericYear = False, returnPrerequisiteCurriculumID = False, returnPrerequisiteID = False, returnSchoolYearID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/PrerequisiteCurriculumCourse/" + str(PrerequisiteCurriculumCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createPrerequisiteCurriculumCourse(EntityID = 1, setPrerequisiteCurriculumCourseID = None, setCourseID = None, setCurriculumIDFor = None, setCurriculumIDRequired = None, setEntityID = None, setNumericYear = None, setPrerequisiteCurriculumID = None, setPrerequisiteID = None, setSchoolYearID = None, returnPrerequisiteCurriculumCourseID = False, returnCourseID = False, returnCurriculumIDFor = False, returnCurriculumIDRequired = False, returnEntityID = False, returnNumericYear = False, returnPrerequisiteCurriculumID = False, returnPrerequisiteID = False, returnSchoolYearID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/PrerequisiteCurriculumCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deletePrerequisiteCurriculumCourse(PrerequisiteCurriculumCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/PrerequisiteCurriculumCourse/" + str(PrerequisiteCurriculumCourseID), verb = "delete")


def getEveryProcessRestriction(searchConditions = [], EntityID = 1, returnProcessRestrictionID = False, returnCreatedTime = False, returnEntityID = False, returnLockCourseMaster = False, returnLockCourseMasterSetByMassStudentSchedulerUtility = False, returnLockMassStudentSchedulerUtility = False, returnLockMassStudentSchedulerUtilitySetByMassStudentSchedulerUtility = False, returnLockMassUnscheduleStudentSectionsUtility = False, returnLockMassUnscheduleStudentSectionsUtilitySetByMassStudentSchedulerUtility = False, returnLockSchedulingBoard = False, returnLockSchedulingBoardSetByMassStudentSchedulerUtility = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDLockCourseMasterPerformer = False, returnUserIDLockMassStudentSchedulerUtilityPerformer = False, returnUserIDLockMassUnscheduleStudentSectionsUtilityPerformer = False, returnUserIDLockSchedulingBoardPerformer = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every ProcessRestriction in the district.

    This function returns a dataframe of every ProcessRestriction in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ProcessRestriction/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ProcessRestriction/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getProcessRestriction(ProcessRestrictionID, EntityID = 1, returnProcessRestrictionID = False, returnCreatedTime = False, returnEntityID = False, returnLockCourseMaster = False, returnLockCourseMasterSetByMassStudentSchedulerUtility = False, returnLockMassStudentSchedulerUtility = False, returnLockMassStudentSchedulerUtilitySetByMassStudentSchedulerUtility = False, returnLockMassUnscheduleStudentSectionsUtility = False, returnLockMassUnscheduleStudentSectionsUtilitySetByMassStudentSchedulerUtility = False, returnLockSchedulingBoard = False, returnLockSchedulingBoardSetByMassStudentSchedulerUtility = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDLockCourseMasterPerformer = False, returnUserIDLockMassStudentSchedulerUtilityPerformer = False, returnUserIDLockMassUnscheduleStudentSectionsUtilityPerformer = False, returnUserIDLockSchedulingBoardPerformer = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ProcessRestriction/" + str(ProcessRestrictionID), verb = "get", return_params_list = return_params)

def modifyProcessRestriction(ProcessRestrictionID, EntityID = 1, setProcessRestrictionID = None, setCreatedTime = None, setEntityID = None, setLockCourseMaster = None, setLockCourseMasterSetByMassStudentSchedulerUtility = None, setLockMassStudentSchedulerUtility = None, setLockMassStudentSchedulerUtilitySetByMassStudentSchedulerUtility = None, setLockMassUnscheduleStudentSectionsUtility = None, setLockMassUnscheduleStudentSectionsUtilitySetByMassStudentSchedulerUtility = None, setLockSchedulingBoard = None, setLockSchedulingBoardSetByMassStudentSchedulerUtility = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDLockCourseMasterPerformer = None, setUserIDLockMassStudentSchedulerUtilityPerformer = None, setUserIDLockMassUnscheduleStudentSectionsUtilityPerformer = None, setUserIDLockSchedulingBoardPerformer = None, setUserIDModifiedBy = None, returnProcessRestrictionID = False, returnCreatedTime = False, returnEntityID = False, returnLockCourseMaster = False, returnLockCourseMasterSetByMassStudentSchedulerUtility = False, returnLockMassStudentSchedulerUtility = False, returnLockMassStudentSchedulerUtilitySetByMassStudentSchedulerUtility = False, returnLockMassUnscheduleStudentSectionsUtility = False, returnLockMassUnscheduleStudentSectionsUtilitySetByMassStudentSchedulerUtility = False, returnLockSchedulingBoard = False, returnLockSchedulingBoardSetByMassStudentSchedulerUtility = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDLockCourseMasterPerformer = False, returnUserIDLockMassStudentSchedulerUtilityPerformer = False, returnUserIDLockMassUnscheduleStudentSectionsUtilityPerformer = False, returnUserIDLockSchedulingBoardPerformer = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ProcessRestriction/" + str(ProcessRestrictionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createProcessRestriction(EntityID = 1, setProcessRestrictionID = None, setCreatedTime = None, setEntityID = None, setLockCourseMaster = None, setLockCourseMasterSetByMassStudentSchedulerUtility = None, setLockMassStudentSchedulerUtility = None, setLockMassStudentSchedulerUtilitySetByMassStudentSchedulerUtility = None, setLockMassUnscheduleStudentSectionsUtility = None, setLockMassUnscheduleStudentSectionsUtilitySetByMassStudentSchedulerUtility = None, setLockSchedulingBoard = None, setLockSchedulingBoardSetByMassStudentSchedulerUtility = None, setModifiedTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDLockCourseMasterPerformer = None, setUserIDLockMassStudentSchedulerUtilityPerformer = None, setUserIDLockMassUnscheduleStudentSectionsUtilityPerformer = None, setUserIDLockSchedulingBoardPerformer = None, setUserIDModifiedBy = None, returnProcessRestrictionID = False, returnCreatedTime = False, returnEntityID = False, returnLockCourseMaster = False, returnLockCourseMasterSetByMassStudentSchedulerUtility = False, returnLockMassStudentSchedulerUtility = False, returnLockMassStudentSchedulerUtilitySetByMassStudentSchedulerUtility = False, returnLockMassUnscheduleStudentSectionsUtility = False, returnLockMassUnscheduleStudentSectionsUtilitySetByMassStudentSchedulerUtility = False, returnLockSchedulingBoard = False, returnLockSchedulingBoardSetByMassStudentSchedulerUtility = False, returnModifiedTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDLockCourseMasterPerformer = False, returnUserIDLockMassStudentSchedulerUtilityPerformer = False, returnUserIDLockMassUnscheduleStudentSectionsUtilityPerformer = False, returnUserIDLockSchedulingBoardPerformer = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ProcessRestriction/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteProcessRestriction(ProcessRestrictionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ProcessRestriction/" + str(ProcessRestrictionID), verb = "delete")


def getEveryQueuedStudentSection(searchConditions = [], EntityID = 1, returnQueuedStudentSectionID = False, returnCreatedTime = False, returnIsComplete = False, returnModifiedTime = False, returnSourceProcess = False, returnSourceProcessCode = False, returnStudentSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every QueuedStudentSection in the district.

    This function returns a dataframe of every QueuedStudentSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/QueuedStudentSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/QueuedStudentSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getQueuedStudentSection(QueuedStudentSectionID, EntityID = 1, returnQueuedStudentSectionID = False, returnCreatedTime = False, returnIsComplete = False, returnModifiedTime = False, returnSourceProcess = False, returnSourceProcessCode = False, returnStudentSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/QueuedStudentSection/" + str(QueuedStudentSectionID), verb = "get", return_params_list = return_params)

def modifyQueuedStudentSection(QueuedStudentSectionID, EntityID = 1, setQueuedStudentSectionID = None, setCreatedTime = None, setIsComplete = None, setModifiedTime = None, setSourceProcess = None, setSourceProcessCode = None, setStudentSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnQueuedStudentSectionID = False, returnCreatedTime = False, returnIsComplete = False, returnModifiedTime = False, returnSourceProcess = False, returnSourceProcessCode = False, returnStudentSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/QueuedStudentSection/" + str(QueuedStudentSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createQueuedStudentSection(EntityID = 1, setQueuedStudentSectionID = None, setCreatedTime = None, setIsComplete = None, setModifiedTime = None, setSourceProcess = None, setSourceProcessCode = None, setStudentSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnQueuedStudentSectionID = False, returnCreatedTime = False, returnIsComplete = False, returnModifiedTime = False, returnSourceProcess = False, returnSourceProcessCode = False, returnStudentSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/QueuedStudentSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteQueuedStudentSection(QueuedStudentSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/QueuedStudentSection/" + str(QueuedStudentSectionID), verb = "delete")


def getEveryScheduleRestorePoint(searchConditions = [], EntityID = 1, returnScheduleRestorePointID = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnReportQueueID = False, returnRestorePointDateTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every ScheduleRestorePoint in the district.

    This function returns a dataframe of every ScheduleRestorePoint in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ScheduleRestorePoint/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ScheduleRestorePoint/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getScheduleRestorePoint(ScheduleRestorePointID, EntityID = 1, returnScheduleRestorePointID = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnReportQueueID = False, returnRestorePointDateTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ScheduleRestorePoint/" + str(ScheduleRestorePointID), verb = "get", return_params_list = return_params)

def modifyScheduleRestorePoint(ScheduleRestorePointID, EntityID = 1, setScheduleRestorePointID = None, setCreatedTime = None, setDescription = None, setEntityID = None, setModifiedTime = None, setName = None, setNameDescription = None, setReportQueueID = None, setRestorePointDateTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnScheduleRestorePointID = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnReportQueueID = False, returnRestorePointDateTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ScheduleRestorePoint/" + str(ScheduleRestorePointID), verb = "post", return_params_list = return_params, payload = payload_params)

def createScheduleRestorePoint(EntityID = 1, setScheduleRestorePointID = None, setCreatedTime = None, setDescription = None, setEntityID = None, setModifiedTime = None, setName = None, setNameDescription = None, setReportQueueID = None, setRestorePointDateTime = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnScheduleRestorePointID = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnReportQueueID = False, returnRestorePointDateTime = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ScheduleRestorePoint/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteScheduleRestorePoint(ScheduleRestorePointID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/ScheduleRestorePoint/" + str(ScheduleRestorePointID), verb = "delete")


def getEverySchedulingBoardFilter(searchConditions = [], EntityID = 1, returnSchedulingBoardFilterID = False, returnCreatedTime = False, returnDescription = False, returnDisplayOrder = False, returnModifiedTime = False, returnSkywardHash = False, returnSkywardID = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SchedulingBoardFilter in the district.

    This function returns a dataframe of every SchedulingBoardFilter in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingBoardFilter/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingBoardFilter/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSchedulingBoardFilter(SchedulingBoardFilterID, EntityID = 1, returnSchedulingBoardFilterID = False, returnCreatedTime = False, returnDescription = False, returnDisplayOrder = False, returnModifiedTime = False, returnSkywardHash = False, returnSkywardID = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingBoardFilter/" + str(SchedulingBoardFilterID), verb = "get", return_params_list = return_params)

def modifySchedulingBoardFilter(SchedulingBoardFilterID, EntityID = 1, setSchedulingBoardFilterID = None, setCreatedTime = None, setDescription = None, setDisplayOrder = None, setModifiedTime = None, setSkywardHash = None, setSkywardID = None, setType = None, setTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingBoardFilterID = False, returnCreatedTime = False, returnDescription = False, returnDisplayOrder = False, returnModifiedTime = False, returnSkywardHash = False, returnSkywardID = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingBoardFilter/" + str(SchedulingBoardFilterID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSchedulingBoardFilter(EntityID = 1, setSchedulingBoardFilterID = None, setCreatedTime = None, setDescription = None, setDisplayOrder = None, setModifiedTime = None, setSkywardHash = None, setSkywardID = None, setType = None, setTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingBoardFilterID = False, returnCreatedTime = False, returnDescription = False, returnDisplayOrder = False, returnModifiedTime = False, returnSkywardHash = False, returnSkywardID = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingBoardFilter/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSchedulingBoardFilter(SchedulingBoardFilterID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingBoardFilter/" + str(SchedulingBoardFilterID), verb = "delete")


def getEverySchedulingCategory(searchConditions = [], EntityID = 1, returnSchedulingCategoryID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchedulingCategoryIDClonedFrom = False, returnSchedulingCategoryIDClonedTo = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SchedulingCategory in the district.

    This function returns a dataframe of every SchedulingCategory in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingCategory/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingCategory/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSchedulingCategory(SchedulingCategoryID, EntityID = 1, returnSchedulingCategoryID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchedulingCategoryIDClonedFrom = False, returnSchedulingCategoryIDClonedTo = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingCategory/" + str(SchedulingCategoryID), verb = "get", return_params_list = return_params)

def modifySchedulingCategory(SchedulingCategoryID, EntityID = 1, setSchedulingCategoryID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setSchedulingCategoryIDClonedFrom = None, setSchedulingCategoryIDClonedTo = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingCategoryID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchedulingCategoryIDClonedFrom = False, returnSchedulingCategoryIDClonedTo = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingCategory/" + str(SchedulingCategoryID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSchedulingCategory(EntityID = 1, setSchedulingCategoryID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setSchedulingCategoryIDClonedFrom = None, setSchedulingCategoryIDClonedTo = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingCategoryID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchedulingCategoryIDClonedFrom = False, returnSchedulingCategoryIDClonedTo = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingCategory/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSchedulingCategory(SchedulingCategoryID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingCategory/" + str(SchedulingCategoryID), verb = "delete")


def getEverySchedulingGroup(searchConditions = [], EntityID = 1, returnSchedulingGroupID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnGradeReferenceID = False, returnHomeroomID = False, returnModifiedTime = False, returnSchedulingGroupIDClonedFrom = False, returnSchedulingGroupIDClonedTo = False, returnSchoolYearID = False, returnTotalSchedulingGroupCoursesCount = False, returnTotalSchedulingGroupSectionsCount = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SchedulingGroup in the district.

    This function returns a dataframe of every SchedulingGroup in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroup/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroup/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSchedulingGroup(SchedulingGroupID, EntityID = 1, returnSchedulingGroupID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnGradeReferenceID = False, returnHomeroomID = False, returnModifiedTime = False, returnSchedulingGroupIDClonedFrom = False, returnSchedulingGroupIDClonedTo = False, returnSchoolYearID = False, returnTotalSchedulingGroupCoursesCount = False, returnTotalSchedulingGroupSectionsCount = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroup/" + str(SchedulingGroupID), verb = "get", return_params_list = return_params)

def modifySchedulingGroup(SchedulingGroupID, EntityID = 1, setSchedulingGroupID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEntityID = None, setGradeReferenceID = None, setHomeroomID = None, setModifiedTime = None, setSchedulingGroupIDClonedFrom = None, setSchedulingGroupIDClonedTo = None, setSchoolYearID = None, setTotalSchedulingGroupCoursesCount = None, setTotalSchedulingGroupSectionsCount = None, setType = None, setTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingGroupID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnGradeReferenceID = False, returnHomeroomID = False, returnModifiedTime = False, returnSchedulingGroupIDClonedFrom = False, returnSchedulingGroupIDClonedTo = False, returnSchoolYearID = False, returnTotalSchedulingGroupCoursesCount = False, returnTotalSchedulingGroupSectionsCount = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroup/" + str(SchedulingGroupID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSchedulingGroup(EntityID = 1, setSchedulingGroupID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEntityID = None, setGradeReferenceID = None, setHomeroomID = None, setModifiedTime = None, setSchedulingGroupIDClonedFrom = None, setSchedulingGroupIDClonedTo = None, setSchoolYearID = None, setTotalSchedulingGroupCoursesCount = None, setTotalSchedulingGroupSectionsCount = None, setType = None, setTypeCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingGroupID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnGradeReferenceID = False, returnHomeroomID = False, returnModifiedTime = False, returnSchedulingGroupIDClonedFrom = False, returnSchedulingGroupIDClonedTo = False, returnSchoolYearID = False, returnTotalSchedulingGroupCoursesCount = False, returnTotalSchedulingGroupSectionsCount = False, returnType = False, returnTypeCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroup/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSchedulingGroup(SchedulingGroupID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroup/" + str(SchedulingGroupID), verb = "delete")


def getEverySchedulingGroupCourse(searchConditions = [], EntityID = 1, returnSchedulingGroupCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingGroupCourseIDClonedFrom = False, returnSchedulingGroupCourseIDClonedTo = False, returnSchedulingGroupID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SchedulingGroupCourse in the district.

    This function returns a dataframe of every SchedulingGroupCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSchedulingGroupCourse(SchedulingGroupCourseID, EntityID = 1, returnSchedulingGroupCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingGroupCourseIDClonedFrom = False, returnSchedulingGroupCourseIDClonedTo = False, returnSchedulingGroupID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupCourse/" + str(SchedulingGroupCourseID), verb = "get", return_params_list = return_params)

def modifySchedulingGroupCourse(SchedulingGroupCourseID, EntityID = 1, setSchedulingGroupCourseID = None, setCourseID = None, setCreatedTime = None, setModifiedTime = None, setSchedulingGroupCourseIDClonedFrom = None, setSchedulingGroupCourseIDClonedTo = None, setSchedulingGroupID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingGroupCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingGroupCourseIDClonedFrom = False, returnSchedulingGroupCourseIDClonedTo = False, returnSchedulingGroupID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupCourse/" + str(SchedulingGroupCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSchedulingGroupCourse(EntityID = 1, setSchedulingGroupCourseID = None, setCourseID = None, setCreatedTime = None, setModifiedTime = None, setSchedulingGroupCourseIDClonedFrom = None, setSchedulingGroupCourseIDClonedTo = None, setSchedulingGroupID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingGroupCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingGroupCourseIDClonedFrom = False, returnSchedulingGroupCourseIDClonedTo = False, returnSchedulingGroupID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSchedulingGroupCourse(SchedulingGroupCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupCourse/" + str(SchedulingGroupCourseID), verb = "delete")


def getEverySchedulingGroupSection(searchConditions = [], EntityID = 1, returnSchedulingGroupSectionID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingGroupID = False, returnSchedulingGroupSectionIDClonedFrom = False, returnSchedulingGroupSectionIDClonedTo = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SchedulingGroupSection in the district.

    This function returns a dataframe of every SchedulingGroupSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSchedulingGroupSection(SchedulingGroupSectionID, EntityID = 1, returnSchedulingGroupSectionID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingGroupID = False, returnSchedulingGroupSectionIDClonedFrom = False, returnSchedulingGroupSectionIDClonedTo = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupSection/" + str(SchedulingGroupSectionID), verb = "get", return_params_list = return_params)

def modifySchedulingGroupSection(SchedulingGroupSectionID, EntityID = 1, setSchedulingGroupSectionID = None, setCreatedTime = None, setModifiedTime = None, setSchedulingGroupID = None, setSchedulingGroupSectionIDClonedFrom = None, setSchedulingGroupSectionIDClonedTo = None, setSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingGroupSectionID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingGroupID = False, returnSchedulingGroupSectionIDClonedFrom = False, returnSchedulingGroupSectionIDClonedTo = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupSection/" + str(SchedulingGroupSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSchedulingGroupSection(EntityID = 1, setSchedulingGroupSectionID = None, setCreatedTime = None, setModifiedTime = None, setSchedulingGroupID = None, setSchedulingGroupSectionIDClonedFrom = None, setSchedulingGroupSectionIDClonedTo = None, setSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingGroupSectionID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingGroupID = False, returnSchedulingGroupSectionIDClonedFrom = False, returnSchedulingGroupSectionIDClonedTo = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSchedulingGroupSection(SchedulingGroupSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingGroupSection/" + str(SchedulingGroupSectionID), verb = "delete")


def getEverySchedulingPeriod(searchConditions = [], EntityID = 1, returnSchedulingPeriodID = False, returnCodeNumber = False, returnCreatedTime = False, returnDayRotationID = False, returnDynamicRelationshipID = False, returnEntityGroupKey = False, returnModifiedTime = False, returnSchedulingPeriodIDClonedFrom = False, returnSchedulingPeriodIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SchedulingPeriod in the district.

    This function returns a dataframe of every SchedulingPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSchedulingPeriod(SchedulingPeriodID, EntityID = 1, returnSchedulingPeriodID = False, returnCodeNumber = False, returnCreatedTime = False, returnDayRotationID = False, returnDynamicRelationshipID = False, returnEntityGroupKey = False, returnModifiedTime = False, returnSchedulingPeriodIDClonedFrom = False, returnSchedulingPeriodIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriod/" + str(SchedulingPeriodID), verb = "get", return_params_list = return_params)

def modifySchedulingPeriod(SchedulingPeriodID, EntityID = 1, setSchedulingPeriodID = None, setCodeNumber = None, setCreatedTime = None, setDayRotationID = None, setDynamicRelationshipID = None, setEntityGroupKey = None, setModifiedTime = None, setSchedulingPeriodIDClonedFrom = None, setSchedulingPeriodIDClonedTo = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingPeriodID = False, returnCodeNumber = False, returnCreatedTime = False, returnDayRotationID = False, returnDynamicRelationshipID = False, returnEntityGroupKey = False, returnModifiedTime = False, returnSchedulingPeriodIDClonedFrom = False, returnSchedulingPeriodIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriod/" + str(SchedulingPeriodID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSchedulingPeriod(EntityID = 1, setSchedulingPeriodID = None, setCodeNumber = None, setCreatedTime = None, setDayRotationID = None, setDynamicRelationshipID = None, setEntityGroupKey = None, setModifiedTime = None, setSchedulingPeriodIDClonedFrom = None, setSchedulingPeriodIDClonedTo = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingPeriodID = False, returnCodeNumber = False, returnCreatedTime = False, returnDayRotationID = False, returnDynamicRelationshipID = False, returnEntityGroupKey = False, returnModifiedTime = False, returnSchedulingPeriodIDClonedFrom = False, returnSchedulingPeriodIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSchedulingPeriod(SchedulingPeriodID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriod/" + str(SchedulingPeriodID), verb = "delete")


def getEverySchedulingPeriodDisplayPeriod(searchConditions = [], EntityID = 1, returnSchedulingPeriodDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnEntityGroupKey = False, returnLabel = False, returnModifiedTime = False, returnSchedulingPeriodDisplayPeriodIDClonedFrom = False, returnSchedulingPeriodID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SchedulingPeriodDisplayPeriod in the district.

    This function returns a dataframe of every SchedulingPeriodDisplayPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriodDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriodDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSchedulingPeriodDisplayPeriod(SchedulingPeriodDisplayPeriodID, EntityID = 1, returnSchedulingPeriodDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnEntityGroupKey = False, returnLabel = False, returnModifiedTime = False, returnSchedulingPeriodDisplayPeriodIDClonedFrom = False, returnSchedulingPeriodID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriodDisplayPeriod/" + str(SchedulingPeriodDisplayPeriodID), verb = "get", return_params_list = return_params)

def modifySchedulingPeriodDisplayPeriod(SchedulingPeriodDisplayPeriodID, EntityID = 1, setSchedulingPeriodDisplayPeriodID = None, setCreatedTime = None, setDisplayPeriodID = None, setEntityGroupKey = None, setLabel = None, setModifiedTime = None, setSchedulingPeriodDisplayPeriodIDClonedFrom = None, setSchedulingPeriodID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingPeriodDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnEntityGroupKey = False, returnLabel = False, returnModifiedTime = False, returnSchedulingPeriodDisplayPeriodIDClonedFrom = False, returnSchedulingPeriodID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriodDisplayPeriod/" + str(SchedulingPeriodDisplayPeriodID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSchedulingPeriodDisplayPeriod(EntityID = 1, setSchedulingPeriodDisplayPeriodID = None, setCreatedTime = None, setDisplayPeriodID = None, setEntityGroupKey = None, setLabel = None, setModifiedTime = None, setSchedulingPeriodDisplayPeriodIDClonedFrom = None, setSchedulingPeriodID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingPeriodDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnEntityGroupKey = False, returnLabel = False, returnModifiedTime = False, returnSchedulingPeriodDisplayPeriodIDClonedFrom = False, returnSchedulingPeriodID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriodDisplayPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSchedulingPeriodDisplayPeriod(SchedulingPeriodDisplayPeriodID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingPeriodDisplayPeriod/" + str(SchedulingPeriodDisplayPeriodID), verb = "delete")


def getEverySchedulingTeam(searchConditions = [], EntityID = 1, returnSchedulingTeamID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchedulingTeamIDClonedFrom = False, returnSchedulingTeamIDClonedTo = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SchedulingTeam in the district.

    This function returns a dataframe of every SchedulingTeam in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeam/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeam/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSchedulingTeam(SchedulingTeamID, EntityID = 1, returnSchedulingTeamID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchedulingTeamIDClonedFrom = False, returnSchedulingTeamIDClonedTo = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeam/" + str(SchedulingTeamID), verb = "get", return_params_list = return_params)

def modifySchedulingTeam(SchedulingTeamID, EntityID = 1, setSchedulingTeamID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setSchedulingTeamIDClonedFrom = None, setSchedulingTeamIDClonedTo = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingTeamID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchedulingTeamIDClonedFrom = False, returnSchedulingTeamIDClonedTo = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeam/" + str(SchedulingTeamID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSchedulingTeam(EntityID = 1, setSchedulingTeamID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEntityGroupKey = None, setEntityID = None, setModifiedTime = None, setSchedulingTeamIDClonedFrom = None, setSchedulingTeamIDClonedTo = None, setSchoolYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingTeamID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEntityGroupKey = False, returnEntityID = False, returnModifiedTime = False, returnSchedulingTeamIDClonedFrom = False, returnSchedulingTeamIDClonedTo = False, returnSchoolYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeam/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSchedulingTeam(SchedulingTeamID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeam/" + str(SchedulingTeamID), verb = "delete")


def getEverySchedulingTeamGradeReference(searchConditions = [], EntityID = 1, returnSchedulingTeamGradeReferenceID = False, returnCreatedTime = False, returnGradeReferenceID = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnSchedulingTeamGradeReferenceIDClonedFrom = False, returnSchedulingTeamID = False, returnStudentEntityYearsCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SchedulingTeamGradeReference in the district.

    This function returns a dataframe of every SchedulingTeamGradeReference in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeamGradeReference/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeamGradeReference/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSchedulingTeamGradeReference(SchedulingTeamGradeReferenceID, EntityID = 1, returnSchedulingTeamGradeReferenceID = False, returnCreatedTime = False, returnGradeReferenceID = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnSchedulingTeamGradeReferenceIDClonedFrom = False, returnSchedulingTeamID = False, returnStudentEntityYearsCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeamGradeReference/" + str(SchedulingTeamGradeReferenceID), verb = "get", return_params_list = return_params)

def modifySchedulingTeamGradeReference(SchedulingTeamGradeReferenceID, EntityID = 1, setSchedulingTeamGradeReferenceID = None, setCreatedTime = None, setGradeReferenceID = None, setMaximumStudentCount = None, setModifiedTime = None, setSchedulingTeamGradeReferenceIDClonedFrom = None, setSchedulingTeamID = None, setStudentEntityYearsCount = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingTeamGradeReferenceID = False, returnCreatedTime = False, returnGradeReferenceID = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnSchedulingTeamGradeReferenceIDClonedFrom = False, returnSchedulingTeamID = False, returnStudentEntityYearsCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeamGradeReference/" + str(SchedulingTeamGradeReferenceID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSchedulingTeamGradeReference(EntityID = 1, setSchedulingTeamGradeReferenceID = None, setCreatedTime = None, setGradeReferenceID = None, setMaximumStudentCount = None, setModifiedTime = None, setSchedulingTeamGradeReferenceIDClonedFrom = None, setSchedulingTeamID = None, setStudentEntityYearsCount = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSchedulingTeamGradeReferenceID = False, returnCreatedTime = False, returnGradeReferenceID = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnSchedulingTeamGradeReferenceIDClonedFrom = False, returnSchedulingTeamID = False, returnStudentEntityYearsCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeamGradeReference/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSchedulingTeamGradeReference(SchedulingTeamGradeReferenceID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SchedulingTeamGradeReference/" + str(SchedulingTeamGradeReferenceID), verb = "delete")


def getEverySectionCorequisiteGroup(searchConditions = [], EntityID = 1, returnSectionCorequisiteGroupID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnScheduleAllSectionsInGroupOrNone = False, returnSectionCorequisiteGroupIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionCorequisiteGroup in the district.

    This function returns a dataframe of every SectionCorequisiteGroup in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroup/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroup/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionCorequisiteGroup(SectionCorequisiteGroupID, EntityID = 1, returnSectionCorequisiteGroupID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnScheduleAllSectionsInGroupOrNone = False, returnSectionCorequisiteGroupIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroup/" + str(SectionCorequisiteGroupID), verb = "get", return_params_list = return_params)

def modifySectionCorequisiteGroup(SectionCorequisiteGroupID, EntityID = 1, setSectionCorequisiteGroupID = None, setAutomaticRequestSetting = None, setAutomaticRequestSettingCode = None, setAutomaticScheduleSetting = None, setAutomaticScheduleSettingCode = None, setCreatedTime = None, setDescription = None, setEntityID = None, setModifiedTime = None, setName = None, setNameDescription = None, setScheduleAllSectionsInGroupOrNone = None, setSectionCorequisiteGroupIDClonedTo = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionCorequisiteGroupID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnScheduleAllSectionsInGroupOrNone = False, returnSectionCorequisiteGroupIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroup/" + str(SectionCorequisiteGroupID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionCorequisiteGroup(EntityID = 1, setSectionCorequisiteGroupID = None, setAutomaticRequestSetting = None, setAutomaticRequestSettingCode = None, setAutomaticScheduleSetting = None, setAutomaticScheduleSettingCode = None, setCreatedTime = None, setDescription = None, setEntityID = None, setModifiedTime = None, setName = None, setNameDescription = None, setScheduleAllSectionsInGroupOrNone = None, setSectionCorequisiteGroupIDClonedTo = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionCorequisiteGroupID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCreatedTime = False, returnDescription = False, returnEntityID = False, returnModifiedTime = False, returnName = False, returnNameDescription = False, returnScheduleAllSectionsInGroupOrNone = False, returnSectionCorequisiteGroupIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroup/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionCorequisiteGroup(SectionCorequisiteGroupID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroup/" + str(SectionCorequisiteGroupID), verb = "delete")


def getEverySectionCorequisiteGroupSection(searchConditions = [], EntityID = 1, returnSectionCorequisiteGroupSectionID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionCorequisiteGroupID = False, returnSectionCorequisiteGroupSectionIDClonedFrom = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionCorequisiteGroupSection in the district.

    This function returns a dataframe of every SectionCorequisiteGroupSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroupSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroupSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionCorequisiteGroupSection(SectionCorequisiteGroupSectionID, EntityID = 1, returnSectionCorequisiteGroupSectionID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionCorequisiteGroupID = False, returnSectionCorequisiteGroupSectionIDClonedFrom = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroupSection/" + str(SectionCorequisiteGroupSectionID), verb = "get", return_params_list = return_params)

def modifySectionCorequisiteGroupSection(SectionCorequisiteGroupSectionID, EntityID = 1, setSectionCorequisiteGroupSectionID = None, setCreatedTime = None, setModifiedTime = None, setSectionCorequisiteGroupID = None, setSectionCorequisiteGroupSectionIDClonedFrom = None, setSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionCorequisiteGroupSectionID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionCorequisiteGroupID = False, returnSectionCorequisiteGroupSectionIDClonedFrom = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroupSection/" + str(SectionCorequisiteGroupSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionCorequisiteGroupSection(EntityID = 1, setSectionCorequisiteGroupSectionID = None, setCreatedTime = None, setModifiedTime = None, setSectionCorequisiteGroupID = None, setSectionCorequisiteGroupSectionIDClonedFrom = None, setSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionCorequisiteGroupSectionID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionCorequisiteGroupID = False, returnSectionCorequisiteGroupSectionIDClonedFrom = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroupSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionCorequisiteGroupSection(SectionCorequisiteGroupSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCorequisiteGroupSection/" + str(SectionCorequisiteGroupSectionID), verb = "delete")


def getEverySectionCustomRequirement(searchConditions = [], EntityID = 1, returnSectionCustomRequirementID = False, returnCreatedTime = False, returnCustomRequirementID = False, returnModifiedTime = False, returnSectionCustomRequirementIDClonedFrom = False, returnSectionCustomRequirementIDClonedTo = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionCustomRequirement in the district.

    This function returns a dataframe of every SectionCustomRequirement in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCustomRequirement/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCustomRequirement/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionCustomRequirement(SectionCustomRequirementID, EntityID = 1, returnSectionCustomRequirementID = False, returnCreatedTime = False, returnCustomRequirementID = False, returnModifiedTime = False, returnSectionCustomRequirementIDClonedFrom = False, returnSectionCustomRequirementIDClonedTo = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCustomRequirement/" + str(SectionCustomRequirementID), verb = "get", return_params_list = return_params)

def modifySectionCustomRequirement(SectionCustomRequirementID, EntityID = 1, setSectionCustomRequirementID = None, setCreatedTime = None, setCustomRequirementID = None, setModifiedTime = None, setSectionCustomRequirementIDClonedFrom = None, setSectionCustomRequirementIDClonedTo = None, setSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionCustomRequirementID = False, returnCreatedTime = False, returnCustomRequirementID = False, returnModifiedTime = False, returnSectionCustomRequirementIDClonedFrom = False, returnSectionCustomRequirementIDClonedTo = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCustomRequirement/" + str(SectionCustomRequirementID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionCustomRequirement(EntityID = 1, setSectionCustomRequirementID = None, setCreatedTime = None, setCustomRequirementID = None, setModifiedTime = None, setSectionCustomRequirementIDClonedFrom = None, setSectionCustomRequirementIDClonedTo = None, setSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionCustomRequirementID = False, returnCreatedTime = False, returnCustomRequirementID = False, returnModifiedTime = False, returnSectionCustomRequirementIDClonedFrom = False, returnSectionCustomRequirementIDClonedTo = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCustomRequirement/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionCustomRequirement(SectionCustomRequirementID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionCustomRequirement/" + str(SectionCustomRequirementID), verb = "delete")


def getEverySectionDefault(searchConditions = [], EntityID = 1, returnSectionDefaultID = False, returnCourseID = False, returnCreatedTime = False, returnMaximumStudentCount = False, returnMinimumStudentCount = False, returnModifiedTime = False, returnOptimalStudentCount = False, returnSectionDefaultIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionDefault in the district.

    This function returns a dataframe of every SectionDefault in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionDefault/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionDefault/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionDefault(SectionDefaultID, EntityID = 1, returnSectionDefaultID = False, returnCourseID = False, returnCreatedTime = False, returnMaximumStudentCount = False, returnMinimumStudentCount = False, returnModifiedTime = False, returnOptimalStudentCount = False, returnSectionDefaultIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionDefault/" + str(SectionDefaultID), verb = "get", return_params_list = return_params)

def modifySectionDefault(SectionDefaultID, EntityID = 1, setSectionDefaultID = None, setCourseID = None, setCreatedTime = None, setMaximumStudentCount = None, setMinimumStudentCount = None, setModifiedTime = None, setOptimalStudentCount = None, setSectionDefaultIDClonedFrom = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionDefaultID = False, returnCourseID = False, returnCreatedTime = False, returnMaximumStudentCount = False, returnMinimumStudentCount = False, returnModifiedTime = False, returnOptimalStudentCount = False, returnSectionDefaultIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionDefault/" + str(SectionDefaultID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionDefault(EntityID = 1, setSectionDefaultID = None, setCourseID = None, setCreatedTime = None, setMaximumStudentCount = None, setMinimumStudentCount = None, setModifiedTime = None, setOptimalStudentCount = None, setSectionDefaultIDClonedFrom = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionDefaultID = False, returnCourseID = False, returnCreatedTime = False, returnMaximumStudentCount = False, returnMinimumStudentCount = False, returnModifiedTime = False, returnOptimalStudentCount = False, returnSectionDefaultIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionDefault/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionDefault(SectionDefaultID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionDefault/" + str(SectionDefaultID), verb = "delete")


def getEverySectionEnrollmentTotalForSectionLengthSubset(searchConditions = [], EntityID = 1, returnSectionID = False, returnSectionLengthSubsetID = False, returnTotalEnrollmentCount = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionEnrollmentTotalForSectionLengthSubset in the district.

    This function returns a dataframe of every SectionEnrollmentTotalForSectionLengthSubset in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionEnrollmentTotalForSectionLengthSubset(SectionID, EntityID = 1, returnSectionID = False, returnSectionLengthSubsetID = False, returnTotalEnrollmentCount = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubset/" + str(SectionID), verb = "get", return_params_list = return_params)

def modifySectionEnrollmentTotalForSectionLengthSubset(SectionID, EntityID = 1, setSectionID = None, setSectionLengthSubsetID = None, setTotalEnrollmentCount = None, returnSectionID = False, returnSectionLengthSubsetID = False, returnTotalEnrollmentCount = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubset/" + str(SectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionEnrollmentTotalForSectionLengthSubset(EntityID = 1, setSectionID = None, setSectionLengthSubsetID = None, setTotalEnrollmentCount = None, returnSectionID = False, returnSectionLengthSubsetID = False, returnTotalEnrollmentCount = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubset/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionEnrollmentTotalForSectionLengthSubset(SectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubset/" + str(SectionID), verb = "delete")


def getEverySectionEnrollmentTotalForSectionLengthSubsetAndEntity(searchConditions = [], EntityID = 1, returnSectionID = False, returnEntityIDCountsAs = False, returnSectionLengthSubsetID = False, returnTotalEnrollmentCount = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionEnrollmentTotalForSectionLengthSubsetAndEntity in the district.

    This function returns a dataframe of every SectionEnrollmentTotalForSectionLengthSubsetAndEntity in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubsetAndEntity/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubsetAndEntity/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionEnrollmentTotalForSectionLengthSubsetAndEntity(SectionID, EntityID = 1, returnSectionID = False, returnEntityIDCountsAs = False, returnSectionLengthSubsetID = False, returnTotalEnrollmentCount = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubsetAndEntity/" + str(SectionID), verb = "get", return_params_list = return_params)

def modifySectionEnrollmentTotalForSectionLengthSubsetAndEntity(SectionID, EntityID = 1, setSectionID = None, setEntityIDCountsAs = None, setSectionLengthSubsetID = None, setTotalEnrollmentCount = None, returnSectionID = False, returnEntityIDCountsAs = False, returnSectionLengthSubsetID = False, returnTotalEnrollmentCount = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubsetAndEntity/" + str(SectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionEnrollmentTotalForSectionLengthSubsetAndEntity(EntityID = 1, setSectionID = None, setEntityIDCountsAs = None, setSectionLengthSubsetID = None, setTotalEnrollmentCount = None, returnSectionID = False, returnEntityIDCountsAs = False, returnSectionLengthSubsetID = False, returnTotalEnrollmentCount = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubsetAndEntity/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionEnrollmentTotalForSectionLengthSubsetAndEntity(SectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionEnrollmentTotalForSectionLengthSubsetAndEntity/" + str(SectionID), verb = "delete")


def getEverySectionLength(searchConditions = [], EntityID = 1, returnSectionLengthID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEdFiTermTypeID = False, returnEndDate = False, returnEntityGroupKey = False, returnIlluminateTermType = False, returnIsSectionCurrent = False, returnMCCCDropDate = False, returnModifiedTime = False, returnSectionLengthIDClonedFrom = False, returnSectionLengthIDClonedTo = False, returnSectionLengthMNID = False, returnSectionRange = False, returnStartDate = False, returnThirdPartyTermNumber = False, returnThirdPartyTermTypeCalculated = False, returnThirdPartyTermTypeOverride = False, returnThirdPartyTermTypeOverrideCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionLength in the district.

    This function returns a dataframe of every SectionLength in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLength/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLength/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionLength(SectionLengthID, EntityID = 1, returnSectionLengthID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEdFiTermTypeID = False, returnEndDate = False, returnEntityGroupKey = False, returnIlluminateTermType = False, returnIsSectionCurrent = False, returnMCCCDropDate = False, returnModifiedTime = False, returnSectionLengthIDClonedFrom = False, returnSectionLengthIDClonedTo = False, returnSectionLengthMNID = False, returnSectionRange = False, returnStartDate = False, returnThirdPartyTermNumber = False, returnThirdPartyTermTypeCalculated = False, returnThirdPartyTermTypeOverride = False, returnThirdPartyTermTypeOverrideCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLength/" + str(SectionLengthID), verb = "get", return_params_list = return_params)

def modifySectionLength(SectionLengthID, EntityID = 1, setSectionLengthID = None, setCode = None, setCodeDescription = None, setCourseLengthID = None, setCreatedTime = None, setDescription = None, setEdFiTermTypeID = None, setEndDate = None, setEntityGroupKey = None, setIlluminateTermType = None, setIsSectionCurrent = None, setMCCCDropDate = None, setModifiedTime = None, setSectionLengthIDClonedFrom = None, setSectionLengthIDClonedTo = None, setSectionLengthMNID = None, setSectionRange = None, setStartDate = None, setThirdPartyTermNumber = None, setThirdPartyTermTypeCalculated = None, setThirdPartyTermTypeOverride = None, setThirdPartyTermTypeOverrideCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionLengthID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEdFiTermTypeID = False, returnEndDate = False, returnEntityGroupKey = False, returnIlluminateTermType = False, returnIsSectionCurrent = False, returnMCCCDropDate = False, returnModifiedTime = False, returnSectionLengthIDClonedFrom = False, returnSectionLengthIDClonedTo = False, returnSectionLengthMNID = False, returnSectionRange = False, returnStartDate = False, returnThirdPartyTermNumber = False, returnThirdPartyTermTypeCalculated = False, returnThirdPartyTermTypeOverride = False, returnThirdPartyTermTypeOverrideCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLength/" + str(SectionLengthID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionLength(EntityID = 1, setSectionLengthID = None, setCode = None, setCodeDescription = None, setCourseLengthID = None, setCreatedTime = None, setDescription = None, setEdFiTermTypeID = None, setEndDate = None, setEntityGroupKey = None, setIlluminateTermType = None, setIsSectionCurrent = None, setMCCCDropDate = None, setModifiedTime = None, setSectionLengthIDClonedFrom = None, setSectionLengthIDClonedTo = None, setSectionLengthMNID = None, setSectionRange = None, setStartDate = None, setThirdPartyTermNumber = None, setThirdPartyTermTypeCalculated = None, setThirdPartyTermTypeOverride = None, setThirdPartyTermTypeOverrideCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionLengthID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEdFiTermTypeID = False, returnEndDate = False, returnEntityGroupKey = False, returnIlluminateTermType = False, returnIsSectionCurrent = False, returnMCCCDropDate = False, returnModifiedTime = False, returnSectionLengthIDClonedFrom = False, returnSectionLengthIDClonedTo = False, returnSectionLengthMNID = False, returnSectionRange = False, returnStartDate = False, returnThirdPartyTermNumber = False, returnThirdPartyTermTypeCalculated = False, returnThirdPartyTermTypeOverride = False, returnThirdPartyTermTypeOverrideCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLength/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionLength(SectionLengthID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLength/" + str(SectionLengthID), verb = "delete")


def getEverySectionLengthSubset(searchConditions = [], EntityID = 1, returnSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEdFiTermTypeID = False, returnEndDate = False, returnEntityGroupKey = False, returnGradeBucketIDCarlPerkins = False, returnIsFullSectionLength = False, returnMCCCDropDate = False, returnMCCCTermImportID = False, returnModifiedTime = False, returnSectionLengthID = False, returnSectionLengthSubsetIDClonedFrom = False, returnSectionLengthSubsetIDClonedTo = False, returnSectionLengthSubsetMNID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionLengthSubset in the district.

    This function returns a dataframe of every SectionLengthSubset in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionLengthSubset(SectionLengthSubsetID, EntityID = 1, returnSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEdFiTermTypeID = False, returnEndDate = False, returnEntityGroupKey = False, returnGradeBucketIDCarlPerkins = False, returnIsFullSectionLength = False, returnMCCCDropDate = False, returnMCCCTermImportID = False, returnModifiedTime = False, returnSectionLengthID = False, returnSectionLengthSubsetIDClonedFrom = False, returnSectionLengthSubsetIDClonedTo = False, returnSectionLengthSubsetMNID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLengthSubset/" + str(SectionLengthSubsetID), verb = "get", return_params_list = return_params)

def modifySectionLengthSubset(SectionLengthSubsetID, EntityID = 1, setSectionLengthSubsetID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEdFiTermTypeID = None, setEndDate = None, setEntityGroupKey = None, setGradeBucketIDCarlPerkins = None, setIsFullSectionLength = None, setMCCCDropDate = None, setMCCCTermImportID = None, setModifiedTime = None, setSectionLengthID = None, setSectionLengthSubsetIDClonedFrom = None, setSectionLengthSubsetIDClonedTo = None, setSectionLengthSubsetMNID = None, setStartDate = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEdFiTermTypeID = False, returnEndDate = False, returnEntityGroupKey = False, returnGradeBucketIDCarlPerkins = False, returnIsFullSectionLength = False, returnMCCCDropDate = False, returnMCCCTermImportID = False, returnModifiedTime = False, returnSectionLengthID = False, returnSectionLengthSubsetIDClonedFrom = False, returnSectionLengthSubsetIDClonedTo = False, returnSectionLengthSubsetMNID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLengthSubset/" + str(SectionLengthSubsetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionLengthSubset(EntityID = 1, setSectionLengthSubsetID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDescription = None, setEdFiTermTypeID = None, setEndDate = None, setEntityGroupKey = None, setGradeBucketIDCarlPerkins = None, setIsFullSectionLength = None, setMCCCDropDate = None, setMCCCTermImportID = None, setModifiedTime = None, setSectionLengthID = None, setSectionLengthSubsetIDClonedFrom = None, setSectionLengthSubsetIDClonedTo = None, setSectionLengthSubsetMNID = None, setStartDate = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDescription = False, returnEdFiTermTypeID = False, returnEndDate = False, returnEntityGroupKey = False, returnGradeBucketIDCarlPerkins = False, returnIsFullSectionLength = False, returnMCCCDropDate = False, returnMCCCTermImportID = False, returnModifiedTime = False, returnSectionLengthID = False, returnSectionLengthSubsetIDClonedFrom = False, returnSectionLengthSubsetIDClonedTo = False, returnSectionLengthSubsetMNID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLengthSubset/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionLengthSubset(SectionLengthSubsetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionLengthSubset/" + str(SectionLengthSubsetID), verb = "delete")


def getEverySectionMeetSummary(searchConditions = [], EntityID = 1, returnSectionMeetSummaryID = False, returnCalendarID = False, returnCreatedTime = False, returnEntityIDViewing = False, returnIsDefaultCalendar = False, returnModifiedTime = False, returnPeriodDaySummary = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionMeetSummary in the district.

    This function returns a dataframe of every SectionMeetSummary in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionMeetSummary/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionMeetSummary/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionMeetSummary(SectionMeetSummaryID, EntityID = 1, returnSectionMeetSummaryID = False, returnCalendarID = False, returnCreatedTime = False, returnEntityIDViewing = False, returnIsDefaultCalendar = False, returnModifiedTime = False, returnPeriodDaySummary = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionMeetSummary/" + str(SectionMeetSummaryID), verb = "get", return_params_list = return_params)

def modifySectionMeetSummary(SectionMeetSummaryID, EntityID = 1, setSectionMeetSummaryID = None, setCalendarID = None, setCreatedTime = None, setEntityIDViewing = None, setIsDefaultCalendar = None, setModifiedTime = None, setPeriodDaySummary = None, setSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionMeetSummaryID = False, returnCalendarID = False, returnCreatedTime = False, returnEntityIDViewing = False, returnIsDefaultCalendar = False, returnModifiedTime = False, returnPeriodDaySummary = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionMeetSummary/" + str(SectionMeetSummaryID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionMeetSummary(EntityID = 1, setSectionMeetSummaryID = None, setCalendarID = None, setCreatedTime = None, setEntityIDViewing = None, setIsDefaultCalendar = None, setModifiedTime = None, setPeriodDaySummary = None, setSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionMeetSummaryID = False, returnCalendarID = False, returnCreatedTime = False, returnEntityIDViewing = False, returnIsDefaultCalendar = False, returnModifiedTime = False, returnPeriodDaySummary = False, returnSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionMeetSummary/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionMeetSummary(SectionMeetSummaryID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionMeetSummary/" + str(SectionMeetSummaryID), verb = "delete")


def getEverySection(searchConditions = [], EntityID = 1, returnSectionID = False, returnAllowCECE = False, returnAllowStudentsWithoutCategoryToBeAssigned = False, returnAssignmentCount = False, returnAssignmentCountForTermCalculated = False, returnAssignmentCountYTDCalculated = False, returnAssignmentDataString = False, returnAssignmentsHaveBeenCreated = False, returnBellScheduleGroupID = False, returnCalculatedBellScheduleGroupID = False, returnCalculatedStudentEnrollmentCount = False, returnCalculatedStudentEnrollmentCountEntity = False, returnCalculatedStudentEnrollmentCountEntityFirstDay = False, returnCalculatedStudentEnrollmentCountEntitySpecifiedDate = False, returnCalculatedStudentEnrollmentCountEntityToday = False, returnCalculatedStudentEnrollmentCountFirstDay = False, returnCalculatedStudentEnrollmentCountSpecifiedDate = False, returnCalculatedStudentEnrollmentCountToday = False, returnCalendarIDMCCCOverride = False, returnCanAddStudentSection = False, returnCanBeOffered = False, returnCode = False, returnCourseCodeSectionCode = False, returnCourseCodeSectionCodeCourseDescription = False, returnCourseDescriptionCodeSectionCode = False, returnCourseID = False, returnCourseIDHash = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnCurrentEnrollmentEntity = False, returnCurrentEnrollmentEntityForFilter = False, returnCurrentEnrollmentForFilter = False, returnCurrentGradingPeriod = False, returnCurrentlyRecalculating = False, returnDisplayForTeachers = False, returnDisplayPeriodIDCurrentStoredPrimary = False, returnDueDateOfLastAssignmentScored = False, returnEdFiEducationalEnvironmentID = False, returnEffectiveTeacherFirstLastName = False, returnEffectiveTeacherLastFirstName = False, returnEntityCodeTeacherNumber = False, returnEntityID = False, returnExcludeFromStudentSectionLink = False, returnExcusedAbsencesForTerm = False, returnExcusedAbsencesYTD = False, returnFit = False, returnFutureAssignmentCountForTermCalculated = False, returnGradebookCanHaveSettingsCopiedFromPreviousYear = False, returnGradedAssignmentCountForTermCalculated = False, returnHasAssignments = False, returnHasAssignmentsWithAcademicStandards = False, returnHasAssignmentsWithStudentGroups = False, returnHasAssignmentsWithSubjects = False, returnHasCalculationGroupCourse = False, returnHasCategoriesInDistrict = False, returnHasClosedOrCompletedSectionGradingScaleGroup = False, returnHasCompleted = False, returnHasCompletedForFilter = False, returnHasGradeMarksInEntity = False, returnHasGradingPeriodGradeBuckets = False, returnHasGradingScales = False, returnHasIncompleteClosedGradeChangeRequests = False, returnHasNonDeletedAssignments = False, returnHasNotStarted = False, returnHasNotStartedForFilter = False, returnHasPreviousYearSettings = False, returnHasStandardsCheckSectionLengthGradingPeriodSet = False, returnHasStudentSections = False, returnHasSubjectsCheckSectionLengthGradingPeriodSet = False, returnHasValidGradebookSetup = False, returnHasValidStandardsSetup = False, returnHasValidSubjectsSetup = False, returnHomeroomID = False, returnInPastYear = False, returnIsActive = False, returnIsActiveOverride = False, returnIsAdministeredForTSA = False, returnIsAHistoricRecord = False, returnIsBilingual = False, returnIsCreditRecovery = False, returnIsInProgress = False, returnIsInProgressForFilter = False, returnIsOffered = False, returnIsOfferedToAnotherEntity = False, returnIsSelfPaced = False, returnIsSelfPacedAndActive = False, returnIsTSAProficient = False, returnLanguageID = False, returnLockSectionFromSectionScheduler = False, returnLockSectionLengthFromSectionScheduler = False, returnMaximumStudentCount = False, returnMaximumStudentCountEntity = False, returnMaximumStudentCountEntityForFilter = False, returnMaximumStudentCountForEntityOfCourse = False, returnMaximumStudentCountForViewingEntity = False, returnMaximumStudentCountOffered = False, returnMaximumStudentCountOfferedForFilter = False, returnMaximumStudentCountOfferedToSpecifiedEntity = False, returnMeetIDCurrentStoredPrimary = False, returnMeetSummaryIDCurrentStoredPrimary = False, returnMinimumStudentCount = False, returnMissingAssignmentCount = False, returnMissingAssignmentCountForTermCalculated = False, returnModifiedTime = False, returnNoCountAssignmentCountForTermCalculated = False, returnNonGradedAssignmentCountForTerm = False, returnNonGradedAssignmentCountNoStudentAssignmentsForTerm = False, returnNonTransferCourseEnrollmentCountFemales = False, returnNonTransferCourseEnrollmentCountFemalesEntity = False, returnNonTransferCourseEnrollmentCountFemalesEntityFirstDay = False, returnNonTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = False, returnNonTransferCourseEnrollmentCountFemalesEntityToday = False, returnNonTransferCourseEnrollmentCountFemalesFirstDay = False, returnNonTransferCourseEnrollmentCountFemalesSpecifiedDate = False, returnNonTransferCourseEnrollmentCountFemalesToday = False, returnNonTransferCourseEnrollmentCountMales = False, returnNonTransferCourseEnrollmentCountMalesEntity = False, returnNonTransferCourseEnrollmentCountMalesEntityFirstDay = False, returnNonTransferCourseEnrollmentCountMalesEntitySpecifiedDate = False, returnNonTransferCourseEnrollmentCountMalesEntityToday = False, returnNonTransferCourseEnrollmentCountMalesFirstDay = False, returnNonTransferCourseEnrollmentCountMalesSpecifiedDate = False, returnNonTransferCourseEnrollmentCountMalesToday = False, returnNonTransferCourseStudentEnrollmentCount = False, returnNonTransferCourseStudentEnrollmentCountEntity = False, returnNonTransferCourseStudentEnrollmentCountEntityFirstDay = False, returnNonTransferCourseStudentEnrollmentCountEntitySpecifiedDate = False, returnNonTransferCourseStudentEnrollmentCountEntityToday = False, returnNonTransferCourseStudentEnrollmentCountFirstDay = False, returnNonTransferCourseStudentEnrollmentCountSpecifiedDate = False, returnNonTransferCourseStudentEnrollmentCountToday = False, returnNumberOfTransferStudentSections = False, returnNumberOfTransferStudentSectionsForFilter = False, returnOffenseCount = False, returnOffenseCountYTD = False, returnOptimalStudentCount = False, returnOtherAbsencesForTerm = False, returnOtherAbsencesYTD = False, returnPeriodDaySummary = False, returnPreviousVersionOfFit = False, returnProgressStatusSpecifiedDate = False, returnProgressStatusToday = False, returnRecalculateGradebook = False, returnRecalculateGradebookAdmin = False, returnReservedSeatCount = False, returnRoomSeatsAvailable = False, returnSchedulingCategories = False, returnSchedulingTeams = False, returnSchoolYearID = False, returnScoreClarifierAssignmentCountForTermCalculated = False, returnScoredAssignmentCount = False, returnScoredAssignmentRange0CurrentTerm = False, returnScoredAssignmentRange100to90CurrentTerm = False, returnScoredAssignmentRange49to1CurrentTerm = False, returnScoredAssignmentRange59to50CurrentTerm = False, returnScoredAssignmentRange69to60CurrentTerm = False, returnScoredAssignmentRange79to70CurrentTerm = False, returnScoredAssignmentRange89to80CurrentTerm = False, returnSeatsAvailable = False, returnSeatsAvailableEntity = False, returnSeatsAvailableEntityForFilter = False, returnSeatsAvailableForFilter = False, returnSectionEnrollmentTotalsForSectionLengthSubsetSummary = False, returnSectionEnrollmentTotalsForSectionLengthSubsetSummaryForEntity = False, returnSectionIDClonedFrom = False, returnSectionIDClonedTo = False, returnSectionIDHash = False, returnSectionLengthID = False, returnSectionLengthScheduledBySectionScheduler = False, returnSectionMNID = False, returnSelfPacedEndTime = False, returnSelfPacedEndTimeDate = False, returnSelfPacedEndTimeTime = False, returnSingleSex = False, returnSingleSexCode = False, returnSpecialEdPercentageLimit = False, returnSpecifiedPeriodDaySummary = False, returnStaffIDCurrentStoredPrimary = False, returnStaffMeetIDCurrentStoredPrimary = False, returnStateInstructionalMethodCodeMNID = False, returnStateSTARModeOfTeachingMNID = False, returnStudentAssignmentDataString = False, returnStudentCountForTerm = False, returnStudentEnrollment = False, returnStudentEnrollmentAsOfSpecifiedDate = False, returnStudentEnrollmentAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentEntity = False, returnStudentEnrollmentEntityForFilter = False, returnStudentEnrollmentFemales = False, returnStudentEnrollmentFemalesAsOfSpecifiedDate = False, returnStudentEnrollmentFemalesAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentFemalesEntity = False, returnStudentEnrollmentFemalesEntityForFilter = False, returnStudentEnrollmentFemalesForFilter = False, returnStudentEnrollmentForFilter = False, returnStudentEnrollmentMales = False, returnStudentEnrollmentMalesAsOfSpecifiedDate = False, returnStudentEnrollmentMalesAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentMalesEntity = False, returnStudentEnrollmentMalesEntityForFilter = False, returnStudentEnrollmentMalesForFilter = False, returnStudentSectionSectionIDHash = False, returnTardiesForTerm = False, returnTardiesYTD = False, returnThisPeriodDaySummary = False, returnTotalEnrollmentCount = False, returnTotalEnrollmentCountEntity = False, returnTotalEnrollmentCountEntityForFilter = False, returnTotalEnrollmentCountForFilter = False, returnTotalMeetCount = False, returnTotalSeatsOfferedToOtherEntities = False, returnTransferCourseEnrollmentCountFemales = False, returnTransferCourseEnrollmentCountFemalesEntity = False, returnTransferCourseEnrollmentCountFemalesEntityFirstDay = False, returnTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = False, returnTransferCourseEnrollmentCountFemalesEntityToday = False, returnTransferCourseEnrollmentCountFemalesFirstDay = False, returnTransferCourseEnrollmentCountFemalesSpecifiedDate = False, returnTransferCourseEnrollmentCountFemalesToday = False, returnTransferCourseEnrollmentCountMales = False, returnTransferCourseEnrollmentCountMalesEntity = False, returnTransferCourseEnrollmentCountMalesEntityFirstDay = False, returnTransferCourseEnrollmentCountMalesEntitySpecifiedDate = False, returnTransferCourseEnrollmentCountMalesEntityToday = False, returnTransferCourseEnrollmentCountMalesFirstDay = False, returnTransferCourseEnrollmentCountMalesSpecifiedDate = False, returnTransferCourseEnrollmentCountMalesToday = False, returnTransferCourseStudentEnrollmentCount = False, returnTransferCourseStudentEnrollmentCountEntity = False, returnTransferCourseStudentEnrollmentCountEntityFirstDay = False, returnTransferCourseStudentEnrollmentCountEntitySpecifiedDate = False, returnTransferCourseStudentEnrollmentCountEntityToday = False, returnTransferCourseStudentEnrollmentCountFirstDay = False, returnTransferCourseStudentEnrollmentCountSpecifiedDate = False, returnTransferCourseStudentEnrollmentCountToday = False, returnUnexcusedAbsencesForTerm = False, returnUnexcusedAbsencesYTD = False, returnUnscoredAssignmentCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUsingCurriculumSubjectsInGradebook = False, returnViewingFromOfferingEntity = False, returnWebsite = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every Section in the district.

    This function returns a dataframe of every Section in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Section/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Section/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSection(SectionID, EntityID = 1, returnSectionID = False, returnAllowCECE = False, returnAllowStudentsWithoutCategoryToBeAssigned = False, returnAssignmentCount = False, returnAssignmentCountForTermCalculated = False, returnAssignmentCountYTDCalculated = False, returnAssignmentDataString = False, returnAssignmentsHaveBeenCreated = False, returnBellScheduleGroupID = False, returnCalculatedBellScheduleGroupID = False, returnCalculatedStudentEnrollmentCount = False, returnCalculatedStudentEnrollmentCountEntity = False, returnCalculatedStudentEnrollmentCountEntityFirstDay = False, returnCalculatedStudentEnrollmentCountEntitySpecifiedDate = False, returnCalculatedStudentEnrollmentCountEntityToday = False, returnCalculatedStudentEnrollmentCountFirstDay = False, returnCalculatedStudentEnrollmentCountSpecifiedDate = False, returnCalculatedStudentEnrollmentCountToday = False, returnCalendarIDMCCCOverride = False, returnCanAddStudentSection = False, returnCanBeOffered = False, returnCode = False, returnCourseCodeSectionCode = False, returnCourseCodeSectionCodeCourseDescription = False, returnCourseDescriptionCodeSectionCode = False, returnCourseID = False, returnCourseIDHash = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnCurrentEnrollmentEntity = False, returnCurrentEnrollmentEntityForFilter = False, returnCurrentEnrollmentForFilter = False, returnCurrentGradingPeriod = False, returnCurrentlyRecalculating = False, returnDisplayForTeachers = False, returnDisplayPeriodIDCurrentStoredPrimary = False, returnDueDateOfLastAssignmentScored = False, returnEdFiEducationalEnvironmentID = False, returnEffectiveTeacherFirstLastName = False, returnEffectiveTeacherLastFirstName = False, returnEntityCodeTeacherNumber = False, returnEntityID = False, returnExcludeFromStudentSectionLink = False, returnExcusedAbsencesForTerm = False, returnExcusedAbsencesYTD = False, returnFit = False, returnFutureAssignmentCountForTermCalculated = False, returnGradebookCanHaveSettingsCopiedFromPreviousYear = False, returnGradedAssignmentCountForTermCalculated = False, returnHasAssignments = False, returnHasAssignmentsWithAcademicStandards = False, returnHasAssignmentsWithStudentGroups = False, returnHasAssignmentsWithSubjects = False, returnHasCalculationGroupCourse = False, returnHasCategoriesInDistrict = False, returnHasClosedOrCompletedSectionGradingScaleGroup = False, returnHasCompleted = False, returnHasCompletedForFilter = False, returnHasGradeMarksInEntity = False, returnHasGradingPeriodGradeBuckets = False, returnHasGradingScales = False, returnHasIncompleteClosedGradeChangeRequests = False, returnHasNonDeletedAssignments = False, returnHasNotStarted = False, returnHasNotStartedForFilter = False, returnHasPreviousYearSettings = False, returnHasStandardsCheckSectionLengthGradingPeriodSet = False, returnHasStudentSections = False, returnHasSubjectsCheckSectionLengthGradingPeriodSet = False, returnHasValidGradebookSetup = False, returnHasValidStandardsSetup = False, returnHasValidSubjectsSetup = False, returnHomeroomID = False, returnInPastYear = False, returnIsActive = False, returnIsActiveOverride = False, returnIsAdministeredForTSA = False, returnIsAHistoricRecord = False, returnIsBilingual = False, returnIsCreditRecovery = False, returnIsInProgress = False, returnIsInProgressForFilter = False, returnIsOffered = False, returnIsOfferedToAnotherEntity = False, returnIsSelfPaced = False, returnIsSelfPacedAndActive = False, returnIsTSAProficient = False, returnLanguageID = False, returnLockSectionFromSectionScheduler = False, returnLockSectionLengthFromSectionScheduler = False, returnMaximumStudentCount = False, returnMaximumStudentCountEntity = False, returnMaximumStudentCountEntityForFilter = False, returnMaximumStudentCountForEntityOfCourse = False, returnMaximumStudentCountForViewingEntity = False, returnMaximumStudentCountOffered = False, returnMaximumStudentCountOfferedForFilter = False, returnMaximumStudentCountOfferedToSpecifiedEntity = False, returnMeetIDCurrentStoredPrimary = False, returnMeetSummaryIDCurrentStoredPrimary = False, returnMinimumStudentCount = False, returnMissingAssignmentCount = False, returnMissingAssignmentCountForTermCalculated = False, returnModifiedTime = False, returnNoCountAssignmentCountForTermCalculated = False, returnNonGradedAssignmentCountForTerm = False, returnNonGradedAssignmentCountNoStudentAssignmentsForTerm = False, returnNonTransferCourseEnrollmentCountFemales = False, returnNonTransferCourseEnrollmentCountFemalesEntity = False, returnNonTransferCourseEnrollmentCountFemalesEntityFirstDay = False, returnNonTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = False, returnNonTransferCourseEnrollmentCountFemalesEntityToday = False, returnNonTransferCourseEnrollmentCountFemalesFirstDay = False, returnNonTransferCourseEnrollmentCountFemalesSpecifiedDate = False, returnNonTransferCourseEnrollmentCountFemalesToday = False, returnNonTransferCourseEnrollmentCountMales = False, returnNonTransferCourseEnrollmentCountMalesEntity = False, returnNonTransferCourseEnrollmentCountMalesEntityFirstDay = False, returnNonTransferCourseEnrollmentCountMalesEntitySpecifiedDate = False, returnNonTransferCourseEnrollmentCountMalesEntityToday = False, returnNonTransferCourseEnrollmentCountMalesFirstDay = False, returnNonTransferCourseEnrollmentCountMalesSpecifiedDate = False, returnNonTransferCourseEnrollmentCountMalesToday = False, returnNonTransferCourseStudentEnrollmentCount = False, returnNonTransferCourseStudentEnrollmentCountEntity = False, returnNonTransferCourseStudentEnrollmentCountEntityFirstDay = False, returnNonTransferCourseStudentEnrollmentCountEntitySpecifiedDate = False, returnNonTransferCourseStudentEnrollmentCountEntityToday = False, returnNonTransferCourseStudentEnrollmentCountFirstDay = False, returnNonTransferCourseStudentEnrollmentCountSpecifiedDate = False, returnNonTransferCourseStudentEnrollmentCountToday = False, returnNumberOfTransferStudentSections = False, returnNumberOfTransferStudentSectionsForFilter = False, returnOffenseCount = False, returnOffenseCountYTD = False, returnOptimalStudentCount = False, returnOtherAbsencesForTerm = False, returnOtherAbsencesYTD = False, returnPeriodDaySummary = False, returnPreviousVersionOfFit = False, returnProgressStatusSpecifiedDate = False, returnProgressStatusToday = False, returnRecalculateGradebook = False, returnRecalculateGradebookAdmin = False, returnReservedSeatCount = False, returnRoomSeatsAvailable = False, returnSchedulingCategories = False, returnSchedulingTeams = False, returnSchoolYearID = False, returnScoreClarifierAssignmentCountForTermCalculated = False, returnScoredAssignmentCount = False, returnScoredAssignmentRange0CurrentTerm = False, returnScoredAssignmentRange100to90CurrentTerm = False, returnScoredAssignmentRange49to1CurrentTerm = False, returnScoredAssignmentRange59to50CurrentTerm = False, returnScoredAssignmentRange69to60CurrentTerm = False, returnScoredAssignmentRange79to70CurrentTerm = False, returnScoredAssignmentRange89to80CurrentTerm = False, returnSeatsAvailable = False, returnSeatsAvailableEntity = False, returnSeatsAvailableEntityForFilter = False, returnSeatsAvailableForFilter = False, returnSectionEnrollmentTotalsForSectionLengthSubsetSummary = False, returnSectionEnrollmentTotalsForSectionLengthSubsetSummaryForEntity = False, returnSectionIDClonedFrom = False, returnSectionIDClonedTo = False, returnSectionIDHash = False, returnSectionLengthID = False, returnSectionLengthScheduledBySectionScheduler = False, returnSectionMNID = False, returnSelfPacedEndTime = False, returnSelfPacedEndTimeDate = False, returnSelfPacedEndTimeTime = False, returnSingleSex = False, returnSingleSexCode = False, returnSpecialEdPercentageLimit = False, returnSpecifiedPeriodDaySummary = False, returnStaffIDCurrentStoredPrimary = False, returnStaffMeetIDCurrentStoredPrimary = False, returnStateInstructionalMethodCodeMNID = False, returnStateSTARModeOfTeachingMNID = False, returnStudentAssignmentDataString = False, returnStudentCountForTerm = False, returnStudentEnrollment = False, returnStudentEnrollmentAsOfSpecifiedDate = False, returnStudentEnrollmentAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentEntity = False, returnStudentEnrollmentEntityForFilter = False, returnStudentEnrollmentFemales = False, returnStudentEnrollmentFemalesAsOfSpecifiedDate = False, returnStudentEnrollmentFemalesAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentFemalesEntity = False, returnStudentEnrollmentFemalesEntityForFilter = False, returnStudentEnrollmentFemalesForFilter = False, returnStudentEnrollmentForFilter = False, returnStudentEnrollmentMales = False, returnStudentEnrollmentMalesAsOfSpecifiedDate = False, returnStudentEnrollmentMalesAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentMalesEntity = False, returnStudentEnrollmentMalesEntityForFilter = False, returnStudentEnrollmentMalesForFilter = False, returnStudentSectionSectionIDHash = False, returnTardiesForTerm = False, returnTardiesYTD = False, returnThisPeriodDaySummary = False, returnTotalEnrollmentCount = False, returnTotalEnrollmentCountEntity = False, returnTotalEnrollmentCountEntityForFilter = False, returnTotalEnrollmentCountForFilter = False, returnTotalMeetCount = False, returnTotalSeatsOfferedToOtherEntities = False, returnTransferCourseEnrollmentCountFemales = False, returnTransferCourseEnrollmentCountFemalesEntity = False, returnTransferCourseEnrollmentCountFemalesEntityFirstDay = False, returnTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = False, returnTransferCourseEnrollmentCountFemalesEntityToday = False, returnTransferCourseEnrollmentCountFemalesFirstDay = False, returnTransferCourseEnrollmentCountFemalesSpecifiedDate = False, returnTransferCourseEnrollmentCountFemalesToday = False, returnTransferCourseEnrollmentCountMales = False, returnTransferCourseEnrollmentCountMalesEntity = False, returnTransferCourseEnrollmentCountMalesEntityFirstDay = False, returnTransferCourseEnrollmentCountMalesEntitySpecifiedDate = False, returnTransferCourseEnrollmentCountMalesEntityToday = False, returnTransferCourseEnrollmentCountMalesFirstDay = False, returnTransferCourseEnrollmentCountMalesSpecifiedDate = False, returnTransferCourseEnrollmentCountMalesToday = False, returnTransferCourseStudentEnrollmentCount = False, returnTransferCourseStudentEnrollmentCountEntity = False, returnTransferCourseStudentEnrollmentCountEntityFirstDay = False, returnTransferCourseStudentEnrollmentCountEntitySpecifiedDate = False, returnTransferCourseStudentEnrollmentCountEntityToday = False, returnTransferCourseStudentEnrollmentCountFirstDay = False, returnTransferCourseStudentEnrollmentCountSpecifiedDate = False, returnTransferCourseStudentEnrollmentCountToday = False, returnUnexcusedAbsencesForTerm = False, returnUnexcusedAbsencesYTD = False, returnUnscoredAssignmentCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUsingCurriculumSubjectsInGradebook = False, returnViewingFromOfferingEntity = False, returnWebsite = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Section/" + str(SectionID), verb = "get", return_params_list = return_params)

def modifySection(SectionID, EntityID = 1, setSectionID = None, setAllowCECE = None, setAllowStudentsWithoutCategoryToBeAssigned = None, setAssignmentCount = None, setAssignmentCountForTermCalculated = None, setAssignmentCountYTDCalculated = None, setAssignmentDataString = None, setAssignmentsHaveBeenCreated = None, setBellScheduleGroupID = None, setCalculatedBellScheduleGroupID = None, setCalculatedStudentEnrollmentCount = None, setCalculatedStudentEnrollmentCountEntity = None, setCalculatedStudentEnrollmentCountEntityFirstDay = None, setCalculatedStudentEnrollmentCountEntitySpecifiedDate = None, setCalculatedStudentEnrollmentCountEntityToday = None, setCalculatedStudentEnrollmentCountFirstDay = None, setCalculatedStudentEnrollmentCountSpecifiedDate = None, setCalculatedStudentEnrollmentCountToday = None, setCalendarIDMCCCOverride = None, setCanAddStudentSection = None, setCanBeOffered = None, setCode = None, setCourseCodeSectionCode = None, setCourseCodeSectionCodeCourseDescription = None, setCourseDescriptionCodeSectionCode = None, setCourseID = None, setCourseIDHash = None, setCreatedTime = None, setCurrentEnrollment = None, setCurrentEnrollmentEntity = None, setCurrentEnrollmentEntityForFilter = None, setCurrentEnrollmentForFilter = None, setCurrentGradingPeriod = None, setCurrentlyRecalculating = None, setDisplayForTeachers = None, setDisplayPeriodIDCurrentStoredPrimary = None, setDueDateOfLastAssignmentScored = None, setEdFiEducationalEnvironmentID = None, setEffectiveTeacherFirstLastName = None, setEffectiveTeacherLastFirstName = None, setEntityCodeTeacherNumber = None, setEntityID = None, setExcludeFromStudentSectionLink = None, setExcusedAbsencesForTerm = None, setExcusedAbsencesYTD = None, setFit = None, setFutureAssignmentCountForTermCalculated = None, setGradebookCanHaveSettingsCopiedFromPreviousYear = None, setGradedAssignmentCountForTermCalculated = None, setHasAssignments = None, setHasAssignmentsWithAcademicStandards = None, setHasAssignmentsWithStudentGroups = None, setHasAssignmentsWithSubjects = None, setHasCalculationGroupCourse = None, setHasCategoriesInDistrict = None, setHasClosedOrCompletedSectionGradingScaleGroup = None, setHasCompleted = None, setHasCompletedForFilter = None, setHasGradeMarksInEntity = None, setHasGradingPeriodGradeBuckets = None, setHasGradingScales = None, setHasIncompleteClosedGradeChangeRequests = None, setHasNonDeletedAssignments = None, setHasNotStarted = None, setHasNotStartedForFilter = None, setHasPreviousYearSettings = None, setHasStandardsCheckSectionLengthGradingPeriodSet = None, setHasStudentSections = None, setHasSubjectsCheckSectionLengthGradingPeriodSet = None, setHasValidGradebookSetup = None, setHasValidStandardsSetup = None, setHasValidSubjectsSetup = None, setHomeroomID = None, setInPastYear = None, setIsActive = None, setIsActiveOverride = None, setIsAdministeredForTSA = None, setIsAHistoricRecord = None, setIsBilingual = None, setIsCreditRecovery = None, setIsInProgress = None, setIsInProgressForFilter = None, setIsOffered = None, setIsOfferedToAnotherEntity = None, setIsSelfPaced = None, setIsSelfPacedAndActive = None, setIsTSAProficient = None, setLanguageID = None, setLockSectionFromSectionScheduler = None, setLockSectionLengthFromSectionScheduler = None, setMaximumStudentCount = None, setMaximumStudentCountEntity = None, setMaximumStudentCountEntityForFilter = None, setMaximumStudentCountForEntityOfCourse = None, setMaximumStudentCountForViewingEntity = None, setMaximumStudentCountOffered = None, setMaximumStudentCountOfferedForFilter = None, setMaximumStudentCountOfferedToSpecifiedEntity = None, setMeetIDCurrentStoredPrimary = None, setMeetSummaryIDCurrentStoredPrimary = None, setMinimumStudentCount = None, setMissingAssignmentCount = None, setMissingAssignmentCountForTermCalculated = None, setModifiedTime = None, setNoCountAssignmentCountForTermCalculated = None, setNonGradedAssignmentCountForTerm = None, setNonGradedAssignmentCountNoStudentAssignmentsForTerm = None, setNonTransferCourseEnrollmentCountFemales = None, setNonTransferCourseEnrollmentCountFemalesEntity = None, setNonTransferCourseEnrollmentCountFemalesEntityFirstDay = None, setNonTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = None, setNonTransferCourseEnrollmentCountFemalesEntityToday = None, setNonTransferCourseEnrollmentCountFemalesFirstDay = None, setNonTransferCourseEnrollmentCountFemalesSpecifiedDate = None, setNonTransferCourseEnrollmentCountFemalesToday = None, setNonTransferCourseEnrollmentCountMales = None, setNonTransferCourseEnrollmentCountMalesEntity = None, setNonTransferCourseEnrollmentCountMalesEntityFirstDay = None, setNonTransferCourseEnrollmentCountMalesEntitySpecifiedDate = None, setNonTransferCourseEnrollmentCountMalesEntityToday = None, setNonTransferCourseEnrollmentCountMalesFirstDay = None, setNonTransferCourseEnrollmentCountMalesSpecifiedDate = None, setNonTransferCourseEnrollmentCountMalesToday = None, setNonTransferCourseStudentEnrollmentCount = None, setNonTransferCourseStudentEnrollmentCountEntity = None, setNonTransferCourseStudentEnrollmentCountEntityFirstDay = None, setNonTransferCourseStudentEnrollmentCountEntitySpecifiedDate = None, setNonTransferCourseStudentEnrollmentCountEntityToday = None, setNonTransferCourseStudentEnrollmentCountFirstDay = None, setNonTransferCourseStudentEnrollmentCountSpecifiedDate = None, setNonTransferCourseStudentEnrollmentCountToday = None, setNumberOfTransferStudentSections = None, setNumberOfTransferStudentSectionsForFilter = None, setOffenseCount = None, setOffenseCountYTD = None, setOptimalStudentCount = None, setOtherAbsencesForTerm = None, setOtherAbsencesYTD = None, setPeriodDaySummary = None, setPreviousVersionOfFit = None, setProgressStatusSpecifiedDate = None, setProgressStatusToday = None, setRecalculateGradebook = None, setRecalculateGradebookAdmin = None, setReservedSeatCount = None, setRoomSeatsAvailable = None, setSchedulingCategories = None, setSchedulingTeams = None, setSchoolYearID = None, setScoreClarifierAssignmentCountForTermCalculated = None, setScoredAssignmentCount = None, setScoredAssignmentRange0CurrentTerm = None, setScoredAssignmentRange100to90CurrentTerm = None, setScoredAssignmentRange49to1CurrentTerm = None, setScoredAssignmentRange59to50CurrentTerm = None, setScoredAssignmentRange69to60CurrentTerm = None, setScoredAssignmentRange79to70CurrentTerm = None, setScoredAssignmentRange89to80CurrentTerm = None, setSeatsAvailable = None, setSeatsAvailableEntity = None, setSeatsAvailableEntityForFilter = None, setSeatsAvailableForFilter = None, setSectionEnrollmentTotalsForSectionLengthSubsetSummary = None, setSectionEnrollmentTotalsForSectionLengthSubsetSummaryForEntity = None, setSectionIDClonedFrom = None, setSectionIDClonedTo = None, setSectionIDHash = None, setSectionLengthID = None, setSectionLengthScheduledBySectionScheduler = None, setSectionMNID = None, setSelfPacedEndTime = None, setSelfPacedEndTimeDate = None, setSelfPacedEndTimeTime = None, setSingleSex = None, setSingleSexCode = None, setSpecialEdPercentageLimit = None, setSpecifiedPeriodDaySummary = None, setStaffIDCurrentStoredPrimary = None, setStaffMeetIDCurrentStoredPrimary = None, setStateInstructionalMethodCodeMNID = None, setStateSTARModeOfTeachingMNID = None, setStudentAssignmentDataString = None, setStudentCountForTerm = None, setStudentEnrollment = None, setStudentEnrollmentAsOfSpecifiedDate = None, setStudentEnrollmentAsOfSpecifiedDateForFilter = None, setStudentEnrollmentEntity = None, setStudentEnrollmentEntityForFilter = None, setStudentEnrollmentFemales = None, setStudentEnrollmentFemalesAsOfSpecifiedDate = None, setStudentEnrollmentFemalesAsOfSpecifiedDateForFilter = None, setStudentEnrollmentFemalesEntity = None, setStudentEnrollmentFemalesEntityForFilter = None, setStudentEnrollmentFemalesForFilter = None, setStudentEnrollmentForFilter = None, setStudentEnrollmentMales = None, setStudentEnrollmentMalesAsOfSpecifiedDate = None, setStudentEnrollmentMalesAsOfSpecifiedDateForFilter = None, setStudentEnrollmentMalesEntity = None, setStudentEnrollmentMalesEntityForFilter = None, setStudentEnrollmentMalesForFilter = None, setStudentSectionSectionIDHash = None, setTardiesForTerm = None, setTardiesYTD = None, setThisPeriodDaySummary = None, setTotalEnrollmentCount = None, setTotalEnrollmentCountEntity = None, setTotalEnrollmentCountEntityForFilter = None, setTotalEnrollmentCountForFilter = None, setTotalMeetCount = None, setTotalSeatsOfferedToOtherEntities = None, setTransferCourseEnrollmentCountFemales = None, setTransferCourseEnrollmentCountFemalesEntity = None, setTransferCourseEnrollmentCountFemalesEntityFirstDay = None, setTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = None, setTransferCourseEnrollmentCountFemalesEntityToday = None, setTransferCourseEnrollmentCountFemalesFirstDay = None, setTransferCourseEnrollmentCountFemalesSpecifiedDate = None, setTransferCourseEnrollmentCountFemalesToday = None, setTransferCourseEnrollmentCountMales = None, setTransferCourseEnrollmentCountMalesEntity = None, setTransferCourseEnrollmentCountMalesEntityFirstDay = None, setTransferCourseEnrollmentCountMalesEntitySpecifiedDate = None, setTransferCourseEnrollmentCountMalesEntityToday = None, setTransferCourseEnrollmentCountMalesFirstDay = None, setTransferCourseEnrollmentCountMalesSpecifiedDate = None, setTransferCourseEnrollmentCountMalesToday = None, setTransferCourseStudentEnrollmentCount = None, setTransferCourseStudentEnrollmentCountEntity = None, setTransferCourseStudentEnrollmentCountEntityFirstDay = None, setTransferCourseStudentEnrollmentCountEntitySpecifiedDate = None, setTransferCourseStudentEnrollmentCountEntityToday = None, setTransferCourseStudentEnrollmentCountFirstDay = None, setTransferCourseStudentEnrollmentCountSpecifiedDate = None, setTransferCourseStudentEnrollmentCountToday = None, setUnexcusedAbsencesForTerm = None, setUnexcusedAbsencesYTD = None, setUnscoredAssignmentCount = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUsingCurriculumSubjectsInGradebook = None, setViewingFromOfferingEntity = None, setWebsite = None, returnSectionID = False, returnAllowCECE = False, returnAllowStudentsWithoutCategoryToBeAssigned = False, returnAssignmentCount = False, returnAssignmentCountForTermCalculated = False, returnAssignmentCountYTDCalculated = False, returnAssignmentDataString = False, returnAssignmentsHaveBeenCreated = False, returnBellScheduleGroupID = False, returnCalculatedBellScheduleGroupID = False, returnCalculatedStudentEnrollmentCount = False, returnCalculatedStudentEnrollmentCountEntity = False, returnCalculatedStudentEnrollmentCountEntityFirstDay = False, returnCalculatedStudentEnrollmentCountEntitySpecifiedDate = False, returnCalculatedStudentEnrollmentCountEntityToday = False, returnCalculatedStudentEnrollmentCountFirstDay = False, returnCalculatedStudentEnrollmentCountSpecifiedDate = False, returnCalculatedStudentEnrollmentCountToday = False, returnCalendarIDMCCCOverride = False, returnCanAddStudentSection = False, returnCanBeOffered = False, returnCode = False, returnCourseCodeSectionCode = False, returnCourseCodeSectionCodeCourseDescription = False, returnCourseDescriptionCodeSectionCode = False, returnCourseID = False, returnCourseIDHash = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnCurrentEnrollmentEntity = False, returnCurrentEnrollmentEntityForFilter = False, returnCurrentEnrollmentForFilter = False, returnCurrentGradingPeriod = False, returnCurrentlyRecalculating = False, returnDisplayForTeachers = False, returnDisplayPeriodIDCurrentStoredPrimary = False, returnDueDateOfLastAssignmentScored = False, returnEdFiEducationalEnvironmentID = False, returnEffectiveTeacherFirstLastName = False, returnEffectiveTeacherLastFirstName = False, returnEntityCodeTeacherNumber = False, returnEntityID = False, returnExcludeFromStudentSectionLink = False, returnExcusedAbsencesForTerm = False, returnExcusedAbsencesYTD = False, returnFit = False, returnFutureAssignmentCountForTermCalculated = False, returnGradebookCanHaveSettingsCopiedFromPreviousYear = False, returnGradedAssignmentCountForTermCalculated = False, returnHasAssignments = False, returnHasAssignmentsWithAcademicStandards = False, returnHasAssignmentsWithStudentGroups = False, returnHasAssignmentsWithSubjects = False, returnHasCalculationGroupCourse = False, returnHasCategoriesInDistrict = False, returnHasClosedOrCompletedSectionGradingScaleGroup = False, returnHasCompleted = False, returnHasCompletedForFilter = False, returnHasGradeMarksInEntity = False, returnHasGradingPeriodGradeBuckets = False, returnHasGradingScales = False, returnHasIncompleteClosedGradeChangeRequests = False, returnHasNonDeletedAssignments = False, returnHasNotStarted = False, returnHasNotStartedForFilter = False, returnHasPreviousYearSettings = False, returnHasStandardsCheckSectionLengthGradingPeriodSet = False, returnHasStudentSections = False, returnHasSubjectsCheckSectionLengthGradingPeriodSet = False, returnHasValidGradebookSetup = False, returnHasValidStandardsSetup = False, returnHasValidSubjectsSetup = False, returnHomeroomID = False, returnInPastYear = False, returnIsActive = False, returnIsActiveOverride = False, returnIsAdministeredForTSA = False, returnIsAHistoricRecord = False, returnIsBilingual = False, returnIsCreditRecovery = False, returnIsInProgress = False, returnIsInProgressForFilter = False, returnIsOffered = False, returnIsOfferedToAnotherEntity = False, returnIsSelfPaced = False, returnIsSelfPacedAndActive = False, returnIsTSAProficient = False, returnLanguageID = False, returnLockSectionFromSectionScheduler = False, returnLockSectionLengthFromSectionScheduler = False, returnMaximumStudentCount = False, returnMaximumStudentCountEntity = False, returnMaximumStudentCountEntityForFilter = False, returnMaximumStudentCountForEntityOfCourse = False, returnMaximumStudentCountForViewingEntity = False, returnMaximumStudentCountOffered = False, returnMaximumStudentCountOfferedForFilter = False, returnMaximumStudentCountOfferedToSpecifiedEntity = False, returnMeetIDCurrentStoredPrimary = False, returnMeetSummaryIDCurrentStoredPrimary = False, returnMinimumStudentCount = False, returnMissingAssignmentCount = False, returnMissingAssignmentCountForTermCalculated = False, returnModifiedTime = False, returnNoCountAssignmentCountForTermCalculated = False, returnNonGradedAssignmentCountForTerm = False, returnNonGradedAssignmentCountNoStudentAssignmentsForTerm = False, returnNonTransferCourseEnrollmentCountFemales = False, returnNonTransferCourseEnrollmentCountFemalesEntity = False, returnNonTransferCourseEnrollmentCountFemalesEntityFirstDay = False, returnNonTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = False, returnNonTransferCourseEnrollmentCountFemalesEntityToday = False, returnNonTransferCourseEnrollmentCountFemalesFirstDay = False, returnNonTransferCourseEnrollmentCountFemalesSpecifiedDate = False, returnNonTransferCourseEnrollmentCountFemalesToday = False, returnNonTransferCourseEnrollmentCountMales = False, returnNonTransferCourseEnrollmentCountMalesEntity = False, returnNonTransferCourseEnrollmentCountMalesEntityFirstDay = False, returnNonTransferCourseEnrollmentCountMalesEntitySpecifiedDate = False, returnNonTransferCourseEnrollmentCountMalesEntityToday = False, returnNonTransferCourseEnrollmentCountMalesFirstDay = False, returnNonTransferCourseEnrollmentCountMalesSpecifiedDate = False, returnNonTransferCourseEnrollmentCountMalesToday = False, returnNonTransferCourseStudentEnrollmentCount = False, returnNonTransferCourseStudentEnrollmentCountEntity = False, returnNonTransferCourseStudentEnrollmentCountEntityFirstDay = False, returnNonTransferCourseStudentEnrollmentCountEntitySpecifiedDate = False, returnNonTransferCourseStudentEnrollmentCountEntityToday = False, returnNonTransferCourseStudentEnrollmentCountFirstDay = False, returnNonTransferCourseStudentEnrollmentCountSpecifiedDate = False, returnNonTransferCourseStudentEnrollmentCountToday = False, returnNumberOfTransferStudentSections = False, returnNumberOfTransferStudentSectionsForFilter = False, returnOffenseCount = False, returnOffenseCountYTD = False, returnOptimalStudentCount = False, returnOtherAbsencesForTerm = False, returnOtherAbsencesYTD = False, returnPeriodDaySummary = False, returnPreviousVersionOfFit = False, returnProgressStatusSpecifiedDate = False, returnProgressStatusToday = False, returnRecalculateGradebook = False, returnRecalculateGradebookAdmin = False, returnReservedSeatCount = False, returnRoomSeatsAvailable = False, returnSchedulingCategories = False, returnSchedulingTeams = False, returnSchoolYearID = False, returnScoreClarifierAssignmentCountForTermCalculated = False, returnScoredAssignmentCount = False, returnScoredAssignmentRange0CurrentTerm = False, returnScoredAssignmentRange100to90CurrentTerm = False, returnScoredAssignmentRange49to1CurrentTerm = False, returnScoredAssignmentRange59to50CurrentTerm = False, returnScoredAssignmentRange69to60CurrentTerm = False, returnScoredAssignmentRange79to70CurrentTerm = False, returnScoredAssignmentRange89to80CurrentTerm = False, returnSeatsAvailable = False, returnSeatsAvailableEntity = False, returnSeatsAvailableEntityForFilter = False, returnSeatsAvailableForFilter = False, returnSectionEnrollmentTotalsForSectionLengthSubsetSummary = False, returnSectionEnrollmentTotalsForSectionLengthSubsetSummaryForEntity = False, returnSectionIDClonedFrom = False, returnSectionIDClonedTo = False, returnSectionIDHash = False, returnSectionLengthID = False, returnSectionLengthScheduledBySectionScheduler = False, returnSectionMNID = False, returnSelfPacedEndTime = False, returnSelfPacedEndTimeDate = False, returnSelfPacedEndTimeTime = False, returnSingleSex = False, returnSingleSexCode = False, returnSpecialEdPercentageLimit = False, returnSpecifiedPeriodDaySummary = False, returnStaffIDCurrentStoredPrimary = False, returnStaffMeetIDCurrentStoredPrimary = False, returnStateInstructionalMethodCodeMNID = False, returnStateSTARModeOfTeachingMNID = False, returnStudentAssignmentDataString = False, returnStudentCountForTerm = False, returnStudentEnrollment = False, returnStudentEnrollmentAsOfSpecifiedDate = False, returnStudentEnrollmentAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentEntity = False, returnStudentEnrollmentEntityForFilter = False, returnStudentEnrollmentFemales = False, returnStudentEnrollmentFemalesAsOfSpecifiedDate = False, returnStudentEnrollmentFemalesAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentFemalesEntity = False, returnStudentEnrollmentFemalesEntityForFilter = False, returnStudentEnrollmentFemalesForFilter = False, returnStudentEnrollmentForFilter = False, returnStudentEnrollmentMales = False, returnStudentEnrollmentMalesAsOfSpecifiedDate = False, returnStudentEnrollmentMalesAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentMalesEntity = False, returnStudentEnrollmentMalesEntityForFilter = False, returnStudentEnrollmentMalesForFilter = False, returnStudentSectionSectionIDHash = False, returnTardiesForTerm = False, returnTardiesYTD = False, returnThisPeriodDaySummary = False, returnTotalEnrollmentCount = False, returnTotalEnrollmentCountEntity = False, returnTotalEnrollmentCountEntityForFilter = False, returnTotalEnrollmentCountForFilter = False, returnTotalMeetCount = False, returnTotalSeatsOfferedToOtherEntities = False, returnTransferCourseEnrollmentCountFemales = False, returnTransferCourseEnrollmentCountFemalesEntity = False, returnTransferCourseEnrollmentCountFemalesEntityFirstDay = False, returnTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = False, returnTransferCourseEnrollmentCountFemalesEntityToday = False, returnTransferCourseEnrollmentCountFemalesFirstDay = False, returnTransferCourseEnrollmentCountFemalesSpecifiedDate = False, returnTransferCourseEnrollmentCountFemalesToday = False, returnTransferCourseEnrollmentCountMales = False, returnTransferCourseEnrollmentCountMalesEntity = False, returnTransferCourseEnrollmentCountMalesEntityFirstDay = False, returnTransferCourseEnrollmentCountMalesEntitySpecifiedDate = False, returnTransferCourseEnrollmentCountMalesEntityToday = False, returnTransferCourseEnrollmentCountMalesFirstDay = False, returnTransferCourseEnrollmentCountMalesSpecifiedDate = False, returnTransferCourseEnrollmentCountMalesToday = False, returnTransferCourseStudentEnrollmentCount = False, returnTransferCourseStudentEnrollmentCountEntity = False, returnTransferCourseStudentEnrollmentCountEntityFirstDay = False, returnTransferCourseStudentEnrollmentCountEntitySpecifiedDate = False, returnTransferCourseStudentEnrollmentCountEntityToday = False, returnTransferCourseStudentEnrollmentCountFirstDay = False, returnTransferCourseStudentEnrollmentCountSpecifiedDate = False, returnTransferCourseStudentEnrollmentCountToday = False, returnUnexcusedAbsencesForTerm = False, returnUnexcusedAbsencesYTD = False, returnUnscoredAssignmentCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUsingCurriculumSubjectsInGradebook = False, returnViewingFromOfferingEntity = False, returnWebsite = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Section/" + str(SectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSection(EntityID = 1, setSectionID = None, setAllowCECE = None, setAllowStudentsWithoutCategoryToBeAssigned = None, setAssignmentCount = None, setAssignmentCountForTermCalculated = None, setAssignmentCountYTDCalculated = None, setAssignmentDataString = None, setAssignmentsHaveBeenCreated = None, setBellScheduleGroupID = None, setCalculatedBellScheduleGroupID = None, setCalculatedStudentEnrollmentCount = None, setCalculatedStudentEnrollmentCountEntity = None, setCalculatedStudentEnrollmentCountEntityFirstDay = None, setCalculatedStudentEnrollmentCountEntitySpecifiedDate = None, setCalculatedStudentEnrollmentCountEntityToday = None, setCalculatedStudentEnrollmentCountFirstDay = None, setCalculatedStudentEnrollmentCountSpecifiedDate = None, setCalculatedStudentEnrollmentCountToday = None, setCalendarIDMCCCOverride = None, setCanAddStudentSection = None, setCanBeOffered = None, setCode = None, setCourseCodeSectionCode = None, setCourseCodeSectionCodeCourseDescription = None, setCourseDescriptionCodeSectionCode = None, setCourseID = None, setCourseIDHash = None, setCreatedTime = None, setCurrentEnrollment = None, setCurrentEnrollmentEntity = None, setCurrentEnrollmentEntityForFilter = None, setCurrentEnrollmentForFilter = None, setCurrentGradingPeriod = None, setCurrentlyRecalculating = None, setDisplayForTeachers = None, setDisplayPeriodIDCurrentStoredPrimary = None, setDueDateOfLastAssignmentScored = None, setEdFiEducationalEnvironmentID = None, setEffectiveTeacherFirstLastName = None, setEffectiveTeacherLastFirstName = None, setEntityCodeTeacherNumber = None, setEntityID = None, setExcludeFromStudentSectionLink = None, setExcusedAbsencesForTerm = None, setExcusedAbsencesYTD = None, setFit = None, setFutureAssignmentCountForTermCalculated = None, setGradebookCanHaveSettingsCopiedFromPreviousYear = None, setGradedAssignmentCountForTermCalculated = None, setHasAssignments = None, setHasAssignmentsWithAcademicStandards = None, setHasAssignmentsWithStudentGroups = None, setHasAssignmentsWithSubjects = None, setHasCalculationGroupCourse = None, setHasCategoriesInDistrict = None, setHasClosedOrCompletedSectionGradingScaleGroup = None, setHasCompleted = None, setHasCompletedForFilter = None, setHasGradeMarksInEntity = None, setHasGradingPeriodGradeBuckets = None, setHasGradingScales = None, setHasIncompleteClosedGradeChangeRequests = None, setHasNonDeletedAssignments = None, setHasNotStarted = None, setHasNotStartedForFilter = None, setHasPreviousYearSettings = None, setHasStandardsCheckSectionLengthGradingPeriodSet = None, setHasStudentSections = None, setHasSubjectsCheckSectionLengthGradingPeriodSet = None, setHasValidGradebookSetup = None, setHasValidStandardsSetup = None, setHasValidSubjectsSetup = None, setHomeroomID = None, setInPastYear = None, setIsActive = None, setIsActiveOverride = None, setIsAdministeredForTSA = None, setIsAHistoricRecord = None, setIsBilingual = None, setIsCreditRecovery = None, setIsInProgress = None, setIsInProgressForFilter = None, setIsOffered = None, setIsOfferedToAnotherEntity = None, setIsSelfPaced = None, setIsSelfPacedAndActive = None, setIsTSAProficient = None, setLanguageID = None, setLockSectionFromSectionScheduler = None, setLockSectionLengthFromSectionScheduler = None, setMaximumStudentCount = None, setMaximumStudentCountEntity = None, setMaximumStudentCountEntityForFilter = None, setMaximumStudentCountForEntityOfCourse = None, setMaximumStudentCountForViewingEntity = None, setMaximumStudentCountOffered = None, setMaximumStudentCountOfferedForFilter = None, setMaximumStudentCountOfferedToSpecifiedEntity = None, setMeetIDCurrentStoredPrimary = None, setMeetSummaryIDCurrentStoredPrimary = None, setMinimumStudentCount = None, setMissingAssignmentCount = None, setMissingAssignmentCountForTermCalculated = None, setModifiedTime = None, setNoCountAssignmentCountForTermCalculated = None, setNonGradedAssignmentCountForTerm = None, setNonGradedAssignmentCountNoStudentAssignmentsForTerm = None, setNonTransferCourseEnrollmentCountFemales = None, setNonTransferCourseEnrollmentCountFemalesEntity = None, setNonTransferCourseEnrollmentCountFemalesEntityFirstDay = None, setNonTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = None, setNonTransferCourseEnrollmentCountFemalesEntityToday = None, setNonTransferCourseEnrollmentCountFemalesFirstDay = None, setNonTransferCourseEnrollmentCountFemalesSpecifiedDate = None, setNonTransferCourseEnrollmentCountFemalesToday = None, setNonTransferCourseEnrollmentCountMales = None, setNonTransferCourseEnrollmentCountMalesEntity = None, setNonTransferCourseEnrollmentCountMalesEntityFirstDay = None, setNonTransferCourseEnrollmentCountMalesEntitySpecifiedDate = None, setNonTransferCourseEnrollmentCountMalesEntityToday = None, setNonTransferCourseEnrollmentCountMalesFirstDay = None, setNonTransferCourseEnrollmentCountMalesSpecifiedDate = None, setNonTransferCourseEnrollmentCountMalesToday = None, setNonTransferCourseStudentEnrollmentCount = None, setNonTransferCourseStudentEnrollmentCountEntity = None, setNonTransferCourseStudentEnrollmentCountEntityFirstDay = None, setNonTransferCourseStudentEnrollmentCountEntitySpecifiedDate = None, setNonTransferCourseStudentEnrollmentCountEntityToday = None, setNonTransferCourseStudentEnrollmentCountFirstDay = None, setNonTransferCourseStudentEnrollmentCountSpecifiedDate = None, setNonTransferCourseStudentEnrollmentCountToday = None, setNumberOfTransferStudentSections = None, setNumberOfTransferStudentSectionsForFilter = None, setOffenseCount = None, setOffenseCountYTD = None, setOptimalStudentCount = None, setOtherAbsencesForTerm = None, setOtherAbsencesYTD = None, setPeriodDaySummary = None, setPreviousVersionOfFit = None, setProgressStatusSpecifiedDate = None, setProgressStatusToday = None, setRecalculateGradebook = None, setRecalculateGradebookAdmin = None, setReservedSeatCount = None, setRoomSeatsAvailable = None, setSchedulingCategories = None, setSchedulingTeams = None, setSchoolYearID = None, setScoreClarifierAssignmentCountForTermCalculated = None, setScoredAssignmentCount = None, setScoredAssignmentRange0CurrentTerm = None, setScoredAssignmentRange100to90CurrentTerm = None, setScoredAssignmentRange49to1CurrentTerm = None, setScoredAssignmentRange59to50CurrentTerm = None, setScoredAssignmentRange69to60CurrentTerm = None, setScoredAssignmentRange79to70CurrentTerm = None, setScoredAssignmentRange89to80CurrentTerm = None, setSeatsAvailable = None, setSeatsAvailableEntity = None, setSeatsAvailableEntityForFilter = None, setSeatsAvailableForFilter = None, setSectionEnrollmentTotalsForSectionLengthSubsetSummary = None, setSectionEnrollmentTotalsForSectionLengthSubsetSummaryForEntity = None, setSectionIDClonedFrom = None, setSectionIDClonedTo = None, setSectionIDHash = None, setSectionLengthID = None, setSectionLengthScheduledBySectionScheduler = None, setSectionMNID = None, setSelfPacedEndTime = None, setSelfPacedEndTimeDate = None, setSelfPacedEndTimeTime = None, setSingleSex = None, setSingleSexCode = None, setSpecialEdPercentageLimit = None, setSpecifiedPeriodDaySummary = None, setStaffIDCurrentStoredPrimary = None, setStaffMeetIDCurrentStoredPrimary = None, setStateInstructionalMethodCodeMNID = None, setStateSTARModeOfTeachingMNID = None, setStudentAssignmentDataString = None, setStudentCountForTerm = None, setStudentEnrollment = None, setStudentEnrollmentAsOfSpecifiedDate = None, setStudentEnrollmentAsOfSpecifiedDateForFilter = None, setStudentEnrollmentEntity = None, setStudentEnrollmentEntityForFilter = None, setStudentEnrollmentFemales = None, setStudentEnrollmentFemalesAsOfSpecifiedDate = None, setStudentEnrollmentFemalesAsOfSpecifiedDateForFilter = None, setStudentEnrollmentFemalesEntity = None, setStudentEnrollmentFemalesEntityForFilter = None, setStudentEnrollmentFemalesForFilter = None, setStudentEnrollmentForFilter = None, setStudentEnrollmentMales = None, setStudentEnrollmentMalesAsOfSpecifiedDate = None, setStudentEnrollmentMalesAsOfSpecifiedDateForFilter = None, setStudentEnrollmentMalesEntity = None, setStudentEnrollmentMalesEntityForFilter = None, setStudentEnrollmentMalesForFilter = None, setStudentSectionSectionIDHash = None, setTardiesForTerm = None, setTardiesYTD = None, setThisPeriodDaySummary = None, setTotalEnrollmentCount = None, setTotalEnrollmentCountEntity = None, setTotalEnrollmentCountEntityForFilter = None, setTotalEnrollmentCountForFilter = None, setTotalMeetCount = None, setTotalSeatsOfferedToOtherEntities = None, setTransferCourseEnrollmentCountFemales = None, setTransferCourseEnrollmentCountFemalesEntity = None, setTransferCourseEnrollmentCountFemalesEntityFirstDay = None, setTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = None, setTransferCourseEnrollmentCountFemalesEntityToday = None, setTransferCourseEnrollmentCountFemalesFirstDay = None, setTransferCourseEnrollmentCountFemalesSpecifiedDate = None, setTransferCourseEnrollmentCountFemalesToday = None, setTransferCourseEnrollmentCountMales = None, setTransferCourseEnrollmentCountMalesEntity = None, setTransferCourseEnrollmentCountMalesEntityFirstDay = None, setTransferCourseEnrollmentCountMalesEntitySpecifiedDate = None, setTransferCourseEnrollmentCountMalesEntityToday = None, setTransferCourseEnrollmentCountMalesFirstDay = None, setTransferCourseEnrollmentCountMalesSpecifiedDate = None, setTransferCourseEnrollmentCountMalesToday = None, setTransferCourseStudentEnrollmentCount = None, setTransferCourseStudentEnrollmentCountEntity = None, setTransferCourseStudentEnrollmentCountEntityFirstDay = None, setTransferCourseStudentEnrollmentCountEntitySpecifiedDate = None, setTransferCourseStudentEnrollmentCountEntityToday = None, setTransferCourseStudentEnrollmentCountFirstDay = None, setTransferCourseStudentEnrollmentCountSpecifiedDate = None, setTransferCourseStudentEnrollmentCountToday = None, setUnexcusedAbsencesForTerm = None, setUnexcusedAbsencesYTD = None, setUnscoredAssignmentCount = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUsingCurriculumSubjectsInGradebook = None, setViewingFromOfferingEntity = None, setWebsite = None, returnSectionID = False, returnAllowCECE = False, returnAllowStudentsWithoutCategoryToBeAssigned = False, returnAssignmentCount = False, returnAssignmentCountForTermCalculated = False, returnAssignmentCountYTDCalculated = False, returnAssignmentDataString = False, returnAssignmentsHaveBeenCreated = False, returnBellScheduleGroupID = False, returnCalculatedBellScheduleGroupID = False, returnCalculatedStudentEnrollmentCount = False, returnCalculatedStudentEnrollmentCountEntity = False, returnCalculatedStudentEnrollmentCountEntityFirstDay = False, returnCalculatedStudentEnrollmentCountEntitySpecifiedDate = False, returnCalculatedStudentEnrollmentCountEntityToday = False, returnCalculatedStudentEnrollmentCountFirstDay = False, returnCalculatedStudentEnrollmentCountSpecifiedDate = False, returnCalculatedStudentEnrollmentCountToday = False, returnCalendarIDMCCCOverride = False, returnCanAddStudentSection = False, returnCanBeOffered = False, returnCode = False, returnCourseCodeSectionCode = False, returnCourseCodeSectionCodeCourseDescription = False, returnCourseDescriptionCodeSectionCode = False, returnCourseID = False, returnCourseIDHash = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnCurrentEnrollmentEntity = False, returnCurrentEnrollmentEntityForFilter = False, returnCurrentEnrollmentForFilter = False, returnCurrentGradingPeriod = False, returnCurrentlyRecalculating = False, returnDisplayForTeachers = False, returnDisplayPeriodIDCurrentStoredPrimary = False, returnDueDateOfLastAssignmentScored = False, returnEdFiEducationalEnvironmentID = False, returnEffectiveTeacherFirstLastName = False, returnEffectiveTeacherLastFirstName = False, returnEntityCodeTeacherNumber = False, returnEntityID = False, returnExcludeFromStudentSectionLink = False, returnExcusedAbsencesForTerm = False, returnExcusedAbsencesYTD = False, returnFit = False, returnFutureAssignmentCountForTermCalculated = False, returnGradebookCanHaveSettingsCopiedFromPreviousYear = False, returnGradedAssignmentCountForTermCalculated = False, returnHasAssignments = False, returnHasAssignmentsWithAcademicStandards = False, returnHasAssignmentsWithStudentGroups = False, returnHasAssignmentsWithSubjects = False, returnHasCalculationGroupCourse = False, returnHasCategoriesInDistrict = False, returnHasClosedOrCompletedSectionGradingScaleGroup = False, returnHasCompleted = False, returnHasCompletedForFilter = False, returnHasGradeMarksInEntity = False, returnHasGradingPeriodGradeBuckets = False, returnHasGradingScales = False, returnHasIncompleteClosedGradeChangeRequests = False, returnHasNonDeletedAssignments = False, returnHasNotStarted = False, returnHasNotStartedForFilter = False, returnHasPreviousYearSettings = False, returnHasStandardsCheckSectionLengthGradingPeriodSet = False, returnHasStudentSections = False, returnHasSubjectsCheckSectionLengthGradingPeriodSet = False, returnHasValidGradebookSetup = False, returnHasValidStandardsSetup = False, returnHasValidSubjectsSetup = False, returnHomeroomID = False, returnInPastYear = False, returnIsActive = False, returnIsActiveOverride = False, returnIsAdministeredForTSA = False, returnIsAHistoricRecord = False, returnIsBilingual = False, returnIsCreditRecovery = False, returnIsInProgress = False, returnIsInProgressForFilter = False, returnIsOffered = False, returnIsOfferedToAnotherEntity = False, returnIsSelfPaced = False, returnIsSelfPacedAndActive = False, returnIsTSAProficient = False, returnLanguageID = False, returnLockSectionFromSectionScheduler = False, returnLockSectionLengthFromSectionScheduler = False, returnMaximumStudentCount = False, returnMaximumStudentCountEntity = False, returnMaximumStudentCountEntityForFilter = False, returnMaximumStudentCountForEntityOfCourse = False, returnMaximumStudentCountForViewingEntity = False, returnMaximumStudentCountOffered = False, returnMaximumStudentCountOfferedForFilter = False, returnMaximumStudentCountOfferedToSpecifiedEntity = False, returnMeetIDCurrentStoredPrimary = False, returnMeetSummaryIDCurrentStoredPrimary = False, returnMinimumStudentCount = False, returnMissingAssignmentCount = False, returnMissingAssignmentCountForTermCalculated = False, returnModifiedTime = False, returnNoCountAssignmentCountForTermCalculated = False, returnNonGradedAssignmentCountForTerm = False, returnNonGradedAssignmentCountNoStudentAssignmentsForTerm = False, returnNonTransferCourseEnrollmentCountFemales = False, returnNonTransferCourseEnrollmentCountFemalesEntity = False, returnNonTransferCourseEnrollmentCountFemalesEntityFirstDay = False, returnNonTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = False, returnNonTransferCourseEnrollmentCountFemalesEntityToday = False, returnNonTransferCourseEnrollmentCountFemalesFirstDay = False, returnNonTransferCourseEnrollmentCountFemalesSpecifiedDate = False, returnNonTransferCourseEnrollmentCountFemalesToday = False, returnNonTransferCourseEnrollmentCountMales = False, returnNonTransferCourseEnrollmentCountMalesEntity = False, returnNonTransferCourseEnrollmentCountMalesEntityFirstDay = False, returnNonTransferCourseEnrollmentCountMalesEntitySpecifiedDate = False, returnNonTransferCourseEnrollmentCountMalesEntityToday = False, returnNonTransferCourseEnrollmentCountMalesFirstDay = False, returnNonTransferCourseEnrollmentCountMalesSpecifiedDate = False, returnNonTransferCourseEnrollmentCountMalesToday = False, returnNonTransferCourseStudentEnrollmentCount = False, returnNonTransferCourseStudentEnrollmentCountEntity = False, returnNonTransferCourseStudentEnrollmentCountEntityFirstDay = False, returnNonTransferCourseStudentEnrollmentCountEntitySpecifiedDate = False, returnNonTransferCourseStudentEnrollmentCountEntityToday = False, returnNonTransferCourseStudentEnrollmentCountFirstDay = False, returnNonTransferCourseStudentEnrollmentCountSpecifiedDate = False, returnNonTransferCourseStudentEnrollmentCountToday = False, returnNumberOfTransferStudentSections = False, returnNumberOfTransferStudentSectionsForFilter = False, returnOffenseCount = False, returnOffenseCountYTD = False, returnOptimalStudentCount = False, returnOtherAbsencesForTerm = False, returnOtherAbsencesYTD = False, returnPeriodDaySummary = False, returnPreviousVersionOfFit = False, returnProgressStatusSpecifiedDate = False, returnProgressStatusToday = False, returnRecalculateGradebook = False, returnRecalculateGradebookAdmin = False, returnReservedSeatCount = False, returnRoomSeatsAvailable = False, returnSchedulingCategories = False, returnSchedulingTeams = False, returnSchoolYearID = False, returnScoreClarifierAssignmentCountForTermCalculated = False, returnScoredAssignmentCount = False, returnScoredAssignmentRange0CurrentTerm = False, returnScoredAssignmentRange100to90CurrentTerm = False, returnScoredAssignmentRange49to1CurrentTerm = False, returnScoredAssignmentRange59to50CurrentTerm = False, returnScoredAssignmentRange69to60CurrentTerm = False, returnScoredAssignmentRange79to70CurrentTerm = False, returnScoredAssignmentRange89to80CurrentTerm = False, returnSeatsAvailable = False, returnSeatsAvailableEntity = False, returnSeatsAvailableEntityForFilter = False, returnSeatsAvailableForFilter = False, returnSectionEnrollmentTotalsForSectionLengthSubsetSummary = False, returnSectionEnrollmentTotalsForSectionLengthSubsetSummaryForEntity = False, returnSectionIDClonedFrom = False, returnSectionIDClonedTo = False, returnSectionIDHash = False, returnSectionLengthID = False, returnSectionLengthScheduledBySectionScheduler = False, returnSectionMNID = False, returnSelfPacedEndTime = False, returnSelfPacedEndTimeDate = False, returnSelfPacedEndTimeTime = False, returnSingleSex = False, returnSingleSexCode = False, returnSpecialEdPercentageLimit = False, returnSpecifiedPeriodDaySummary = False, returnStaffIDCurrentStoredPrimary = False, returnStaffMeetIDCurrentStoredPrimary = False, returnStateInstructionalMethodCodeMNID = False, returnStateSTARModeOfTeachingMNID = False, returnStudentAssignmentDataString = False, returnStudentCountForTerm = False, returnStudentEnrollment = False, returnStudentEnrollmentAsOfSpecifiedDate = False, returnStudentEnrollmentAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentEntity = False, returnStudentEnrollmentEntityForFilter = False, returnStudentEnrollmentFemales = False, returnStudentEnrollmentFemalesAsOfSpecifiedDate = False, returnStudentEnrollmentFemalesAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentFemalesEntity = False, returnStudentEnrollmentFemalesEntityForFilter = False, returnStudentEnrollmentFemalesForFilter = False, returnStudentEnrollmentForFilter = False, returnStudentEnrollmentMales = False, returnStudentEnrollmentMalesAsOfSpecifiedDate = False, returnStudentEnrollmentMalesAsOfSpecifiedDateForFilter = False, returnStudentEnrollmentMalesEntity = False, returnStudentEnrollmentMalesEntityForFilter = False, returnStudentEnrollmentMalesForFilter = False, returnStudentSectionSectionIDHash = False, returnTardiesForTerm = False, returnTardiesYTD = False, returnThisPeriodDaySummary = False, returnTotalEnrollmentCount = False, returnTotalEnrollmentCountEntity = False, returnTotalEnrollmentCountEntityForFilter = False, returnTotalEnrollmentCountForFilter = False, returnTotalMeetCount = False, returnTotalSeatsOfferedToOtherEntities = False, returnTransferCourseEnrollmentCountFemales = False, returnTransferCourseEnrollmentCountFemalesEntity = False, returnTransferCourseEnrollmentCountFemalesEntityFirstDay = False, returnTransferCourseEnrollmentCountFemalesEntitySpecifiedDate = False, returnTransferCourseEnrollmentCountFemalesEntityToday = False, returnTransferCourseEnrollmentCountFemalesFirstDay = False, returnTransferCourseEnrollmentCountFemalesSpecifiedDate = False, returnTransferCourseEnrollmentCountFemalesToday = False, returnTransferCourseEnrollmentCountMales = False, returnTransferCourseEnrollmentCountMalesEntity = False, returnTransferCourseEnrollmentCountMalesEntityFirstDay = False, returnTransferCourseEnrollmentCountMalesEntitySpecifiedDate = False, returnTransferCourseEnrollmentCountMalesEntityToday = False, returnTransferCourseEnrollmentCountMalesFirstDay = False, returnTransferCourseEnrollmentCountMalesSpecifiedDate = False, returnTransferCourseEnrollmentCountMalesToday = False, returnTransferCourseStudentEnrollmentCount = False, returnTransferCourseStudentEnrollmentCountEntity = False, returnTransferCourseStudentEnrollmentCountEntityFirstDay = False, returnTransferCourseStudentEnrollmentCountEntitySpecifiedDate = False, returnTransferCourseStudentEnrollmentCountEntityToday = False, returnTransferCourseStudentEnrollmentCountFirstDay = False, returnTransferCourseStudentEnrollmentCountSpecifiedDate = False, returnTransferCourseStudentEnrollmentCountToday = False, returnUnexcusedAbsencesForTerm = False, returnUnexcusedAbsencesYTD = False, returnUnscoredAssignmentCount = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUsingCurriculumSubjectsInGradebook = False, returnViewingFromOfferingEntity = False, returnWebsite = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Section/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSection(SectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/Section/" + str(SectionID), verb = "delete")


def getEverySectionSchedulerCourseConstraint(searchConditions = [], EntityID = 1, returnSectionSchedulerCourseConstraintID = False, returnCourseID = False, returnCourseIDLinked = False, returnCreatedTime = False, returnCurrentCourseSection = False, returnCurrentCourseSectionCode = False, returnCurrentCourseTopSectionCount = False, returnIsActive = False, returnLinkedCourse = False, returnLinkedCourseSection = False, returnLinkedCourseSectionCode = False, returnLinkedCourseTopSectionCount = False, returnModifiedTime = False, returnRule = False, returnRuleCode = False, returnScheduleFirst = False, returnScheduleLinkedCourseFirst = False, returnSectionIDCurrentCourseSelected = False, returnSectionIDLinkedCourseSelected = False, returnSectionSchedulerCourseConstraintIDClonedFrom = False, returnSectionSchedulerCourseConstraintIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerCourseConstraint in the district.

    This function returns a dataframe of every SectionSchedulerCourseConstraint in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerCourseConstraint/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerCourseConstraint/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerCourseConstraint(SectionSchedulerCourseConstraintID, EntityID = 1, returnSectionSchedulerCourseConstraintID = False, returnCourseID = False, returnCourseIDLinked = False, returnCreatedTime = False, returnCurrentCourseSection = False, returnCurrentCourseSectionCode = False, returnCurrentCourseTopSectionCount = False, returnIsActive = False, returnLinkedCourse = False, returnLinkedCourseSection = False, returnLinkedCourseSectionCode = False, returnLinkedCourseTopSectionCount = False, returnModifiedTime = False, returnRule = False, returnRuleCode = False, returnScheduleFirst = False, returnScheduleLinkedCourseFirst = False, returnSectionIDCurrentCourseSelected = False, returnSectionIDLinkedCourseSelected = False, returnSectionSchedulerCourseConstraintIDClonedFrom = False, returnSectionSchedulerCourseConstraintIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerCourseConstraint/" + str(SectionSchedulerCourseConstraintID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerCourseConstraint(SectionSchedulerCourseConstraintID, EntityID = 1, setSectionSchedulerCourseConstraintID = None, setCourseID = None, setCourseIDLinked = None, setCreatedTime = None, setCurrentCourseSection = None, setCurrentCourseSectionCode = None, setCurrentCourseTopSectionCount = None, setIsActive = None, setLinkedCourse = None, setLinkedCourseSection = None, setLinkedCourseSectionCode = None, setLinkedCourseTopSectionCount = None, setModifiedTime = None, setRule = None, setRuleCode = None, setScheduleFirst = None, setScheduleLinkedCourseFirst = None, setSectionIDCurrentCourseSelected = None, setSectionIDLinkedCourseSelected = None, setSectionSchedulerCourseConstraintIDClonedFrom = None, setSectionSchedulerCourseConstraintIDClonedTo = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerCourseConstraintID = False, returnCourseID = False, returnCourseIDLinked = False, returnCreatedTime = False, returnCurrentCourseSection = False, returnCurrentCourseSectionCode = False, returnCurrentCourseTopSectionCount = False, returnIsActive = False, returnLinkedCourse = False, returnLinkedCourseSection = False, returnLinkedCourseSectionCode = False, returnLinkedCourseTopSectionCount = False, returnModifiedTime = False, returnRule = False, returnRuleCode = False, returnScheduleFirst = False, returnScheduleLinkedCourseFirst = False, returnSectionIDCurrentCourseSelected = False, returnSectionIDLinkedCourseSelected = False, returnSectionSchedulerCourseConstraintIDClonedFrom = False, returnSectionSchedulerCourseConstraintIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerCourseConstraint/" + str(SectionSchedulerCourseConstraintID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerCourseConstraint(EntityID = 1, setSectionSchedulerCourseConstraintID = None, setCourseID = None, setCourseIDLinked = None, setCreatedTime = None, setCurrentCourseSection = None, setCurrentCourseSectionCode = None, setCurrentCourseTopSectionCount = None, setIsActive = None, setLinkedCourse = None, setLinkedCourseSection = None, setLinkedCourseSectionCode = None, setLinkedCourseTopSectionCount = None, setModifiedTime = None, setRule = None, setRuleCode = None, setScheduleFirst = None, setScheduleLinkedCourseFirst = None, setSectionIDCurrentCourseSelected = None, setSectionIDLinkedCourseSelected = None, setSectionSchedulerCourseConstraintIDClonedFrom = None, setSectionSchedulerCourseConstraintIDClonedTo = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerCourseConstraintID = False, returnCourseID = False, returnCourseIDLinked = False, returnCreatedTime = False, returnCurrentCourseSection = False, returnCurrentCourseSectionCode = False, returnCurrentCourseTopSectionCount = False, returnIsActive = False, returnLinkedCourse = False, returnLinkedCourseSection = False, returnLinkedCourseSectionCode = False, returnLinkedCourseTopSectionCount = False, returnModifiedTime = False, returnRule = False, returnRuleCode = False, returnScheduleFirst = False, returnScheduleLinkedCourseFirst = False, returnSectionIDCurrentCourseSelected = False, returnSectionIDLinkedCourseSelected = False, returnSectionSchedulerCourseConstraintIDClonedFrom = False, returnSectionSchedulerCourseConstraintIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerCourseConstraint/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerCourseConstraint(SectionSchedulerCourseConstraintID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerCourseConstraint/" + str(SectionSchedulerCourseConstraintID), verb = "delete")


def getEverySectionSchedulerDayRotationForMeet(searchConditions = [], EntityID = 1, returnSectionSchedulerDayRotationForMeetID = False, returnCreatedTime = False, returnDayRotationID = False, returnMeetID = False, returnModifiedTime = False, returnSectionSchedulerDayRotationForMeetClonedTo = False, returnSectionSchedulerDayRotationForMeetIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerDayRotationForMeet in the district.

    This function returns a dataframe of every SectionSchedulerDayRotationForMeet in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDayRotationForMeet/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDayRotationForMeet/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerDayRotationForMeet(SectionSchedulerDayRotationForMeetID, EntityID = 1, returnSectionSchedulerDayRotationForMeetID = False, returnCreatedTime = False, returnDayRotationID = False, returnMeetID = False, returnModifiedTime = False, returnSectionSchedulerDayRotationForMeetClonedTo = False, returnSectionSchedulerDayRotationForMeetIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDayRotationForMeet/" + str(SectionSchedulerDayRotationForMeetID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerDayRotationForMeet(SectionSchedulerDayRotationForMeetID, EntityID = 1, setSectionSchedulerDayRotationForMeetID = None, setCreatedTime = None, setDayRotationID = None, setMeetID = None, setModifiedTime = None, setSectionSchedulerDayRotationForMeetClonedTo = None, setSectionSchedulerDayRotationForMeetIDClonedFrom = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerDayRotationForMeetID = False, returnCreatedTime = False, returnDayRotationID = False, returnMeetID = False, returnModifiedTime = False, returnSectionSchedulerDayRotationForMeetClonedTo = False, returnSectionSchedulerDayRotationForMeetIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDayRotationForMeet/" + str(SectionSchedulerDayRotationForMeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerDayRotationForMeet(EntityID = 1, setSectionSchedulerDayRotationForMeetID = None, setCreatedTime = None, setDayRotationID = None, setMeetID = None, setModifiedTime = None, setSectionSchedulerDayRotationForMeetClonedTo = None, setSectionSchedulerDayRotationForMeetIDClonedFrom = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerDayRotationForMeetID = False, returnCreatedTime = False, returnDayRotationID = False, returnMeetID = False, returnModifiedTime = False, returnSectionSchedulerDayRotationForMeetClonedTo = False, returnSectionSchedulerDayRotationForMeetIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDayRotationForMeet/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerDayRotationForMeet(SectionSchedulerDayRotationForMeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDayRotationForMeet/" + str(SectionSchedulerDayRotationForMeetID), verb = "delete")


def getEverySectionSchedulerDisplayPeriodExcludedForCourse(searchConditions = [], EntityID = 1, returnSectionSchedulerDisplayPeriodExcludedForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnSectionSchedulerDisplayPeriodExcludedForCourseIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerDisplayPeriodExcludedForCourse in the district.

    This function returns a dataframe of every SectionSchedulerDisplayPeriodExcludedForCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDisplayPeriodExcludedForCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDisplayPeriodExcludedForCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerDisplayPeriodExcludedForCourse(SectionSchedulerDisplayPeriodExcludedForCourseID, EntityID = 1, returnSectionSchedulerDisplayPeriodExcludedForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnSectionSchedulerDisplayPeriodExcludedForCourseIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDisplayPeriodExcludedForCourse/" + str(SectionSchedulerDisplayPeriodExcludedForCourseID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerDisplayPeriodExcludedForCourse(SectionSchedulerDisplayPeriodExcludedForCourseID, EntityID = 1, setSectionSchedulerDisplayPeriodExcludedForCourseID = None, setCourseID = None, setCreatedTime = None, setDisplayPeriodID = None, setModifiedTime = None, setSectionSchedulerDisplayPeriodExcludedForCourseIDClonedFrom = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerDisplayPeriodExcludedForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnSectionSchedulerDisplayPeriodExcludedForCourseIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDisplayPeriodExcludedForCourse/" + str(SectionSchedulerDisplayPeriodExcludedForCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerDisplayPeriodExcludedForCourse(EntityID = 1, setSectionSchedulerDisplayPeriodExcludedForCourseID = None, setCourseID = None, setCreatedTime = None, setDisplayPeriodID = None, setModifiedTime = None, setSectionSchedulerDisplayPeriodExcludedForCourseIDClonedFrom = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerDisplayPeriodExcludedForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnSectionSchedulerDisplayPeriodExcludedForCourseIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDisplayPeriodExcludedForCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerDisplayPeriodExcludedForCourse(SectionSchedulerDisplayPeriodExcludedForCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerDisplayPeriodExcludedForCourse/" + str(SectionSchedulerDisplayPeriodExcludedForCourseID), verb = "delete")


def getEverySectionSchedulerPattern(searchConditions = [], EntityID = 1, returnSectionSchedulerPatternID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDayRotationCount = False, returnDayRotationSummary = False, returnDescription = False, returnEntityID = False, returnHasDayRotations = False, returnModifiedTime = False, returnSchoolYearID = False, returnSectionSchedulerPatternIDClonedFrom = False, returnSectionSchedulerPatternIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerPattern in the district.

    This function returns a dataframe of every SectionSchedulerPattern in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPattern/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPattern/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerPattern(SectionSchedulerPatternID, EntityID = 1, returnSectionSchedulerPatternID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDayRotationCount = False, returnDayRotationSummary = False, returnDescription = False, returnEntityID = False, returnHasDayRotations = False, returnModifiedTime = False, returnSchoolYearID = False, returnSectionSchedulerPatternIDClonedFrom = False, returnSectionSchedulerPatternIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPattern/" + str(SectionSchedulerPatternID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerPattern(SectionSchedulerPatternID, EntityID = 1, setSectionSchedulerPatternID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDayRotationCount = None, setDayRotationSummary = None, setDescription = None, setEntityID = None, setHasDayRotations = None, setModifiedTime = None, setSchoolYearID = None, setSectionSchedulerPatternIDClonedFrom = None, setSectionSchedulerPatternIDClonedTo = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerPatternID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDayRotationCount = False, returnDayRotationSummary = False, returnDescription = False, returnEntityID = False, returnHasDayRotations = False, returnModifiedTime = False, returnSchoolYearID = False, returnSectionSchedulerPatternIDClonedFrom = False, returnSectionSchedulerPatternIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPattern/" + str(SectionSchedulerPatternID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerPattern(EntityID = 1, setSectionSchedulerPatternID = None, setCode = None, setCodeDescription = None, setCreatedTime = None, setDayRotationCount = None, setDayRotationSummary = None, setDescription = None, setEntityID = None, setHasDayRotations = None, setModifiedTime = None, setSchoolYearID = None, setSectionSchedulerPatternIDClonedFrom = None, setSectionSchedulerPatternIDClonedTo = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerPatternID = False, returnCode = False, returnCodeDescription = False, returnCreatedTime = False, returnDayRotationCount = False, returnDayRotationSummary = False, returnDescription = False, returnEntityID = False, returnHasDayRotations = False, returnModifiedTime = False, returnSchoolYearID = False, returnSectionSchedulerPatternIDClonedFrom = False, returnSectionSchedulerPatternIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPattern/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerPattern(SectionSchedulerPatternID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPattern/" + str(SectionSchedulerPatternID), verb = "delete")


def getEverySectionSchedulerPatternDayRotation(searchConditions = [], EntityID = 1, returnSectionSchedulerPatternDayRotationID = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnSectionSchedulerPatternDayRotationClonedTo = False, returnSectionSchedulerPatternDayRotationIDClonedFrom = False, returnSectionSchedulerPatternID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerPatternDayRotation in the district.

    This function returns a dataframe of every SectionSchedulerPatternDayRotation in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternDayRotation/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternDayRotation/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerPatternDayRotation(SectionSchedulerPatternDayRotationID, EntityID = 1, returnSectionSchedulerPatternDayRotationID = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnSectionSchedulerPatternDayRotationClonedTo = False, returnSectionSchedulerPatternDayRotationIDClonedFrom = False, returnSectionSchedulerPatternID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternDayRotation/" + str(SectionSchedulerPatternDayRotationID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerPatternDayRotation(SectionSchedulerPatternDayRotationID, EntityID = 1, setSectionSchedulerPatternDayRotationID = None, setCreatedTime = None, setDayRotationID = None, setModifiedTime = None, setSectionSchedulerPatternDayRotationClonedTo = None, setSectionSchedulerPatternDayRotationIDClonedFrom = None, setSectionSchedulerPatternID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerPatternDayRotationID = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnSectionSchedulerPatternDayRotationClonedTo = False, returnSectionSchedulerPatternDayRotationIDClonedFrom = False, returnSectionSchedulerPatternID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternDayRotation/" + str(SectionSchedulerPatternDayRotationID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerPatternDayRotation(EntityID = 1, setSectionSchedulerPatternDayRotationID = None, setCreatedTime = None, setDayRotationID = None, setModifiedTime = None, setSectionSchedulerPatternDayRotationClonedTo = None, setSectionSchedulerPatternDayRotationIDClonedFrom = None, setSectionSchedulerPatternID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerPatternDayRotationID = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnSectionSchedulerPatternDayRotationClonedTo = False, returnSectionSchedulerPatternDayRotationIDClonedFrom = False, returnSectionSchedulerPatternID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternDayRotation/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerPatternDayRotation(SectionSchedulerPatternDayRotationID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternDayRotation/" + str(SectionSchedulerPatternDayRotationID), verb = "delete")


def getEverySectionSchedulerPatternExcludedForMeetRequirement(searchConditions = [], EntityID = 1, returnSectionSchedulerPatternExcludedForMeetRequirementID = False, returnCreatedTime = False, returnMeetRequirementID = False, returnModifiedTime = False, returnSectionSchedulerPatternExcludedForMeetRequirementIDClonedFrom = False, returnSectionSchedulerPatternID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerPatternExcludedForMeetRequirement in the district.

    This function returns a dataframe of every SectionSchedulerPatternExcludedForMeetRequirement in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternExcludedForMeetRequirement/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternExcludedForMeetRequirement/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerPatternExcludedForMeetRequirement(SectionSchedulerPatternExcludedForMeetRequirementID, EntityID = 1, returnSectionSchedulerPatternExcludedForMeetRequirementID = False, returnCreatedTime = False, returnMeetRequirementID = False, returnModifiedTime = False, returnSectionSchedulerPatternExcludedForMeetRequirementIDClonedFrom = False, returnSectionSchedulerPatternID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternExcludedForMeetRequirement/" + str(SectionSchedulerPatternExcludedForMeetRequirementID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerPatternExcludedForMeetRequirement(SectionSchedulerPatternExcludedForMeetRequirementID, EntityID = 1, setSectionSchedulerPatternExcludedForMeetRequirementID = None, setCreatedTime = None, setMeetRequirementID = None, setModifiedTime = None, setSectionSchedulerPatternExcludedForMeetRequirementIDClonedFrom = None, setSectionSchedulerPatternID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerPatternExcludedForMeetRequirementID = False, returnCreatedTime = False, returnMeetRequirementID = False, returnModifiedTime = False, returnSectionSchedulerPatternExcludedForMeetRequirementIDClonedFrom = False, returnSectionSchedulerPatternID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternExcludedForMeetRequirement/" + str(SectionSchedulerPatternExcludedForMeetRequirementID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerPatternExcludedForMeetRequirement(EntityID = 1, setSectionSchedulerPatternExcludedForMeetRequirementID = None, setCreatedTime = None, setMeetRequirementID = None, setModifiedTime = None, setSectionSchedulerPatternExcludedForMeetRequirementIDClonedFrom = None, setSectionSchedulerPatternID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerPatternExcludedForMeetRequirementID = False, returnCreatedTime = False, returnMeetRequirementID = False, returnModifiedTime = False, returnSectionSchedulerPatternExcludedForMeetRequirementIDClonedFrom = False, returnSectionSchedulerPatternID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternExcludedForMeetRequirement/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerPatternExcludedForMeetRequirement(SectionSchedulerPatternExcludedForMeetRequirementID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerPatternExcludedForMeetRequirement/" + str(SectionSchedulerPatternExcludedForMeetRequirementID), verb = "delete")


def getEverySectionSchedulerProposedMeet(searchConditions = [], EntityID = 1, returnSectionSchedulerProposedMeetID = False, returnCreatedTime = False, returnDisplayPeriodRotationID = False, returnEndDate = False, returnMeetDisplayPeriodSummary = False, returnModifiedTime = False, returnNumberOfActualConflicts = False, returnNumberOfEstimatedConflicts = False, returnNumberOfProposedMeetCourseConflicts = False, returnNumberOfProposedMeetRoomAndStaffConflicts = False, returnNumberOfProposedMeetRoomConflicts = False, returnNumberOfProposedMeetStaffConflicts = False, returnPrimaryStaffMeetFullNameLFM = False, returnRank = False, returnRankValue = False, returnRoomID = False, returnSectionLengthID = False, returnSectionSchedulerRunAnalysisID = False, returnStartDate = False, returnSumTotalOfMaximumStudentCountForScheduledSections = False, returnSumTotalOfOptimalStudentCountForScheduledSections = False, returnTotalActualConflictsPointsEarned = False, returnTotalDisplayPeriodPointsEarned = False, returnTotalEstimatedConflictsPointsEarned = False, returnTotalRoomPointsEarned = False, returnTotalStaffPointsEarned = False, returnTotalSumOfMaximumStudentCountForScheduledSectionsPointsEarned = False, returnTotalSumOfOptimalStudentCountForScheduledSectionsPointsEarned = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerProposedMeet in the district.

    This function returns a dataframe of every SectionSchedulerProposedMeet in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeet/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeet/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerProposedMeet(SectionSchedulerProposedMeetID, EntityID = 1, returnSectionSchedulerProposedMeetID = False, returnCreatedTime = False, returnDisplayPeriodRotationID = False, returnEndDate = False, returnMeetDisplayPeriodSummary = False, returnModifiedTime = False, returnNumberOfActualConflicts = False, returnNumberOfEstimatedConflicts = False, returnNumberOfProposedMeetCourseConflicts = False, returnNumberOfProposedMeetRoomAndStaffConflicts = False, returnNumberOfProposedMeetRoomConflicts = False, returnNumberOfProposedMeetStaffConflicts = False, returnPrimaryStaffMeetFullNameLFM = False, returnRank = False, returnRankValue = False, returnRoomID = False, returnSectionLengthID = False, returnSectionSchedulerRunAnalysisID = False, returnStartDate = False, returnSumTotalOfMaximumStudentCountForScheduledSections = False, returnSumTotalOfOptimalStudentCountForScheduledSections = False, returnTotalActualConflictsPointsEarned = False, returnTotalDisplayPeriodPointsEarned = False, returnTotalEstimatedConflictsPointsEarned = False, returnTotalRoomPointsEarned = False, returnTotalStaffPointsEarned = False, returnTotalSumOfMaximumStudentCountForScheduledSectionsPointsEarned = False, returnTotalSumOfOptimalStudentCountForScheduledSectionsPointsEarned = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeet/" + str(SectionSchedulerProposedMeetID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerProposedMeet(SectionSchedulerProposedMeetID, EntityID = 1, setSectionSchedulerProposedMeetID = None, setCreatedTime = None, setDisplayPeriodRotationID = None, setEndDate = None, setMeetDisplayPeriodSummary = None, setModifiedTime = None, setNumberOfActualConflicts = None, setNumberOfEstimatedConflicts = None, setNumberOfProposedMeetCourseConflicts = None, setNumberOfProposedMeetRoomAndStaffConflicts = None, setNumberOfProposedMeetRoomConflicts = None, setNumberOfProposedMeetStaffConflicts = None, setPrimaryStaffMeetFullNameLFM = None, setRank = None, setRankValue = None, setRoomID = None, setSectionLengthID = None, setSectionSchedulerRunAnalysisID = None, setStartDate = None, setSumTotalOfMaximumStudentCountForScheduledSections = None, setSumTotalOfOptimalStudentCountForScheduledSections = None, setTotalActualConflictsPointsEarned = None, setTotalDisplayPeriodPointsEarned = None, setTotalEstimatedConflictsPointsEarned = None, setTotalRoomPointsEarned = None, setTotalStaffPointsEarned = None, setTotalSumOfMaximumStudentCountForScheduledSectionsPointsEarned = None, setTotalSumOfOptimalStudentCountForScheduledSectionsPointsEarned = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerProposedMeetID = False, returnCreatedTime = False, returnDisplayPeriodRotationID = False, returnEndDate = False, returnMeetDisplayPeriodSummary = False, returnModifiedTime = False, returnNumberOfActualConflicts = False, returnNumberOfEstimatedConflicts = False, returnNumberOfProposedMeetCourseConflicts = False, returnNumberOfProposedMeetRoomAndStaffConflicts = False, returnNumberOfProposedMeetRoomConflicts = False, returnNumberOfProposedMeetStaffConflicts = False, returnPrimaryStaffMeetFullNameLFM = False, returnRank = False, returnRankValue = False, returnRoomID = False, returnSectionLengthID = False, returnSectionSchedulerRunAnalysisID = False, returnStartDate = False, returnSumTotalOfMaximumStudentCountForScheduledSections = False, returnSumTotalOfOptimalStudentCountForScheduledSections = False, returnTotalActualConflictsPointsEarned = False, returnTotalDisplayPeriodPointsEarned = False, returnTotalEstimatedConflictsPointsEarned = False, returnTotalRoomPointsEarned = False, returnTotalStaffPointsEarned = False, returnTotalSumOfMaximumStudentCountForScheduledSectionsPointsEarned = False, returnTotalSumOfOptimalStudentCountForScheduledSectionsPointsEarned = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeet/" + str(SectionSchedulerProposedMeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerProposedMeet(EntityID = 1, setSectionSchedulerProposedMeetID = None, setCreatedTime = None, setDisplayPeriodRotationID = None, setEndDate = None, setMeetDisplayPeriodSummary = None, setModifiedTime = None, setNumberOfActualConflicts = None, setNumberOfEstimatedConflicts = None, setNumberOfProposedMeetCourseConflicts = None, setNumberOfProposedMeetRoomAndStaffConflicts = None, setNumberOfProposedMeetRoomConflicts = None, setNumberOfProposedMeetStaffConflicts = None, setPrimaryStaffMeetFullNameLFM = None, setRank = None, setRankValue = None, setRoomID = None, setSectionLengthID = None, setSectionSchedulerRunAnalysisID = None, setStartDate = None, setSumTotalOfMaximumStudentCountForScheduledSections = None, setSumTotalOfOptimalStudentCountForScheduledSections = None, setTotalActualConflictsPointsEarned = None, setTotalDisplayPeriodPointsEarned = None, setTotalEstimatedConflictsPointsEarned = None, setTotalRoomPointsEarned = None, setTotalStaffPointsEarned = None, setTotalSumOfMaximumStudentCountForScheduledSectionsPointsEarned = None, setTotalSumOfOptimalStudentCountForScheduledSectionsPointsEarned = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerProposedMeetID = False, returnCreatedTime = False, returnDisplayPeriodRotationID = False, returnEndDate = False, returnMeetDisplayPeriodSummary = False, returnModifiedTime = False, returnNumberOfActualConflicts = False, returnNumberOfEstimatedConflicts = False, returnNumberOfProposedMeetCourseConflicts = False, returnNumberOfProposedMeetRoomAndStaffConflicts = False, returnNumberOfProposedMeetRoomConflicts = False, returnNumberOfProposedMeetStaffConflicts = False, returnPrimaryStaffMeetFullNameLFM = False, returnRank = False, returnRankValue = False, returnRoomID = False, returnSectionLengthID = False, returnSectionSchedulerRunAnalysisID = False, returnStartDate = False, returnSumTotalOfMaximumStudentCountForScheduledSections = False, returnSumTotalOfOptimalStudentCountForScheduledSections = False, returnTotalActualConflictsPointsEarned = False, returnTotalDisplayPeriodPointsEarned = False, returnTotalEstimatedConflictsPointsEarned = False, returnTotalRoomPointsEarned = False, returnTotalStaffPointsEarned = False, returnTotalSumOfMaximumStudentCountForScheduledSectionsPointsEarned = False, returnTotalSumOfOptimalStudentCountForScheduledSectionsPointsEarned = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeet/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerProposedMeet(SectionSchedulerProposedMeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeet/" + str(SectionSchedulerProposedMeetID), verb = "delete")


def getEverySectionSchedulerProposedMeetConflict(searchConditions = [], EntityID = 1, returnSectionSchedulerProposedMeetConflictID = False, returnConflictType = False, returnConflictTypeCode = False, returnCourseID = False, returnCreatedTime = False, returnDescription = False, returnModifiedTime = False, returnName = False, returnNumberOfActualConflicts = False, returnNumberOfCommonRequests = False, returnNumberOfEstimatedConflicts = False, returnSectionSchedulerProposedMeetID = False, returnSeverity = False, returnSeverityCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerProposedMeetConflict in the district.

    This function returns a dataframe of every SectionSchedulerProposedMeetConflict in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetConflict/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetConflict/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerProposedMeetConflict(SectionSchedulerProposedMeetConflictID, EntityID = 1, returnSectionSchedulerProposedMeetConflictID = False, returnConflictType = False, returnConflictTypeCode = False, returnCourseID = False, returnCreatedTime = False, returnDescription = False, returnModifiedTime = False, returnName = False, returnNumberOfActualConflicts = False, returnNumberOfCommonRequests = False, returnNumberOfEstimatedConflicts = False, returnSectionSchedulerProposedMeetID = False, returnSeverity = False, returnSeverityCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetConflict/" + str(SectionSchedulerProposedMeetConflictID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerProposedMeetConflict(SectionSchedulerProposedMeetConflictID, EntityID = 1, setSectionSchedulerProposedMeetConflictID = None, setConflictType = None, setConflictTypeCode = None, setCourseID = None, setCreatedTime = None, setDescription = None, setModifiedTime = None, setName = None, setNumberOfActualConflicts = None, setNumberOfCommonRequests = None, setNumberOfEstimatedConflicts = None, setSectionSchedulerProposedMeetID = None, setSeverity = None, setSeverityCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerProposedMeetConflictID = False, returnConflictType = False, returnConflictTypeCode = False, returnCourseID = False, returnCreatedTime = False, returnDescription = False, returnModifiedTime = False, returnName = False, returnNumberOfActualConflicts = False, returnNumberOfCommonRequests = False, returnNumberOfEstimatedConflicts = False, returnSectionSchedulerProposedMeetID = False, returnSeverity = False, returnSeverityCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetConflict/" + str(SectionSchedulerProposedMeetConflictID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerProposedMeetConflict(EntityID = 1, setSectionSchedulerProposedMeetConflictID = None, setConflictType = None, setConflictTypeCode = None, setCourseID = None, setCreatedTime = None, setDescription = None, setModifiedTime = None, setName = None, setNumberOfActualConflicts = None, setNumberOfCommonRequests = None, setNumberOfEstimatedConflicts = None, setSectionSchedulerProposedMeetID = None, setSeverity = None, setSeverityCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerProposedMeetConflictID = False, returnConflictType = False, returnConflictTypeCode = False, returnCourseID = False, returnCreatedTime = False, returnDescription = False, returnModifiedTime = False, returnName = False, returnNumberOfActualConflicts = False, returnNumberOfCommonRequests = False, returnNumberOfEstimatedConflicts = False, returnSectionSchedulerProposedMeetID = False, returnSeverity = False, returnSeverityCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetConflict/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerProposedMeetConflict(SectionSchedulerProposedMeetConflictID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetConflict/" + str(SectionSchedulerProposedMeetConflictID), verb = "delete")


def getEverySectionSchedulerProposedMeetDisplayPeriod(searchConditions = [], EntityID = 1, returnSectionSchedulerProposedMeetDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnSectionSchedulerProposedMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerProposedMeetDisplayPeriod in the district.

    This function returns a dataframe of every SectionSchedulerProposedMeetDisplayPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetDisplayPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerProposedMeetDisplayPeriod(SectionSchedulerProposedMeetDisplayPeriodID, EntityID = 1, returnSectionSchedulerProposedMeetDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnSectionSchedulerProposedMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetDisplayPeriod/" + str(SectionSchedulerProposedMeetDisplayPeriodID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerProposedMeetDisplayPeriod(SectionSchedulerProposedMeetDisplayPeriodID, EntityID = 1, setSectionSchedulerProposedMeetDisplayPeriodID = None, setCreatedTime = None, setDisplayPeriodID = None, setModifiedTime = None, setSectionSchedulerProposedMeetID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerProposedMeetDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnSectionSchedulerProposedMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetDisplayPeriod/" + str(SectionSchedulerProposedMeetDisplayPeriodID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerProposedMeetDisplayPeriod(EntityID = 1, setSectionSchedulerProposedMeetDisplayPeriodID = None, setCreatedTime = None, setDisplayPeriodID = None, setModifiedTime = None, setSectionSchedulerProposedMeetID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerProposedMeetDisplayPeriodID = False, returnCreatedTime = False, returnDisplayPeriodID = False, returnModifiedTime = False, returnSectionSchedulerProposedMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetDisplayPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerProposedMeetDisplayPeriod(SectionSchedulerProposedMeetDisplayPeriodID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedMeetDisplayPeriod/" + str(SectionSchedulerProposedMeetDisplayPeriodID), verb = "delete")


def getEverySectionSchedulerProposedStaffMeet(searchConditions = [], EntityID = 1, returnSectionSchedulerProposedStaffMeetID = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnIsPrimary = False, returnModifiedTime = False, returnSectionSchedulerProposedMeetID = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerProposedStaffMeet in the district.

    This function returns a dataframe of every SectionSchedulerProposedStaffMeet in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedStaffMeet/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedStaffMeet/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerProposedStaffMeet(SectionSchedulerProposedStaffMeetID, EntityID = 1, returnSectionSchedulerProposedStaffMeetID = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnIsPrimary = False, returnModifiedTime = False, returnSectionSchedulerProposedMeetID = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedStaffMeet/" + str(SectionSchedulerProposedStaffMeetID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerProposedStaffMeet(SectionSchedulerProposedStaffMeetID, EntityID = 1, setSectionSchedulerProposedStaffMeetID = None, setCreatedTime = None, setEffectiveEndDate = None, setEffectiveStartDate = None, setIsPrimary = None, setModifiedTime = None, setSectionSchedulerProposedMeetID = None, setStaffID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerProposedStaffMeetID = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnIsPrimary = False, returnModifiedTime = False, returnSectionSchedulerProposedMeetID = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedStaffMeet/" + str(SectionSchedulerProposedStaffMeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerProposedStaffMeet(EntityID = 1, setSectionSchedulerProposedStaffMeetID = None, setCreatedTime = None, setEffectiveEndDate = None, setEffectiveStartDate = None, setIsPrimary = None, setModifiedTime = None, setSectionSchedulerProposedMeetID = None, setStaffID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerProposedStaffMeetID = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnIsPrimary = False, returnModifiedTime = False, returnSectionSchedulerProposedMeetID = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedStaffMeet/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerProposedStaffMeet(SectionSchedulerProposedStaffMeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerProposedStaffMeet/" + str(SectionSchedulerProposedStaffMeetID), verb = "delete")


def getEverySectionSchedulerRoomTypeForCourse(searchConditions = [], EntityID = 1, returnSectionSchedulerRoomTypeForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnRoomTypeID = False, returnSectionSchedulerRoomTypeForCourseIDClonedFrom = False, returnSectionSchedulerRoomTypeForCourseIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerRoomTypeForCourse in the district.

    This function returns a dataframe of every SectionSchedulerRoomTypeForCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRoomTypeForCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRoomTypeForCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerRoomTypeForCourse(SectionSchedulerRoomTypeForCourseID, EntityID = 1, returnSectionSchedulerRoomTypeForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnRoomTypeID = False, returnSectionSchedulerRoomTypeForCourseIDClonedFrom = False, returnSectionSchedulerRoomTypeForCourseIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRoomTypeForCourse/" + str(SectionSchedulerRoomTypeForCourseID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerRoomTypeForCourse(SectionSchedulerRoomTypeForCourseID, EntityID = 1, setSectionSchedulerRoomTypeForCourseID = None, setCourseID = None, setCreatedTime = None, setModifiedTime = None, setRoomTypeID = None, setSectionSchedulerRoomTypeForCourseIDClonedFrom = None, setSectionSchedulerRoomTypeForCourseIDClonedTo = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerRoomTypeForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnRoomTypeID = False, returnSectionSchedulerRoomTypeForCourseIDClonedFrom = False, returnSectionSchedulerRoomTypeForCourseIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRoomTypeForCourse/" + str(SectionSchedulerRoomTypeForCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerRoomTypeForCourse(EntityID = 1, setSectionSchedulerRoomTypeForCourseID = None, setCourseID = None, setCreatedTime = None, setModifiedTime = None, setRoomTypeID = None, setSectionSchedulerRoomTypeForCourseIDClonedFrom = None, setSectionSchedulerRoomTypeForCourseIDClonedTo = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerRoomTypeForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnRoomTypeID = False, returnSectionSchedulerRoomTypeForCourseIDClonedFrom = False, returnSectionSchedulerRoomTypeForCourseIDClonedTo = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRoomTypeForCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerRoomTypeForCourse(SectionSchedulerRoomTypeForCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRoomTypeForCourse/" + str(SectionSchedulerRoomTypeForCourseID), verb = "delete")


def getEverySectionSchedulerRunAnalysis(searchConditions = [], EntityID = 1, returnSectionSchedulerRunAnalysisID = False, returnAcceptedMeetReverted = False, returnAnalysisDuration = False, returnAnalysisMethod = False, returnAnalysisMethodCode = False, returnAnalyzeDayRotations = False, returnAnalyzeMeetDisplayPeriods = False, returnAnalyzeRoom = False, returnAnalyzeSectionLength = False, returnAnalyzeStaffMeets = False, returnCountOfSectionSchedulerProposedMeetRecords = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnEntityID = False, returnExcludeMeetsPreviouslyScheduled = False, returnMeetID = False, returnModifiedTime = False, returnPageStateID = False, returnRunReason = False, returnSchoolYearID = False, returnSectionSchedulerProposedMeetIDAccepted = False, returnStartTimeAnalysis = False, returnTotalActualConflictsPointsPossible = False, returnTotalDisplayPeriodPointsPossible = False, returnTotalEstimatedConflictsPointsPossible = False, returnTotalRoomPointsPossible = False, returnTotalStaffPointsPossible = False, returnTotalSumOfMaximumStudentCountForScheduledSectionsPointsPossible = False, returnTotalSumOfOptimalStudentCountForScheduledSectionsPointsPossible = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerRunAnalysis in the district.

    This function returns a dataframe of every SectionSchedulerRunAnalysis in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRunAnalysis/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRunAnalysis/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerRunAnalysis(SectionSchedulerRunAnalysisID, EntityID = 1, returnSectionSchedulerRunAnalysisID = False, returnAcceptedMeetReverted = False, returnAnalysisDuration = False, returnAnalysisMethod = False, returnAnalysisMethodCode = False, returnAnalyzeDayRotations = False, returnAnalyzeMeetDisplayPeriods = False, returnAnalyzeRoom = False, returnAnalyzeSectionLength = False, returnAnalyzeStaffMeets = False, returnCountOfSectionSchedulerProposedMeetRecords = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnEntityID = False, returnExcludeMeetsPreviouslyScheduled = False, returnMeetID = False, returnModifiedTime = False, returnPageStateID = False, returnRunReason = False, returnSchoolYearID = False, returnSectionSchedulerProposedMeetIDAccepted = False, returnStartTimeAnalysis = False, returnTotalActualConflictsPointsPossible = False, returnTotalDisplayPeriodPointsPossible = False, returnTotalEstimatedConflictsPointsPossible = False, returnTotalRoomPointsPossible = False, returnTotalStaffPointsPossible = False, returnTotalSumOfMaximumStudentCountForScheduledSectionsPointsPossible = False, returnTotalSumOfOptimalStudentCountForScheduledSectionsPointsPossible = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRunAnalysis/" + str(SectionSchedulerRunAnalysisID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerRunAnalysis(SectionSchedulerRunAnalysisID, EntityID = 1, setSectionSchedulerRunAnalysisID = None, setAcceptedMeetReverted = None, setAnalysisDuration = None, setAnalysisMethod = None, setAnalysisMethodCode = None, setAnalyzeDayRotations = None, setAnalyzeMeetDisplayPeriods = None, setAnalyzeRoom = None, setAnalyzeSectionLength = None, setAnalyzeStaffMeets = None, setCountOfSectionSchedulerProposedMeetRecords = None, setCreatedTime = None, setEndTimeAnalysis = None, setEntityID = None, setExcludeMeetsPreviouslyScheduled = None, setMeetID = None, setModifiedTime = None, setPageStateID = None, setRunReason = None, setSchoolYearID = None, setSectionSchedulerProposedMeetIDAccepted = None, setStartTimeAnalysis = None, setTotalActualConflictsPointsPossible = None, setTotalDisplayPeriodPointsPossible = None, setTotalEstimatedConflictsPointsPossible = None, setTotalRoomPointsPossible = None, setTotalStaffPointsPossible = None, setTotalSumOfMaximumStudentCountForScheduledSectionsPointsPossible = None, setTotalSumOfOptimalStudentCountForScheduledSectionsPointsPossible = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUserIDPerformer = None, returnSectionSchedulerRunAnalysisID = False, returnAcceptedMeetReverted = False, returnAnalysisDuration = False, returnAnalysisMethod = False, returnAnalysisMethodCode = False, returnAnalyzeDayRotations = False, returnAnalyzeMeetDisplayPeriods = False, returnAnalyzeRoom = False, returnAnalyzeSectionLength = False, returnAnalyzeStaffMeets = False, returnCountOfSectionSchedulerProposedMeetRecords = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnEntityID = False, returnExcludeMeetsPreviouslyScheduled = False, returnMeetID = False, returnModifiedTime = False, returnPageStateID = False, returnRunReason = False, returnSchoolYearID = False, returnSectionSchedulerProposedMeetIDAccepted = False, returnStartTimeAnalysis = False, returnTotalActualConflictsPointsPossible = False, returnTotalDisplayPeriodPointsPossible = False, returnTotalEstimatedConflictsPointsPossible = False, returnTotalRoomPointsPossible = False, returnTotalStaffPointsPossible = False, returnTotalSumOfMaximumStudentCountForScheduledSectionsPointsPossible = False, returnTotalSumOfOptimalStudentCountForScheduledSectionsPointsPossible = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRunAnalysis/" + str(SectionSchedulerRunAnalysisID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerRunAnalysis(EntityID = 1, setSectionSchedulerRunAnalysisID = None, setAcceptedMeetReverted = None, setAnalysisDuration = None, setAnalysisMethod = None, setAnalysisMethodCode = None, setAnalyzeDayRotations = None, setAnalyzeMeetDisplayPeriods = None, setAnalyzeRoom = None, setAnalyzeSectionLength = None, setAnalyzeStaffMeets = None, setCountOfSectionSchedulerProposedMeetRecords = None, setCreatedTime = None, setEndTimeAnalysis = None, setEntityID = None, setExcludeMeetsPreviouslyScheduled = None, setMeetID = None, setModifiedTime = None, setPageStateID = None, setRunReason = None, setSchoolYearID = None, setSectionSchedulerProposedMeetIDAccepted = None, setStartTimeAnalysis = None, setTotalActualConflictsPointsPossible = None, setTotalDisplayPeriodPointsPossible = None, setTotalEstimatedConflictsPointsPossible = None, setTotalRoomPointsPossible = None, setTotalStaffPointsPossible = None, setTotalSumOfMaximumStudentCountForScheduledSectionsPointsPossible = None, setTotalSumOfOptimalStudentCountForScheduledSectionsPointsPossible = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setUserIDPerformer = None, returnSectionSchedulerRunAnalysisID = False, returnAcceptedMeetReverted = False, returnAnalysisDuration = False, returnAnalysisMethod = False, returnAnalysisMethodCode = False, returnAnalyzeDayRotations = False, returnAnalyzeMeetDisplayPeriods = False, returnAnalyzeRoom = False, returnAnalyzeSectionLength = False, returnAnalyzeStaffMeets = False, returnCountOfSectionSchedulerProposedMeetRecords = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnEntityID = False, returnExcludeMeetsPreviouslyScheduled = False, returnMeetID = False, returnModifiedTime = False, returnPageStateID = False, returnRunReason = False, returnSchoolYearID = False, returnSectionSchedulerProposedMeetIDAccepted = False, returnStartTimeAnalysis = False, returnTotalActualConflictsPointsPossible = False, returnTotalDisplayPeriodPointsPossible = False, returnTotalEstimatedConflictsPointsPossible = False, returnTotalRoomPointsPossible = False, returnTotalStaffPointsPossible = False, returnTotalSumOfMaximumStudentCountForScheduledSectionsPointsPossible = False, returnTotalSumOfOptimalStudentCountForScheduledSectionsPointsPossible = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnUserIDPerformer = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRunAnalysis/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerRunAnalysis(SectionSchedulerRunAnalysisID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerRunAnalysis/" + str(SectionSchedulerRunAnalysisID), verb = "delete")


def getEverySectionSchedulerStaffForCourse(searchConditions = [], EntityID = 1, returnSectionSchedulerStaffForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionSchedulerStaffForCourseIDClonedFrom = False, returnSectionSchedulerStaffForCourseIDClonedTo = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulerStaffForCourse in the district.

    This function returns a dataframe of every SectionSchedulerStaffForCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerStaffForCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerStaffForCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulerStaffForCourse(SectionSchedulerStaffForCourseID, EntityID = 1, returnSectionSchedulerStaffForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionSchedulerStaffForCourseIDClonedFrom = False, returnSectionSchedulerStaffForCourseIDClonedTo = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerStaffForCourse/" + str(SectionSchedulerStaffForCourseID), verb = "get", return_params_list = return_params)

def modifySectionSchedulerStaffForCourse(SectionSchedulerStaffForCourseID, EntityID = 1, setSectionSchedulerStaffForCourseID = None, setCourseID = None, setCreatedTime = None, setModifiedTime = None, setSectionSchedulerStaffForCourseIDClonedFrom = None, setSectionSchedulerStaffForCourseIDClonedTo = None, setStaffID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerStaffForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionSchedulerStaffForCourseIDClonedFrom = False, returnSectionSchedulerStaffForCourseIDClonedTo = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerStaffForCourse/" + str(SectionSchedulerStaffForCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulerStaffForCourse(EntityID = 1, setSectionSchedulerStaffForCourseID = None, setCourseID = None, setCreatedTime = None, setModifiedTime = None, setSectionSchedulerStaffForCourseIDClonedFrom = None, setSectionSchedulerStaffForCourseIDClonedTo = None, setStaffID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulerStaffForCourseID = False, returnCourseID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionSchedulerStaffForCourseIDClonedFrom = False, returnSectionSchedulerStaffForCourseIDClonedTo = False, returnStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerStaffForCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulerStaffForCourse(SectionSchedulerStaffForCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulerStaffForCourse/" + str(SectionSchedulerStaffForCourseID), verb = "delete")


def getEverySectionSchedulingCategory(searchConditions = [], EntityID = 1, returnSectionSchedulingCategoryID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingCategoryID = False, returnSectionID = False, returnSectionSchedulingCategoryIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulingCategory in the district.

    This function returns a dataframe of every SectionSchedulingCategory in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingCategory/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingCategory/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulingCategory(SectionSchedulingCategoryID, EntityID = 1, returnSectionSchedulingCategoryID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingCategoryID = False, returnSectionID = False, returnSectionSchedulingCategoryIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingCategory/" + str(SectionSchedulingCategoryID), verb = "get", return_params_list = return_params)

def modifySectionSchedulingCategory(SectionSchedulingCategoryID, EntityID = 1, setSectionSchedulingCategoryID = None, setCreatedTime = None, setModifiedTime = None, setSchedulingCategoryID = None, setSectionID = None, setSectionSchedulingCategoryIDClonedFrom = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulingCategoryID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingCategoryID = False, returnSectionID = False, returnSectionSchedulingCategoryIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingCategory/" + str(SectionSchedulingCategoryID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulingCategory(EntityID = 1, setSectionSchedulingCategoryID = None, setCreatedTime = None, setModifiedTime = None, setSchedulingCategoryID = None, setSectionID = None, setSectionSchedulingCategoryIDClonedFrom = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulingCategoryID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingCategoryID = False, returnSectionID = False, returnSectionSchedulingCategoryIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingCategory/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulingCategory(SectionSchedulingCategoryID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingCategory/" + str(SectionSchedulingCategoryID), verb = "delete")


def getEverySectionSchedulingTeam(searchConditions = [], EntityID = 1, returnSectionSchedulingTeamID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingTeamID = False, returnSectionID = False, returnSectionSchedulingTeamIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every SectionSchedulingTeam in the district.

    This function returns a dataframe of every SectionSchedulingTeam in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingTeam/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingTeam/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getSectionSchedulingTeam(SectionSchedulingTeamID, EntityID = 1, returnSectionSchedulingTeamID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingTeamID = False, returnSectionID = False, returnSectionSchedulingTeamIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingTeam/" + str(SectionSchedulingTeamID), verb = "get", return_params_list = return_params)

def modifySectionSchedulingTeam(SectionSchedulingTeamID, EntityID = 1, setSectionSchedulingTeamID = None, setCreatedTime = None, setModifiedTime = None, setSchedulingTeamID = None, setSectionID = None, setSectionSchedulingTeamIDClonedFrom = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulingTeamID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingTeamID = False, returnSectionID = False, returnSectionSchedulingTeamIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingTeam/" + str(SectionSchedulingTeamID), verb = "post", return_params_list = return_params, payload = payload_params)

def createSectionSchedulingTeam(EntityID = 1, setSectionSchedulingTeamID = None, setCreatedTime = None, setModifiedTime = None, setSchedulingTeamID = None, setSectionID = None, setSectionSchedulingTeamIDClonedFrom = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnSectionSchedulingTeamID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingTeamID = False, returnSectionID = False, returnSectionSchedulingTeamIDClonedFrom = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingTeam/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteSectionSchedulingTeam(SectionSchedulingTeamID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/SectionSchedulingTeam/" + str(SectionSchedulingTeamID), verb = "delete")


def getEveryStaffMeet(searchConditions = [], EntityID = 1, returnStaffMeetID = False, returnApplyClosedGradingPeriodGradeChangePermission = False, returnAssignmentCount = False, returnCanMakeClosedGradingPeriodGradeChange = False, returnClosedGradingPeriodGradeChangeCount = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnGradebookLastAccessedTime = False, returnHasAttendanceAccess = False, returnHasAttendanceAccessAsOfDate = False, returnHasGradebookAccess = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsStaffCertified = False, returnIsSubstitute = False, returnLockStaffFromSectionScheduler = False, returnMeetID = False, returnMeetIsCurrent = False, returnMeetsToday = False, returnModifiedTime = False, returnNameMeetDescription = False, returnScheduledBySectionScheduler = False, returnSchoolYearID = False, returnSectionID = False, returnStaffID = False, returnStaffMeetIDClonedFrom = False, returnStaffMeetIDSubstituteFor = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StaffMeet in the district.

    This function returns a dataframe of every StaffMeet in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffMeet/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffMeet/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStaffMeet(StaffMeetID, EntityID = 1, returnStaffMeetID = False, returnApplyClosedGradingPeriodGradeChangePermission = False, returnAssignmentCount = False, returnCanMakeClosedGradingPeriodGradeChange = False, returnClosedGradingPeriodGradeChangeCount = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnGradebookLastAccessedTime = False, returnHasAttendanceAccess = False, returnHasAttendanceAccessAsOfDate = False, returnHasGradebookAccess = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsStaffCertified = False, returnIsSubstitute = False, returnLockStaffFromSectionScheduler = False, returnMeetID = False, returnMeetIsCurrent = False, returnMeetsToday = False, returnModifiedTime = False, returnNameMeetDescription = False, returnScheduledBySectionScheduler = False, returnSchoolYearID = False, returnSectionID = False, returnStaffID = False, returnStaffMeetIDClonedFrom = False, returnStaffMeetIDSubstituteFor = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffMeet/" + str(StaffMeetID), verb = "get", return_params_list = return_params)

def modifyStaffMeet(StaffMeetID, EntityID = 1, setStaffMeetID = None, setApplyClosedGradingPeriodGradeChangePermission = None, setAssignmentCount = None, setCanMakeClosedGradingPeriodGradeChange = None, setClosedGradingPeriodGradeChangeCount = None, setCreatedTime = None, setEffectiveEndDate = None, setEffectiveStartDate = None, setGradebookLastAccessedTime = None, setHasAttendanceAccess = None, setHasAttendanceAccessAsOfDate = None, setHasGradebookAccess = None, setIsLongTermSubstitute = None, setIsPrimary = None, setIsStaffCertified = None, setIsSubstitute = None, setLockStaffFromSectionScheduler = None, setMeetID = None, setMeetIsCurrent = None, setMeetsToday = None, setModifiedTime = None, setNameMeetDescription = None, setScheduledBySectionScheduler = None, setSchoolYearID = None, setSectionID = None, setStaffID = None, setStaffMeetIDClonedFrom = None, setStaffMeetIDSubstituteFor = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferingEntity = None, returnStaffMeetID = False, returnApplyClosedGradingPeriodGradeChangePermission = False, returnAssignmentCount = False, returnCanMakeClosedGradingPeriodGradeChange = False, returnClosedGradingPeriodGradeChangeCount = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnGradebookLastAccessedTime = False, returnHasAttendanceAccess = False, returnHasAttendanceAccessAsOfDate = False, returnHasGradebookAccess = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsStaffCertified = False, returnIsSubstitute = False, returnLockStaffFromSectionScheduler = False, returnMeetID = False, returnMeetIsCurrent = False, returnMeetsToday = False, returnModifiedTime = False, returnNameMeetDescription = False, returnScheduledBySectionScheduler = False, returnSchoolYearID = False, returnSectionID = False, returnStaffID = False, returnStaffMeetIDClonedFrom = False, returnStaffMeetIDSubstituteFor = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffMeet/" + str(StaffMeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStaffMeet(EntityID = 1, setStaffMeetID = None, setApplyClosedGradingPeriodGradeChangePermission = None, setAssignmentCount = None, setCanMakeClosedGradingPeriodGradeChange = None, setClosedGradingPeriodGradeChangeCount = None, setCreatedTime = None, setEffectiveEndDate = None, setEffectiveStartDate = None, setGradebookLastAccessedTime = None, setHasAttendanceAccess = None, setHasAttendanceAccessAsOfDate = None, setHasGradebookAccess = None, setIsLongTermSubstitute = None, setIsPrimary = None, setIsStaffCertified = None, setIsSubstitute = None, setLockStaffFromSectionScheduler = None, setMeetID = None, setMeetIsCurrent = None, setMeetsToday = None, setModifiedTime = None, setNameMeetDescription = None, setScheduledBySectionScheduler = None, setSchoolYearID = None, setSectionID = None, setStaffID = None, setStaffMeetIDClonedFrom = None, setStaffMeetIDSubstituteFor = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferingEntity = None, returnStaffMeetID = False, returnApplyClosedGradingPeriodGradeChangePermission = False, returnAssignmentCount = False, returnCanMakeClosedGradingPeriodGradeChange = False, returnClosedGradingPeriodGradeChangeCount = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnGradebookLastAccessedTime = False, returnHasAttendanceAccess = False, returnHasAttendanceAccessAsOfDate = False, returnHasGradebookAccess = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsStaffCertified = False, returnIsSubstitute = False, returnLockStaffFromSectionScheduler = False, returnMeetID = False, returnMeetIsCurrent = False, returnMeetsToday = False, returnModifiedTime = False, returnNameMeetDescription = False, returnScheduledBySectionScheduler = False, returnSchoolYearID = False, returnSectionID = False, returnStaffID = False, returnStaffMeetIDClonedFrom = False, returnStaffMeetIDSubstituteFor = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffMeet/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStaffMeet(StaffMeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffMeet/" + str(StaffMeetID), verb = "delete")


def getEveryStaffStudent(searchConditions = [], EntityID = 1, returnStudentID = False, returnEntityID = False, returnSchoolYearID = False, returnStaffID = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StaffStudent in the district.

    This function returns a dataframe of every StaffStudent in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffStudent/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffStudent/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStaffStudent(StudentID, EntityID = 1, returnStudentID = False, returnEntityID = False, returnSchoolYearID = False, returnStaffID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffStudent/" + str(StudentID), verb = "get", return_params_list = return_params)

def modifyStaffStudent(StudentID, EntityID = 1, setStudentID = None, setEntityID = None, setSchoolYearID = None, setStaffID = None, returnStudentID = False, returnEntityID = False, returnSchoolYearID = False, returnStaffID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffStudent/" + str(StudentID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStaffStudent(EntityID = 1, setStudentID = None, setEntityID = None, setSchoolYearID = None, setStaffID = None, returnStudentID = False, returnEntityID = False, returnSchoolYearID = False, returnStaffID = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffStudent/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStaffStudent(StudentID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StaffStudent/" + str(StudentID), verb = "delete")


def getEveryStudentAutoSchedulerCourse(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerCourseID = False, returnActiveSections = False, returnCategoryCode = False, returnConflictedRequestPercent = False, returnCourseCode = False, returnCourseDescription = False, returnCourseEntityCode = False, returnCourseEntityID = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseSubjectCode = False, returnCreatedTime = False, returnDepartmentCode = False, returnIsActive = False, returnIsRequired = False, returnModifiedTime = False, returnScheduledRequestPercent = False, returnSchedulingPriorityCode = False, returnSchedulingTeamModeCode = False, returnSchedulingTypeCode = False, returnStudentAutoSchedulerRunAnalysisID = False, returnTotalAlternateRequests = False, returnTotalConflicts = False, returnTotalNumberScheduledThisRun = False, returnTotalRequests = False, returnTotalScheduled = False, returnTotalSeatsAvailable = False, returnTotalSeatsScheduled = False, returnTotalSections = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerCourse in the district.

    This function returns a dataframe of every StudentAutoSchedulerCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerCourse(StudentAutoSchedulerCourseID, EntityID = 1, returnStudentAutoSchedulerCourseID = False, returnActiveSections = False, returnCategoryCode = False, returnConflictedRequestPercent = False, returnCourseCode = False, returnCourseDescription = False, returnCourseEntityCode = False, returnCourseEntityID = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseSubjectCode = False, returnCreatedTime = False, returnDepartmentCode = False, returnIsActive = False, returnIsRequired = False, returnModifiedTime = False, returnScheduledRequestPercent = False, returnSchedulingPriorityCode = False, returnSchedulingTeamModeCode = False, returnSchedulingTypeCode = False, returnStudentAutoSchedulerRunAnalysisID = False, returnTotalAlternateRequests = False, returnTotalConflicts = False, returnTotalNumberScheduledThisRun = False, returnTotalRequests = False, returnTotalScheduled = False, returnTotalSeatsAvailable = False, returnTotalSeatsScheduled = False, returnTotalSections = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerCourse/" + str(StudentAutoSchedulerCourseID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerCourse(StudentAutoSchedulerCourseID, EntityID = 1, setStudentAutoSchedulerCourseID = None, setActiveSections = None, setCategoryCode = None, setConflictedRequestPercent = None, setCourseCode = None, setCourseDescription = None, setCourseEntityCode = None, setCourseEntityID = None, setCourseID = None, setCourseLengthCode = None, setCourseSubjectCode = None, setCreatedTime = None, setDepartmentCode = None, setIsActive = None, setIsRequired = None, setModifiedTime = None, setScheduledRequestPercent = None, setSchedulingPriorityCode = None, setSchedulingTeamModeCode = None, setSchedulingTypeCode = None, setStudentAutoSchedulerRunAnalysisID = None, setTotalAlternateRequests = None, setTotalConflicts = None, setTotalNumberScheduledThisRun = None, setTotalRequests = None, setTotalScheduled = None, setTotalSeatsAvailable = None, setTotalSeatsScheduled = None, setTotalSections = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerCourseID = False, returnActiveSections = False, returnCategoryCode = False, returnConflictedRequestPercent = False, returnCourseCode = False, returnCourseDescription = False, returnCourseEntityCode = False, returnCourseEntityID = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseSubjectCode = False, returnCreatedTime = False, returnDepartmentCode = False, returnIsActive = False, returnIsRequired = False, returnModifiedTime = False, returnScheduledRequestPercent = False, returnSchedulingPriorityCode = False, returnSchedulingTeamModeCode = False, returnSchedulingTypeCode = False, returnStudentAutoSchedulerRunAnalysisID = False, returnTotalAlternateRequests = False, returnTotalConflicts = False, returnTotalNumberScheduledThisRun = False, returnTotalRequests = False, returnTotalScheduled = False, returnTotalSeatsAvailable = False, returnTotalSeatsScheduled = False, returnTotalSections = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerCourse/" + str(StudentAutoSchedulerCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerCourse(EntityID = 1, setStudentAutoSchedulerCourseID = None, setActiveSections = None, setCategoryCode = None, setConflictedRequestPercent = None, setCourseCode = None, setCourseDescription = None, setCourseEntityCode = None, setCourseEntityID = None, setCourseID = None, setCourseLengthCode = None, setCourseSubjectCode = None, setCreatedTime = None, setDepartmentCode = None, setIsActive = None, setIsRequired = None, setModifiedTime = None, setScheduledRequestPercent = None, setSchedulingPriorityCode = None, setSchedulingTeamModeCode = None, setSchedulingTypeCode = None, setStudentAutoSchedulerRunAnalysisID = None, setTotalAlternateRequests = None, setTotalConflicts = None, setTotalNumberScheduledThisRun = None, setTotalRequests = None, setTotalScheduled = None, setTotalSeatsAvailable = None, setTotalSeatsScheduled = None, setTotalSections = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerCourseID = False, returnActiveSections = False, returnCategoryCode = False, returnConflictedRequestPercent = False, returnCourseCode = False, returnCourseDescription = False, returnCourseEntityCode = False, returnCourseEntityID = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseSubjectCode = False, returnCreatedTime = False, returnDepartmentCode = False, returnIsActive = False, returnIsRequired = False, returnModifiedTime = False, returnScheduledRequestPercent = False, returnSchedulingPriorityCode = False, returnSchedulingTeamModeCode = False, returnSchedulingTypeCode = False, returnStudentAutoSchedulerRunAnalysisID = False, returnTotalAlternateRequests = False, returnTotalConflicts = False, returnTotalNumberScheduledThisRun = False, returnTotalRequests = False, returnTotalScheduled = False, returnTotalSeatsAvailable = False, returnTotalSeatsScheduled = False, returnTotalSections = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerCourse(StudentAutoSchedulerCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerCourse/" + str(StudentAutoSchedulerCourseID), verb = "delete")


def getEveryStudentAutoSchedulerProposedStudentCourseRequest(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerProposedStudentCourseRequestID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCourseConflictReason = False, returnCourseConflictReasonCode = False, returnCourseConflictReasonText = False, returnCourseID = False, returnCourseIDOriginal = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnEntityIDRequestedFrom = False, returnIgnore = False, returnIsAlternate = False, returnIsNewlyScheduled = False, returnModifiedTime = False, returnRequestStatus = False, returnRequestStatusCode = False, returnRequestStatusOriginal = False, returnRequestStatusOriginalCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchedulingMethodOriginal = False, returnSchedulingMethodOriginalCode = False, returnSectionID = False, returnSectionIDOriginal = False, returnSectionLengthSubsetsRequested = False, returnSectionLengthSubsetSummary = False, returnSequenceWithinEntireProcess = False, returnSequenceWithinGrade = False, returnSequenceWithinStudent = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDOriginal = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnUnscheduleStatus = False, returnUnscheduleStatusCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerProposedStudentCourseRequest in the district.

    This function returns a dataframe of every StudentAutoSchedulerProposedStudentCourseRequest in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerProposedStudentCourseRequest(StudentAutoSchedulerProposedStudentCourseRequestID, EntityID = 1, returnStudentAutoSchedulerProposedStudentCourseRequestID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCourseConflictReason = False, returnCourseConflictReasonCode = False, returnCourseConflictReasonText = False, returnCourseID = False, returnCourseIDOriginal = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnEntityIDRequestedFrom = False, returnIgnore = False, returnIsAlternate = False, returnIsNewlyScheduled = False, returnModifiedTime = False, returnRequestStatus = False, returnRequestStatusCode = False, returnRequestStatusOriginal = False, returnRequestStatusOriginalCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchedulingMethodOriginal = False, returnSchedulingMethodOriginalCode = False, returnSectionID = False, returnSectionIDOriginal = False, returnSectionLengthSubsetsRequested = False, returnSectionLengthSubsetSummary = False, returnSequenceWithinEntireProcess = False, returnSequenceWithinGrade = False, returnSequenceWithinStudent = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDOriginal = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnUnscheduleStatus = False, returnUnscheduleStatusCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentCourseRequest/" + str(StudentAutoSchedulerProposedStudentCourseRequestID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerProposedStudentCourseRequest(StudentAutoSchedulerProposedStudentCourseRequestID, EntityID = 1, setStudentAutoSchedulerProposedStudentCourseRequestID = None, setBaseRunAnalysisID = None, setCachedStudentSectionID = None, setCourseConflictReason = None, setCourseConflictReasonCode = None, setCourseConflictReasonText = None, setCourseID = None, setCourseIDOriginal = None, setCreatedTime = None, setDataCommittedToRealObjects = None, setEntityIDRequestedFrom = None, setIgnore = None, setIsAlternate = None, setIsNewlyScheduled = None, setModifiedTime = None, setRequestStatus = None, setRequestStatusCode = None, setRequestStatusOriginal = None, setRequestStatusOriginalCode = None, setSchedulingMethod = None, setSchedulingMethodCode = None, setSchedulingMethodOriginal = None, setSchedulingMethodOriginalCode = None, setSectionID = None, setSectionIDOriginal = None, setSectionLengthSubsetsRequested = None, setSectionLengthSubsetSummary = None, setSequenceWithinEntireProcess = None, setSequenceWithinGrade = None, setSequenceWithinStudent = None, setStudentCourseRequestID = None, setStudentCourseRequestIDOriginal = None, setStudentID = None, setStudentIDOriginal = None, setStudentSectionID = None, setStudentSectionIDOriginal = None, setUnscheduleStatus = None, setUnscheduleStatusCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerProposedStudentCourseRequestID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCourseConflictReason = False, returnCourseConflictReasonCode = False, returnCourseConflictReasonText = False, returnCourseID = False, returnCourseIDOriginal = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnEntityIDRequestedFrom = False, returnIgnore = False, returnIsAlternate = False, returnIsNewlyScheduled = False, returnModifiedTime = False, returnRequestStatus = False, returnRequestStatusCode = False, returnRequestStatusOriginal = False, returnRequestStatusOriginalCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchedulingMethodOriginal = False, returnSchedulingMethodOriginalCode = False, returnSectionID = False, returnSectionIDOriginal = False, returnSectionLengthSubsetsRequested = False, returnSectionLengthSubsetSummary = False, returnSequenceWithinEntireProcess = False, returnSequenceWithinGrade = False, returnSequenceWithinStudent = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDOriginal = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnUnscheduleStatus = False, returnUnscheduleStatusCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentCourseRequest/" + str(StudentAutoSchedulerProposedStudentCourseRequestID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerProposedStudentCourseRequest(EntityID = 1, setStudentAutoSchedulerProposedStudentCourseRequestID = None, setBaseRunAnalysisID = None, setCachedStudentSectionID = None, setCourseConflictReason = None, setCourseConflictReasonCode = None, setCourseConflictReasonText = None, setCourseID = None, setCourseIDOriginal = None, setCreatedTime = None, setDataCommittedToRealObjects = None, setEntityIDRequestedFrom = None, setIgnore = None, setIsAlternate = None, setIsNewlyScheduled = None, setModifiedTime = None, setRequestStatus = None, setRequestStatusCode = None, setRequestStatusOriginal = None, setRequestStatusOriginalCode = None, setSchedulingMethod = None, setSchedulingMethodCode = None, setSchedulingMethodOriginal = None, setSchedulingMethodOriginalCode = None, setSectionID = None, setSectionIDOriginal = None, setSectionLengthSubsetsRequested = None, setSectionLengthSubsetSummary = None, setSequenceWithinEntireProcess = None, setSequenceWithinGrade = None, setSequenceWithinStudent = None, setStudentCourseRequestID = None, setStudentCourseRequestIDOriginal = None, setStudentID = None, setStudentIDOriginal = None, setStudentSectionID = None, setStudentSectionIDOriginal = None, setUnscheduleStatus = None, setUnscheduleStatusCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerProposedStudentCourseRequestID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCourseConflictReason = False, returnCourseConflictReasonCode = False, returnCourseConflictReasonText = False, returnCourseID = False, returnCourseIDOriginal = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnEntityIDRequestedFrom = False, returnIgnore = False, returnIsAlternate = False, returnIsNewlyScheduled = False, returnModifiedTime = False, returnRequestStatus = False, returnRequestStatusCode = False, returnRequestStatusOriginal = False, returnRequestStatusOriginalCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchedulingMethodOriginal = False, returnSchedulingMethodOriginalCode = False, returnSectionID = False, returnSectionIDOriginal = False, returnSectionLengthSubsetsRequested = False, returnSectionLengthSubsetSummary = False, returnSequenceWithinEntireProcess = False, returnSequenceWithinGrade = False, returnSequenceWithinStudent = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDOriginal = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnUnscheduleStatus = False, returnUnscheduleStatusCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentCourseRequest/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerProposedStudentCourseRequest(StudentAutoSchedulerProposedStudentCourseRequestID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentCourseRequest/" + str(StudentAutoSchedulerProposedStudentCourseRequestID), verb = "delete")


def getEveryStudentAutoSchedulerProposedStudentSection(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerProposedStudentSectionID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnGradeReferenceID = False, returnGradeReferenceIDOriginal = False, returnModifiedTime = False, returnSectionID = False, returnSectionIDOriginal = False, returnSequenceWithinEntireProcess = False, returnSequenceWithinGrade = False, returnSequenceWithinStudent = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerProposedStudentSection in the district.

    This function returns a dataframe of every StudentAutoSchedulerProposedStudentSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerProposedStudentSection(StudentAutoSchedulerProposedStudentSectionID, EntityID = 1, returnStudentAutoSchedulerProposedStudentSectionID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnGradeReferenceID = False, returnGradeReferenceIDOriginal = False, returnModifiedTime = False, returnSectionID = False, returnSectionIDOriginal = False, returnSequenceWithinEntireProcess = False, returnSequenceWithinGrade = False, returnSequenceWithinStudent = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSection/" + str(StudentAutoSchedulerProposedStudentSectionID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerProposedStudentSection(StudentAutoSchedulerProposedStudentSectionID, EntityID = 1, setStudentAutoSchedulerProposedStudentSectionID = None, setBaseRunAnalysisID = None, setCachedStudentSectionID = None, setCreatedTime = None, setDataCommittedToRealObjects = None, setGradeReferenceID = None, setGradeReferenceIDOriginal = None, setModifiedTime = None, setSectionID = None, setSectionIDOriginal = None, setSequenceWithinEntireProcess = None, setSequenceWithinGrade = None, setSequenceWithinStudent = None, setStudentID = None, setStudentIDOriginal = None, setStudentSectionID = None, setStudentSectionIDOriginal = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerProposedStudentSectionID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnGradeReferenceID = False, returnGradeReferenceIDOriginal = False, returnModifiedTime = False, returnSectionID = False, returnSectionIDOriginal = False, returnSequenceWithinEntireProcess = False, returnSequenceWithinGrade = False, returnSequenceWithinStudent = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSection/" + str(StudentAutoSchedulerProposedStudentSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerProposedStudentSection(EntityID = 1, setStudentAutoSchedulerProposedStudentSectionID = None, setBaseRunAnalysisID = None, setCachedStudentSectionID = None, setCreatedTime = None, setDataCommittedToRealObjects = None, setGradeReferenceID = None, setGradeReferenceIDOriginal = None, setModifiedTime = None, setSectionID = None, setSectionIDOriginal = None, setSequenceWithinEntireProcess = None, setSequenceWithinGrade = None, setSequenceWithinStudent = None, setStudentID = None, setStudentIDOriginal = None, setStudentSectionID = None, setStudentSectionIDOriginal = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerProposedStudentSectionID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnGradeReferenceID = False, returnGradeReferenceIDOriginal = False, returnModifiedTime = False, returnSectionID = False, returnSectionIDOriginal = False, returnSequenceWithinEntireProcess = False, returnSequenceWithinGrade = False, returnSequenceWithinStudent = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerProposedStudentSection(StudentAutoSchedulerProposedStudentSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSection/" + str(StudentAutoSchedulerProposedStudentSectionID), verb = "delete")


def getEveryStudentAutoSchedulerProposedStudentSectionTransaction(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerProposedStudentSectionTransactionID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnEndDate = False, returnEndDateOriginal = False, returnEntityIDCountsAs = False, returnModifiedTime = False, returnSectionID = False, returnSectionIDOriginal = False, returnSectionLengthSubsetID = False, returnSectionLengthSubsetIDOriginal = False, returnStartDate = False, returnStartDateOriginal = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnStudentSectionTransactionID = False, returnStudentSectionTransactionIDOriginal = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerProposedStudentSectionTransaction in the district.

    This function returns a dataframe of every StudentAutoSchedulerProposedStudentSectionTransaction in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSectionTransaction/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSectionTransaction/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerProposedStudentSectionTransaction(StudentAutoSchedulerProposedStudentSectionTransactionID, EntityID = 1, returnStudentAutoSchedulerProposedStudentSectionTransactionID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnEndDate = False, returnEndDateOriginal = False, returnEntityIDCountsAs = False, returnModifiedTime = False, returnSectionID = False, returnSectionIDOriginal = False, returnSectionLengthSubsetID = False, returnSectionLengthSubsetIDOriginal = False, returnStartDate = False, returnStartDateOriginal = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnStudentSectionTransactionID = False, returnStudentSectionTransactionIDOriginal = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSectionTransaction/" + str(StudentAutoSchedulerProposedStudentSectionTransactionID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerProposedStudentSectionTransaction(StudentAutoSchedulerProposedStudentSectionTransactionID, EntityID = 1, setStudentAutoSchedulerProposedStudentSectionTransactionID = None, setBaseRunAnalysisID = None, setCachedStudentSectionID = None, setCreatedTime = None, setDataCommittedToRealObjects = None, setEndDate = None, setEndDateOriginal = None, setEntityIDCountsAs = None, setModifiedTime = None, setSectionID = None, setSectionIDOriginal = None, setSectionLengthSubsetID = None, setSectionLengthSubsetIDOriginal = None, setStartDate = None, setStartDateOriginal = None, setStudentID = None, setStudentIDOriginal = None, setStudentSectionID = None, setStudentSectionIDOriginal = None, setStudentSectionTransactionID = None, setStudentSectionTransactionIDOriginal = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerProposedStudentSectionTransactionID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnEndDate = False, returnEndDateOriginal = False, returnEntityIDCountsAs = False, returnModifiedTime = False, returnSectionID = False, returnSectionIDOriginal = False, returnSectionLengthSubsetID = False, returnSectionLengthSubsetIDOriginal = False, returnStartDate = False, returnStartDateOriginal = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnStudentSectionTransactionID = False, returnStudentSectionTransactionIDOriginal = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSectionTransaction/" + str(StudentAutoSchedulerProposedStudentSectionTransactionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerProposedStudentSectionTransaction(EntityID = 1, setStudentAutoSchedulerProposedStudentSectionTransactionID = None, setBaseRunAnalysisID = None, setCachedStudentSectionID = None, setCreatedTime = None, setDataCommittedToRealObjects = None, setEndDate = None, setEndDateOriginal = None, setEntityIDCountsAs = None, setModifiedTime = None, setSectionID = None, setSectionIDOriginal = None, setSectionLengthSubsetID = None, setSectionLengthSubsetIDOriginal = None, setStartDate = None, setStartDateOriginal = None, setStudentID = None, setStudentIDOriginal = None, setStudentSectionID = None, setStudentSectionIDOriginal = None, setStudentSectionTransactionID = None, setStudentSectionTransactionIDOriginal = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerProposedStudentSectionTransactionID = False, returnBaseRunAnalysisID = False, returnCachedStudentSectionID = False, returnCreatedTime = False, returnDataCommittedToRealObjects = False, returnEndDate = False, returnEndDateOriginal = False, returnEntityIDCountsAs = False, returnModifiedTime = False, returnSectionID = False, returnSectionIDOriginal = False, returnSectionLengthSubsetID = False, returnSectionLengthSubsetIDOriginal = False, returnStartDate = False, returnStartDateOriginal = False, returnStudentID = False, returnStudentIDOriginal = False, returnStudentSectionID = False, returnStudentSectionIDOriginal = False, returnStudentSectionTransactionID = False, returnStudentSectionTransactionIDOriginal = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSectionTransaction/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerProposedStudentSectionTransaction(StudentAutoSchedulerProposedStudentSectionTransactionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerProposedStudentSectionTransaction/" + str(StudentAutoSchedulerProposedStudentSectionTransactionID), verb = "delete")


def getEveryStudentAutoSchedulerRunAnalysis(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerRunAnalysisID = False, returnAnalysisDuration = False, returnAnalysisVersion = False, returnAnalysisVersionCode = False, returnBaseRunAnalysisID = False, returnCloseSectionsWhenFilled = False, returnConflictedStudentCourseRequestPercent = False, returnCountOfStudentAutoSchedulerCourseRecords = False, returnCountOfStudentAutoSchedulerRunAnalysisExceptionRecords = False, returnCountOfStudentAutoSchedulerStudentRecords = False, returnCourseConflictPercent = False, returnCreatedCourseAndSectionAnalysisDetails = False, returnCreatedStudentAnalysisDetails = False, returnCreatedTime = False, returnDescription = False, returnEndTimeAnalysis = False, returnEndTimeFinalize = False, returnExistsAutoScheduledCourses = False, returnExistsAutoScheduledStudents = False, returnFailedScheduledStudentSectionsCount = False, returnFailedStudentCourseRequestsCount = False, returnFailedStudentSectionsCount = False, returnFailedStudentSectionTransactionsCount = False, returnFinalizeDuration = False, returnGradeReferenceIDEnd = False, returnGradeReferenceIDStart = False, returnIncludedAbilityToAcceptProposedSchedules = False, returnIsInvalidFinalizeState = False, returnModifiedTime = False, returnOverallDuration = False, returnPersistentSchedulingRunDataIsNoLongerAcceptable = False, returnProcessSpecialEdCourses = False, returnProposedSchedulesAccepted = False, returnRunDescription = False, returnRunInformation = False, returnScheduledStudentCourseRequestPercent = False, returnSendMessageOnComplete = False, returnStartTimeAnalysis = False, returnStartTimeFinalize = False, returnStudentAutoSchedulerMode = False, returnStudentAutoSchedulerModeCode = False, returnStudentConflictPercent = False, returnStudentCourseRequestOrder = False, returnStudentCourseRequestsConflictedThisRun = False, returnStudentCourseRequestsProcessedThisRun = False, returnStudentCourseRequestsScheduledThisRun = False, returnStudentDifficultyOrder = False, returnStudentInformation = False, returnSuccessfulStudentSectionsCount = False, returnTotalAlternateStudentCourseRequests = False, returnTotalConflictedStudentCourseRequests = False, returnTotalScheduledStudentCourseRequests = False, returnTotalStudentCourseRequests = False, returnTotalStudentCourseRequestsToFinalize = False, returnTotalStudents = False, returnTotalStudentSectionsToFinalize = False, returnTotalStudentSectionTransactionsToFinalize = False, returnTotalStudentsWithConflicts = False, returnTotalStudentsWithOneConflict = False, returnTotalStudentsWithThreeOrMoreConflicts = False, returnTotalStudentsWithTwoConflicts = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerRunAnalysis in the district.

    This function returns a dataframe of every StudentAutoSchedulerRunAnalysis in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysis/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysis/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerRunAnalysis(StudentAutoSchedulerRunAnalysisID, EntityID = 1, returnStudentAutoSchedulerRunAnalysisID = False, returnAnalysisDuration = False, returnAnalysisVersion = False, returnAnalysisVersionCode = False, returnBaseRunAnalysisID = False, returnCloseSectionsWhenFilled = False, returnConflictedStudentCourseRequestPercent = False, returnCountOfStudentAutoSchedulerCourseRecords = False, returnCountOfStudentAutoSchedulerRunAnalysisExceptionRecords = False, returnCountOfStudentAutoSchedulerStudentRecords = False, returnCourseConflictPercent = False, returnCreatedCourseAndSectionAnalysisDetails = False, returnCreatedStudentAnalysisDetails = False, returnCreatedTime = False, returnDescription = False, returnEndTimeAnalysis = False, returnEndTimeFinalize = False, returnExistsAutoScheduledCourses = False, returnExistsAutoScheduledStudents = False, returnFailedScheduledStudentSectionsCount = False, returnFailedStudentCourseRequestsCount = False, returnFailedStudentSectionsCount = False, returnFailedStudentSectionTransactionsCount = False, returnFinalizeDuration = False, returnGradeReferenceIDEnd = False, returnGradeReferenceIDStart = False, returnIncludedAbilityToAcceptProposedSchedules = False, returnIsInvalidFinalizeState = False, returnModifiedTime = False, returnOverallDuration = False, returnPersistentSchedulingRunDataIsNoLongerAcceptable = False, returnProcessSpecialEdCourses = False, returnProposedSchedulesAccepted = False, returnRunDescription = False, returnRunInformation = False, returnScheduledStudentCourseRequestPercent = False, returnSendMessageOnComplete = False, returnStartTimeAnalysis = False, returnStartTimeFinalize = False, returnStudentAutoSchedulerMode = False, returnStudentAutoSchedulerModeCode = False, returnStudentConflictPercent = False, returnStudentCourseRequestOrder = False, returnStudentCourseRequestsConflictedThisRun = False, returnStudentCourseRequestsProcessedThisRun = False, returnStudentCourseRequestsScheduledThisRun = False, returnStudentDifficultyOrder = False, returnStudentInformation = False, returnSuccessfulStudentSectionsCount = False, returnTotalAlternateStudentCourseRequests = False, returnTotalConflictedStudentCourseRequests = False, returnTotalScheduledStudentCourseRequests = False, returnTotalStudentCourseRequests = False, returnTotalStudentCourseRequestsToFinalize = False, returnTotalStudents = False, returnTotalStudentSectionsToFinalize = False, returnTotalStudentSectionTransactionsToFinalize = False, returnTotalStudentsWithConflicts = False, returnTotalStudentsWithOneConflict = False, returnTotalStudentsWithThreeOrMoreConflicts = False, returnTotalStudentsWithTwoConflicts = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysis/" + str(StudentAutoSchedulerRunAnalysisID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerRunAnalysis(StudentAutoSchedulerRunAnalysisID, EntityID = 1, setStudentAutoSchedulerRunAnalysisID = None, setAnalysisDuration = None, setAnalysisVersion = None, setAnalysisVersionCode = None, setBaseRunAnalysisID = None, setCloseSectionsWhenFilled = None, setConflictedStudentCourseRequestPercent = None, setCountOfStudentAutoSchedulerCourseRecords = None, setCountOfStudentAutoSchedulerRunAnalysisExceptionRecords = None, setCountOfStudentAutoSchedulerStudentRecords = None, setCourseConflictPercent = None, setCreatedCourseAndSectionAnalysisDetails = None, setCreatedStudentAnalysisDetails = None, setCreatedTime = None, setDescription = None, setEndTimeAnalysis = None, setEndTimeFinalize = None, setExistsAutoScheduledCourses = None, setExistsAutoScheduledStudents = None, setFailedScheduledStudentSectionsCount = None, setFailedStudentCourseRequestsCount = None, setFailedStudentSectionsCount = None, setFailedStudentSectionTransactionsCount = None, setFinalizeDuration = None, setGradeReferenceIDEnd = None, setGradeReferenceIDStart = None, setIncludedAbilityToAcceptProposedSchedules = None, setIsInvalidFinalizeState = None, setModifiedTime = None, setOverallDuration = None, setPersistentSchedulingRunDataIsNoLongerAcceptable = None, setProcessSpecialEdCourses = None, setProposedSchedulesAccepted = None, setRunDescription = None, setRunInformation = None, setScheduledStudentCourseRequestPercent = None, setSendMessageOnComplete = None, setStartTimeAnalysis = None, setStartTimeFinalize = None, setStudentAutoSchedulerMode = None, setStudentAutoSchedulerModeCode = None, setStudentConflictPercent = None, setStudentCourseRequestOrder = None, setStudentCourseRequestsConflictedThisRun = None, setStudentCourseRequestsProcessedThisRun = None, setStudentCourseRequestsScheduledThisRun = None, setStudentDifficultyOrder = None, setStudentInformation = None, setSuccessfulStudentSectionsCount = None, setTotalAlternateStudentCourseRequests = None, setTotalConflictedStudentCourseRequests = None, setTotalScheduledStudentCourseRequests = None, setTotalStudentCourseRequests = None, setTotalStudentCourseRequestsToFinalize = None, setTotalStudents = None, setTotalStudentSectionsToFinalize = None, setTotalStudentSectionTransactionsToFinalize = None, setTotalStudentsWithConflicts = None, setTotalStudentsWithOneConflict = None, setTotalStudentsWithThreeOrMoreConflicts = None, setTotalStudentsWithTwoConflicts = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerRunAnalysisID = False, returnAnalysisDuration = False, returnAnalysisVersion = False, returnAnalysisVersionCode = False, returnBaseRunAnalysisID = False, returnCloseSectionsWhenFilled = False, returnConflictedStudentCourseRequestPercent = False, returnCountOfStudentAutoSchedulerCourseRecords = False, returnCountOfStudentAutoSchedulerRunAnalysisExceptionRecords = False, returnCountOfStudentAutoSchedulerStudentRecords = False, returnCourseConflictPercent = False, returnCreatedCourseAndSectionAnalysisDetails = False, returnCreatedStudentAnalysisDetails = False, returnCreatedTime = False, returnDescription = False, returnEndTimeAnalysis = False, returnEndTimeFinalize = False, returnExistsAutoScheduledCourses = False, returnExistsAutoScheduledStudents = False, returnFailedScheduledStudentSectionsCount = False, returnFailedStudentCourseRequestsCount = False, returnFailedStudentSectionsCount = False, returnFailedStudentSectionTransactionsCount = False, returnFinalizeDuration = False, returnGradeReferenceIDEnd = False, returnGradeReferenceIDStart = False, returnIncludedAbilityToAcceptProposedSchedules = False, returnIsInvalidFinalizeState = False, returnModifiedTime = False, returnOverallDuration = False, returnPersistentSchedulingRunDataIsNoLongerAcceptable = False, returnProcessSpecialEdCourses = False, returnProposedSchedulesAccepted = False, returnRunDescription = False, returnRunInformation = False, returnScheduledStudentCourseRequestPercent = False, returnSendMessageOnComplete = False, returnStartTimeAnalysis = False, returnStartTimeFinalize = False, returnStudentAutoSchedulerMode = False, returnStudentAutoSchedulerModeCode = False, returnStudentConflictPercent = False, returnStudentCourseRequestOrder = False, returnStudentCourseRequestsConflictedThisRun = False, returnStudentCourseRequestsProcessedThisRun = False, returnStudentCourseRequestsScheduledThisRun = False, returnStudentDifficultyOrder = False, returnStudentInformation = False, returnSuccessfulStudentSectionsCount = False, returnTotalAlternateStudentCourseRequests = False, returnTotalConflictedStudentCourseRequests = False, returnTotalScheduledStudentCourseRequests = False, returnTotalStudentCourseRequests = False, returnTotalStudentCourseRequestsToFinalize = False, returnTotalStudents = False, returnTotalStudentSectionsToFinalize = False, returnTotalStudentSectionTransactionsToFinalize = False, returnTotalStudentsWithConflicts = False, returnTotalStudentsWithOneConflict = False, returnTotalStudentsWithThreeOrMoreConflicts = False, returnTotalStudentsWithTwoConflicts = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysis/" + str(StudentAutoSchedulerRunAnalysisID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerRunAnalysis(EntityID = 1, setStudentAutoSchedulerRunAnalysisID = None, setAnalysisDuration = None, setAnalysisVersion = None, setAnalysisVersionCode = None, setBaseRunAnalysisID = None, setCloseSectionsWhenFilled = None, setConflictedStudentCourseRequestPercent = None, setCountOfStudentAutoSchedulerCourseRecords = None, setCountOfStudentAutoSchedulerRunAnalysisExceptionRecords = None, setCountOfStudentAutoSchedulerStudentRecords = None, setCourseConflictPercent = None, setCreatedCourseAndSectionAnalysisDetails = None, setCreatedStudentAnalysisDetails = None, setCreatedTime = None, setDescription = None, setEndTimeAnalysis = None, setEndTimeFinalize = None, setExistsAutoScheduledCourses = None, setExistsAutoScheduledStudents = None, setFailedScheduledStudentSectionsCount = None, setFailedStudentCourseRequestsCount = None, setFailedStudentSectionsCount = None, setFailedStudentSectionTransactionsCount = None, setFinalizeDuration = None, setGradeReferenceIDEnd = None, setGradeReferenceIDStart = None, setIncludedAbilityToAcceptProposedSchedules = None, setIsInvalidFinalizeState = None, setModifiedTime = None, setOverallDuration = None, setPersistentSchedulingRunDataIsNoLongerAcceptable = None, setProcessSpecialEdCourses = None, setProposedSchedulesAccepted = None, setRunDescription = None, setRunInformation = None, setScheduledStudentCourseRequestPercent = None, setSendMessageOnComplete = None, setStartTimeAnalysis = None, setStartTimeFinalize = None, setStudentAutoSchedulerMode = None, setStudentAutoSchedulerModeCode = None, setStudentConflictPercent = None, setStudentCourseRequestOrder = None, setStudentCourseRequestsConflictedThisRun = None, setStudentCourseRequestsProcessedThisRun = None, setStudentCourseRequestsScheduledThisRun = None, setStudentDifficultyOrder = None, setStudentInformation = None, setSuccessfulStudentSectionsCount = None, setTotalAlternateStudentCourseRequests = None, setTotalConflictedStudentCourseRequests = None, setTotalScheduledStudentCourseRequests = None, setTotalStudentCourseRequests = None, setTotalStudentCourseRequestsToFinalize = None, setTotalStudents = None, setTotalStudentSectionsToFinalize = None, setTotalStudentSectionTransactionsToFinalize = None, setTotalStudentsWithConflicts = None, setTotalStudentsWithOneConflict = None, setTotalStudentsWithThreeOrMoreConflicts = None, setTotalStudentsWithTwoConflicts = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerRunAnalysisID = False, returnAnalysisDuration = False, returnAnalysisVersion = False, returnAnalysisVersionCode = False, returnBaseRunAnalysisID = False, returnCloseSectionsWhenFilled = False, returnConflictedStudentCourseRequestPercent = False, returnCountOfStudentAutoSchedulerCourseRecords = False, returnCountOfStudentAutoSchedulerRunAnalysisExceptionRecords = False, returnCountOfStudentAutoSchedulerStudentRecords = False, returnCourseConflictPercent = False, returnCreatedCourseAndSectionAnalysisDetails = False, returnCreatedStudentAnalysisDetails = False, returnCreatedTime = False, returnDescription = False, returnEndTimeAnalysis = False, returnEndTimeFinalize = False, returnExistsAutoScheduledCourses = False, returnExistsAutoScheduledStudents = False, returnFailedScheduledStudentSectionsCount = False, returnFailedStudentCourseRequestsCount = False, returnFailedStudentSectionsCount = False, returnFailedStudentSectionTransactionsCount = False, returnFinalizeDuration = False, returnGradeReferenceIDEnd = False, returnGradeReferenceIDStart = False, returnIncludedAbilityToAcceptProposedSchedules = False, returnIsInvalidFinalizeState = False, returnModifiedTime = False, returnOverallDuration = False, returnPersistentSchedulingRunDataIsNoLongerAcceptable = False, returnProcessSpecialEdCourses = False, returnProposedSchedulesAccepted = False, returnRunDescription = False, returnRunInformation = False, returnScheduledStudentCourseRequestPercent = False, returnSendMessageOnComplete = False, returnStartTimeAnalysis = False, returnStartTimeFinalize = False, returnStudentAutoSchedulerMode = False, returnStudentAutoSchedulerModeCode = False, returnStudentConflictPercent = False, returnStudentCourseRequestOrder = False, returnStudentCourseRequestsConflictedThisRun = False, returnStudentCourseRequestsProcessedThisRun = False, returnStudentCourseRequestsScheduledThisRun = False, returnStudentDifficultyOrder = False, returnStudentInformation = False, returnSuccessfulStudentSectionsCount = False, returnTotalAlternateStudentCourseRequests = False, returnTotalConflictedStudentCourseRequests = False, returnTotalScheduledStudentCourseRequests = False, returnTotalStudentCourseRequests = False, returnTotalStudentCourseRequestsToFinalize = False, returnTotalStudents = False, returnTotalStudentSectionsToFinalize = False, returnTotalStudentSectionTransactionsToFinalize = False, returnTotalStudentsWithConflicts = False, returnTotalStudentsWithOneConflict = False, returnTotalStudentsWithThreeOrMoreConflicts = False, returnTotalStudentsWithTwoConflicts = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysis/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerRunAnalysis(StudentAutoSchedulerRunAnalysisID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysis/" + str(StudentAutoSchedulerRunAnalysisID), verb = "delete")


def getEveryStudentAutoSchedulerRunAnalysisException(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerRunAnalysisExceptionID = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnSectionCode = False, returnSeverityType = False, returnSeverityTypeCode = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentAutoSchedulerStudentCourseRequestID = False, returnStudentFullName = False, returnStudentNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerRunAnalysisException in the district.

    This function returns a dataframe of every StudentAutoSchedulerRunAnalysisException in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisException/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisException/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerRunAnalysisException(StudentAutoSchedulerRunAnalysisExceptionID, EntityID = 1, returnStudentAutoSchedulerRunAnalysisExceptionID = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnSectionCode = False, returnSeverityType = False, returnSeverityTypeCode = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentAutoSchedulerStudentCourseRequestID = False, returnStudentFullName = False, returnStudentNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisException/" + str(StudentAutoSchedulerRunAnalysisExceptionID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerRunAnalysisException(StudentAutoSchedulerRunAnalysisExceptionID, EntityID = 1, setStudentAutoSchedulerRunAnalysisExceptionID = None, setCourseCode = None, setCourseDescription = None, setCreatedTime = None, setMessage = None, setModifiedTime = None, setSectionCode = None, setSeverityType = None, setSeverityTypeCode = None, setStudentAutoSchedulerRunAnalysisID = None, setStudentAutoSchedulerStudentCourseRequestID = None, setStudentFullName = None, setStudentNumber = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerRunAnalysisExceptionID = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnSectionCode = False, returnSeverityType = False, returnSeverityTypeCode = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentAutoSchedulerStudentCourseRequestID = False, returnStudentFullName = False, returnStudentNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisException/" + str(StudentAutoSchedulerRunAnalysisExceptionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerRunAnalysisException(EntityID = 1, setStudentAutoSchedulerRunAnalysisExceptionID = None, setCourseCode = None, setCourseDescription = None, setCreatedTime = None, setMessage = None, setModifiedTime = None, setSectionCode = None, setSeverityType = None, setSeverityTypeCode = None, setStudentAutoSchedulerRunAnalysisID = None, setStudentAutoSchedulerStudentCourseRequestID = None, setStudentFullName = None, setStudentNumber = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerRunAnalysisExceptionID = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnSectionCode = False, returnSeverityType = False, returnSeverityTypeCode = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentAutoSchedulerStudentCourseRequestID = False, returnStudentFullName = False, returnStudentNumber = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisException/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerRunAnalysisException(StudentAutoSchedulerRunAnalysisExceptionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisException/" + str(StudentAutoSchedulerRunAnalysisExceptionID), verb = "delete")


def getEveryStudentAutoSchedulerRunAnalysisTotal(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerRunAnalysisTotalID = False, returnConflictedStudentCourseRequestPercent = False, returnConflictPercent = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnGradeReferenceID = False, returnModifiedTime = False, returnScheduledStudentCourseRequestPercent = False, returnStartTimeAnalysis = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentCourseRequestsConflictedThisRun = False, returnStudentCourseRequestsProcessedThisRun = False, returnStudentCourseRequestsScheduledThisRun = False, returnStudentsWithConflicts = False, returnStudentsWithOneConflict = False, returnStudentsWithThreeOrMoreConflicts = False, returnStudentsWithTwoConflicts = False, returnTotalAlternateStudentCourseRequests = False, returnTotalConflictedStudentCourseRequests = False, returnTotalScheduledStudentCourseRequests = False, returnTotalStudentCourseRequests = False, returnTotalStudents = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerRunAnalysisTotal in the district.

    This function returns a dataframe of every StudentAutoSchedulerRunAnalysisTotal in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisTotal/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisTotal/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerRunAnalysisTotal(StudentAutoSchedulerRunAnalysisTotalID, EntityID = 1, returnStudentAutoSchedulerRunAnalysisTotalID = False, returnConflictedStudentCourseRequestPercent = False, returnConflictPercent = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnGradeReferenceID = False, returnModifiedTime = False, returnScheduledStudentCourseRequestPercent = False, returnStartTimeAnalysis = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentCourseRequestsConflictedThisRun = False, returnStudentCourseRequestsProcessedThisRun = False, returnStudentCourseRequestsScheduledThisRun = False, returnStudentsWithConflicts = False, returnStudentsWithOneConflict = False, returnStudentsWithThreeOrMoreConflicts = False, returnStudentsWithTwoConflicts = False, returnTotalAlternateStudentCourseRequests = False, returnTotalConflictedStudentCourseRequests = False, returnTotalScheduledStudentCourseRequests = False, returnTotalStudentCourseRequests = False, returnTotalStudents = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisTotal/" + str(StudentAutoSchedulerRunAnalysisTotalID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerRunAnalysisTotal(StudentAutoSchedulerRunAnalysisTotalID, EntityID = 1, setStudentAutoSchedulerRunAnalysisTotalID = None, setConflictedStudentCourseRequestPercent = None, setConflictPercent = None, setCreatedTime = None, setEndTimeAnalysis = None, setGradeReferenceID = None, setModifiedTime = None, setScheduledStudentCourseRequestPercent = None, setStartTimeAnalysis = None, setStudentAutoSchedulerRunAnalysisID = None, setStudentCourseRequestsConflictedThisRun = None, setStudentCourseRequestsProcessedThisRun = None, setStudentCourseRequestsScheduledThisRun = None, setStudentsWithConflicts = None, setStudentsWithOneConflict = None, setStudentsWithThreeOrMoreConflicts = None, setStudentsWithTwoConflicts = None, setTotalAlternateStudentCourseRequests = None, setTotalConflictedStudentCourseRequests = None, setTotalScheduledStudentCourseRequests = None, setTotalStudentCourseRequests = None, setTotalStudents = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerRunAnalysisTotalID = False, returnConflictedStudentCourseRequestPercent = False, returnConflictPercent = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnGradeReferenceID = False, returnModifiedTime = False, returnScheduledStudentCourseRequestPercent = False, returnStartTimeAnalysis = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentCourseRequestsConflictedThisRun = False, returnStudentCourseRequestsProcessedThisRun = False, returnStudentCourseRequestsScheduledThisRun = False, returnStudentsWithConflicts = False, returnStudentsWithOneConflict = False, returnStudentsWithThreeOrMoreConflicts = False, returnStudentsWithTwoConflicts = False, returnTotalAlternateStudentCourseRequests = False, returnTotalConflictedStudentCourseRequests = False, returnTotalScheduledStudentCourseRequests = False, returnTotalStudentCourseRequests = False, returnTotalStudents = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisTotal/" + str(StudentAutoSchedulerRunAnalysisTotalID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerRunAnalysisTotal(EntityID = 1, setStudentAutoSchedulerRunAnalysisTotalID = None, setConflictedStudentCourseRequestPercent = None, setConflictPercent = None, setCreatedTime = None, setEndTimeAnalysis = None, setGradeReferenceID = None, setModifiedTime = None, setScheduledStudentCourseRequestPercent = None, setStartTimeAnalysis = None, setStudentAutoSchedulerRunAnalysisID = None, setStudentCourseRequestsConflictedThisRun = None, setStudentCourseRequestsProcessedThisRun = None, setStudentCourseRequestsScheduledThisRun = None, setStudentsWithConflicts = None, setStudentsWithOneConflict = None, setStudentsWithThreeOrMoreConflicts = None, setStudentsWithTwoConflicts = None, setTotalAlternateStudentCourseRequests = None, setTotalConflictedStudentCourseRequests = None, setTotalScheduledStudentCourseRequests = None, setTotalStudentCourseRequests = None, setTotalStudents = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerRunAnalysisTotalID = False, returnConflictedStudentCourseRequestPercent = False, returnConflictPercent = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnGradeReferenceID = False, returnModifiedTime = False, returnScheduledStudentCourseRequestPercent = False, returnStartTimeAnalysis = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentCourseRequestsConflictedThisRun = False, returnStudentCourseRequestsProcessedThisRun = False, returnStudentCourseRequestsScheduledThisRun = False, returnStudentsWithConflicts = False, returnStudentsWithOneConflict = False, returnStudentsWithThreeOrMoreConflicts = False, returnStudentsWithTwoConflicts = False, returnTotalAlternateStudentCourseRequests = False, returnTotalConflictedStudentCourseRequests = False, returnTotalScheduledStudentCourseRequests = False, returnTotalStudentCourseRequests = False, returnTotalStudents = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisTotal/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerRunAnalysisTotal(StudentAutoSchedulerRunAnalysisTotalID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerRunAnalysisTotal/" + str(StudentAutoSchedulerRunAnalysisTotalID), verb = "delete")


def getEveryStudentAutoSchedulerSection(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerSectionID = False, returnAllowStudentsWithoutCategoryToBeAssigned = False, returnCreatedTime = False, returnDayRotationCode = False, returnDisplayPeriodCode = False, returnIsActive = False, returnMaximumStudentCount = False, returnMinimumStudentCount = False, returnModifiedTime = False, returnOptimalStudentCount = False, returnPeriodDaySummary = False, returnPrimaryMeetBuildingCode = False, returnPrimaryMeetRoomNumber = False, returnPrimaryMeetStaffNameLFM = False, returnSchedulingCategories = False, returnSchedulingTeams = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnStudentAutoSchedulerCourseID = False, returnTotalNumberScheduledThisRun = False, returnTotalScheduled = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerSection in the district.

    This function returns a dataframe of every StudentAutoSchedulerSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerSection(StudentAutoSchedulerSectionID, EntityID = 1, returnStudentAutoSchedulerSectionID = False, returnAllowStudentsWithoutCategoryToBeAssigned = False, returnCreatedTime = False, returnDayRotationCode = False, returnDisplayPeriodCode = False, returnIsActive = False, returnMaximumStudentCount = False, returnMinimumStudentCount = False, returnModifiedTime = False, returnOptimalStudentCount = False, returnPeriodDaySummary = False, returnPrimaryMeetBuildingCode = False, returnPrimaryMeetRoomNumber = False, returnPrimaryMeetStaffNameLFM = False, returnSchedulingCategories = False, returnSchedulingTeams = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnStudentAutoSchedulerCourseID = False, returnTotalNumberScheduledThisRun = False, returnTotalScheduled = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerSection/" + str(StudentAutoSchedulerSectionID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerSection(StudentAutoSchedulerSectionID, EntityID = 1, setStudentAutoSchedulerSectionID = None, setAllowStudentsWithoutCategoryToBeAssigned = None, setCreatedTime = None, setDayRotationCode = None, setDisplayPeriodCode = None, setIsActive = None, setMaximumStudentCount = None, setMinimumStudentCount = None, setModifiedTime = None, setOptimalStudentCount = None, setPeriodDaySummary = None, setPrimaryMeetBuildingCode = None, setPrimaryMeetRoomNumber = None, setPrimaryMeetStaffNameLFM = None, setSchedulingCategories = None, setSchedulingTeams = None, setSectionCode = None, setSectionID = None, setSectionLengthCode = None, setStudentAutoSchedulerCourseID = None, setTotalNumberScheduledThisRun = None, setTotalScheduled = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerSectionID = False, returnAllowStudentsWithoutCategoryToBeAssigned = False, returnCreatedTime = False, returnDayRotationCode = False, returnDisplayPeriodCode = False, returnIsActive = False, returnMaximumStudentCount = False, returnMinimumStudentCount = False, returnModifiedTime = False, returnOptimalStudentCount = False, returnPeriodDaySummary = False, returnPrimaryMeetBuildingCode = False, returnPrimaryMeetRoomNumber = False, returnPrimaryMeetStaffNameLFM = False, returnSchedulingCategories = False, returnSchedulingTeams = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnStudentAutoSchedulerCourseID = False, returnTotalNumberScheduledThisRun = False, returnTotalScheduled = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerSection/" + str(StudentAutoSchedulerSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerSection(EntityID = 1, setStudentAutoSchedulerSectionID = None, setAllowStudentsWithoutCategoryToBeAssigned = None, setCreatedTime = None, setDayRotationCode = None, setDisplayPeriodCode = None, setIsActive = None, setMaximumStudentCount = None, setMinimumStudentCount = None, setModifiedTime = None, setOptimalStudentCount = None, setPeriodDaySummary = None, setPrimaryMeetBuildingCode = None, setPrimaryMeetRoomNumber = None, setPrimaryMeetStaffNameLFM = None, setSchedulingCategories = None, setSchedulingTeams = None, setSectionCode = None, setSectionID = None, setSectionLengthCode = None, setStudentAutoSchedulerCourseID = None, setTotalNumberScheduledThisRun = None, setTotalScheduled = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerSectionID = False, returnAllowStudentsWithoutCategoryToBeAssigned = False, returnCreatedTime = False, returnDayRotationCode = False, returnDisplayPeriodCode = False, returnIsActive = False, returnMaximumStudentCount = False, returnMinimumStudentCount = False, returnModifiedTime = False, returnOptimalStudentCount = False, returnPeriodDaySummary = False, returnPrimaryMeetBuildingCode = False, returnPrimaryMeetRoomNumber = False, returnPrimaryMeetStaffNameLFM = False, returnSchedulingCategories = False, returnSchedulingTeams = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnStudentAutoSchedulerCourseID = False, returnTotalNumberScheduledThisRun = False, returnTotalScheduled = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerSection(StudentAutoSchedulerSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerSection/" + str(StudentAutoSchedulerSectionID), verb = "delete")


def getEveryStudentAutoSchedulerStudent(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerStudentID = False, returnBirthDate = False, returnCalendarCode = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnFullName = False, returnGenderCode = False, returnGrade = False, returnGradeReferenceID = False, returnHasConflict = False, returnModifiedTime = False, returnNumberOfConflictedStudentCourseRequests = False, returnNumberOfScheduledStudentCourseRequests = False, returnProcessedDuringThisSchedulingRun = False, returnRandomSchedulingInteger = False, returnRawPermutations = False, returnSchedulesConsidered = False, returnSchedulingCategories = False, returnSchedulingTeamCode = False, returnSequenceNumber = False, returnStartTimeAnalysis = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentID = False, returnStudentNumber = False, returnStudentTypeCode = False, returnTotalNumberOfAlternateStudentCourseRequests = False, returnTotalNumberOfStudentCourseRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerStudent in the district.

    This function returns a dataframe of every StudentAutoSchedulerStudent in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudent/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudent/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerStudent(StudentAutoSchedulerStudentID, EntityID = 1, returnStudentAutoSchedulerStudentID = False, returnBirthDate = False, returnCalendarCode = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnFullName = False, returnGenderCode = False, returnGrade = False, returnGradeReferenceID = False, returnHasConflict = False, returnModifiedTime = False, returnNumberOfConflictedStudentCourseRequests = False, returnNumberOfScheduledStudentCourseRequests = False, returnProcessedDuringThisSchedulingRun = False, returnRandomSchedulingInteger = False, returnRawPermutations = False, returnSchedulesConsidered = False, returnSchedulingCategories = False, returnSchedulingTeamCode = False, returnSequenceNumber = False, returnStartTimeAnalysis = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentID = False, returnStudentNumber = False, returnStudentTypeCode = False, returnTotalNumberOfAlternateStudentCourseRequests = False, returnTotalNumberOfStudentCourseRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudent/" + str(StudentAutoSchedulerStudentID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerStudent(StudentAutoSchedulerStudentID, EntityID = 1, setStudentAutoSchedulerStudentID = None, setBirthDate = None, setCalendarCode = None, setCreatedTime = None, setEndTimeAnalysis = None, setFullName = None, setGenderCode = None, setGrade = None, setGradeReferenceID = None, setHasConflict = None, setModifiedTime = None, setNumberOfConflictedStudentCourseRequests = None, setNumberOfScheduledStudentCourseRequests = None, setProcessedDuringThisSchedulingRun = None, setRandomSchedulingInteger = None, setRawPermutations = None, setSchedulesConsidered = None, setSchedulingCategories = None, setSchedulingTeamCode = None, setSequenceNumber = None, setStartTimeAnalysis = None, setStudentAutoSchedulerRunAnalysisID = None, setStudentID = None, setStudentNumber = None, setStudentTypeCode = None, setTotalNumberOfAlternateStudentCourseRequests = None, setTotalNumberOfStudentCourseRequests = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerStudentID = False, returnBirthDate = False, returnCalendarCode = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnFullName = False, returnGenderCode = False, returnGrade = False, returnGradeReferenceID = False, returnHasConflict = False, returnModifiedTime = False, returnNumberOfConflictedStudentCourseRequests = False, returnNumberOfScheduledStudentCourseRequests = False, returnProcessedDuringThisSchedulingRun = False, returnRandomSchedulingInteger = False, returnRawPermutations = False, returnSchedulesConsidered = False, returnSchedulingCategories = False, returnSchedulingTeamCode = False, returnSequenceNumber = False, returnStartTimeAnalysis = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentID = False, returnStudentNumber = False, returnStudentTypeCode = False, returnTotalNumberOfAlternateStudentCourseRequests = False, returnTotalNumberOfStudentCourseRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudent/" + str(StudentAutoSchedulerStudentID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerStudent(EntityID = 1, setStudentAutoSchedulerStudentID = None, setBirthDate = None, setCalendarCode = None, setCreatedTime = None, setEndTimeAnalysis = None, setFullName = None, setGenderCode = None, setGrade = None, setGradeReferenceID = None, setHasConflict = None, setModifiedTime = None, setNumberOfConflictedStudentCourseRequests = None, setNumberOfScheduledStudentCourseRequests = None, setProcessedDuringThisSchedulingRun = None, setRandomSchedulingInteger = None, setRawPermutations = None, setSchedulesConsidered = None, setSchedulingCategories = None, setSchedulingTeamCode = None, setSequenceNumber = None, setStartTimeAnalysis = None, setStudentAutoSchedulerRunAnalysisID = None, setStudentID = None, setStudentNumber = None, setStudentTypeCode = None, setTotalNumberOfAlternateStudentCourseRequests = None, setTotalNumberOfStudentCourseRequests = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerStudentID = False, returnBirthDate = False, returnCalendarCode = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnFullName = False, returnGenderCode = False, returnGrade = False, returnGradeReferenceID = False, returnHasConflict = False, returnModifiedTime = False, returnNumberOfConflictedStudentCourseRequests = False, returnNumberOfScheduledStudentCourseRequests = False, returnProcessedDuringThisSchedulingRun = False, returnRandomSchedulingInteger = False, returnRawPermutations = False, returnSchedulesConsidered = False, returnSchedulingCategories = False, returnSchedulingTeamCode = False, returnSequenceNumber = False, returnStartTimeAnalysis = False, returnStudentAutoSchedulerRunAnalysisID = False, returnStudentID = False, returnStudentNumber = False, returnStudentTypeCode = False, returnTotalNumberOfAlternateStudentCourseRequests = False, returnTotalNumberOfStudentCourseRequests = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudent/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerStudent(StudentAutoSchedulerStudentID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudent/" + str(StudentAutoSchedulerStudentID), verb = "delete")


def getEveryStudentAutoSchedulerStudentCourseRequest(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerStudentCourseRequestID = False, returnCourseConflictReason = False, returnCourseConflictReasonCode = False, returnCourseConflictReasonText = False, returnCreatedTime = False, returnEntityIDRequestedFrom = False, returnEntityRequestedFromEntityCode = False, returnHasRelatedStudentAutoSchedulerStudentCourseRequestSections = False, returnInitialSequenceNumber = False, returnIsAlternate = False, returnModifiedTime = False, returnSchedulingMethodCode = False, returnSectionLengthSubsetsRequested = False, returnSectionLengthSubsetSummary = False, returnSequenceNumber = False, returnStudentAutoSchedulerCourseID = False, returnStudentAutoSchedulerSectionID = False, returnStudentAutoSchedulerStudentID = False, returnStudentCourseRequestID = False, returnUpdatedDuringThisSchedulingRun = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerStudentCourseRequest in the district.

    This function returns a dataframe of every StudentAutoSchedulerStudentCourseRequest in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerStudentCourseRequest(StudentAutoSchedulerStudentCourseRequestID, EntityID = 1, returnStudentAutoSchedulerStudentCourseRequestID = False, returnCourseConflictReason = False, returnCourseConflictReasonCode = False, returnCourseConflictReasonText = False, returnCreatedTime = False, returnEntityIDRequestedFrom = False, returnEntityRequestedFromEntityCode = False, returnHasRelatedStudentAutoSchedulerStudentCourseRequestSections = False, returnInitialSequenceNumber = False, returnIsAlternate = False, returnModifiedTime = False, returnSchedulingMethodCode = False, returnSectionLengthSubsetsRequested = False, returnSectionLengthSubsetSummary = False, returnSequenceNumber = False, returnStudentAutoSchedulerCourseID = False, returnStudentAutoSchedulerSectionID = False, returnStudentAutoSchedulerStudentID = False, returnStudentCourseRequestID = False, returnUpdatedDuringThisSchedulingRun = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequest/" + str(StudentAutoSchedulerStudentCourseRequestID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerStudentCourseRequest(StudentAutoSchedulerStudentCourseRequestID, EntityID = 1, setStudentAutoSchedulerStudentCourseRequestID = None, setCourseConflictReason = None, setCourseConflictReasonCode = None, setCourseConflictReasonText = None, setCreatedTime = None, setEntityIDRequestedFrom = None, setEntityRequestedFromEntityCode = None, setHasRelatedStudentAutoSchedulerStudentCourseRequestSections = None, setInitialSequenceNumber = None, setIsAlternate = None, setModifiedTime = None, setSchedulingMethodCode = None, setSectionLengthSubsetsRequested = None, setSectionLengthSubsetSummary = None, setSequenceNumber = None, setStudentAutoSchedulerCourseID = None, setStudentAutoSchedulerSectionID = None, setStudentAutoSchedulerStudentID = None, setStudentCourseRequestID = None, setUpdatedDuringThisSchedulingRun = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerStudentCourseRequestID = False, returnCourseConflictReason = False, returnCourseConflictReasonCode = False, returnCourseConflictReasonText = False, returnCreatedTime = False, returnEntityIDRequestedFrom = False, returnEntityRequestedFromEntityCode = False, returnHasRelatedStudentAutoSchedulerStudentCourseRequestSections = False, returnInitialSequenceNumber = False, returnIsAlternate = False, returnModifiedTime = False, returnSchedulingMethodCode = False, returnSectionLengthSubsetsRequested = False, returnSectionLengthSubsetSummary = False, returnSequenceNumber = False, returnStudentAutoSchedulerCourseID = False, returnStudentAutoSchedulerSectionID = False, returnStudentAutoSchedulerStudentID = False, returnStudentCourseRequestID = False, returnUpdatedDuringThisSchedulingRun = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequest/" + str(StudentAutoSchedulerStudentCourseRequestID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerStudentCourseRequest(EntityID = 1, setStudentAutoSchedulerStudentCourseRequestID = None, setCourseConflictReason = None, setCourseConflictReasonCode = None, setCourseConflictReasonText = None, setCreatedTime = None, setEntityIDRequestedFrom = None, setEntityRequestedFromEntityCode = None, setHasRelatedStudentAutoSchedulerStudentCourseRequestSections = None, setInitialSequenceNumber = None, setIsAlternate = None, setModifiedTime = None, setSchedulingMethodCode = None, setSectionLengthSubsetsRequested = None, setSectionLengthSubsetSummary = None, setSequenceNumber = None, setStudentAutoSchedulerCourseID = None, setStudentAutoSchedulerSectionID = None, setStudentAutoSchedulerStudentID = None, setStudentCourseRequestID = None, setUpdatedDuringThisSchedulingRun = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerStudentCourseRequestID = False, returnCourseConflictReason = False, returnCourseConflictReasonCode = False, returnCourseConflictReasonText = False, returnCreatedTime = False, returnEntityIDRequestedFrom = False, returnEntityRequestedFromEntityCode = False, returnHasRelatedStudentAutoSchedulerStudentCourseRequestSections = False, returnInitialSequenceNumber = False, returnIsAlternate = False, returnModifiedTime = False, returnSchedulingMethodCode = False, returnSectionLengthSubsetsRequested = False, returnSectionLengthSubsetSummary = False, returnSequenceNumber = False, returnStudentAutoSchedulerCourseID = False, returnStudentAutoSchedulerSectionID = False, returnStudentAutoSchedulerStudentID = False, returnStudentCourseRequestID = False, returnUpdatedDuringThisSchedulingRun = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequest/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerStudentCourseRequest(StudentAutoSchedulerStudentCourseRequestID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequest/" + str(StudentAutoSchedulerStudentCourseRequestID), verb = "delete")


def getEveryStudentAutoSchedulerStudentCourseRequestSection(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerStudentCourseRequestSectionID = False, returnAssignedToThisSection = False, returnCreatedTime = False, returnEligibleToEnrollInSection = False, returnModifiedTime = False, returnPeriodDaySummary = False, returnSeatsRemaining = False, returnSequenceNumber = False, returnStudentAutoSchedulerSectionID = False, returnStudentAutoSchedulerStudentCourseRequestID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerStudentCourseRequestSection in the district.

    This function returns a dataframe of every StudentAutoSchedulerStudentCourseRequestSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerStudentCourseRequestSection(StudentAutoSchedulerStudentCourseRequestSectionID, EntityID = 1, returnStudentAutoSchedulerStudentCourseRequestSectionID = False, returnAssignedToThisSection = False, returnCreatedTime = False, returnEligibleToEnrollInSection = False, returnModifiedTime = False, returnPeriodDaySummary = False, returnSeatsRemaining = False, returnSequenceNumber = False, returnStudentAutoSchedulerSectionID = False, returnStudentAutoSchedulerStudentCourseRequestID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSection/" + str(StudentAutoSchedulerStudentCourseRequestSectionID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerStudentCourseRequestSection(StudentAutoSchedulerStudentCourseRequestSectionID, EntityID = 1, setStudentAutoSchedulerStudentCourseRequestSectionID = None, setAssignedToThisSection = None, setCreatedTime = None, setEligibleToEnrollInSection = None, setModifiedTime = None, setPeriodDaySummary = None, setSeatsRemaining = None, setSequenceNumber = None, setStudentAutoSchedulerSectionID = None, setStudentAutoSchedulerStudentCourseRequestID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerStudentCourseRequestSectionID = False, returnAssignedToThisSection = False, returnCreatedTime = False, returnEligibleToEnrollInSection = False, returnModifiedTime = False, returnPeriodDaySummary = False, returnSeatsRemaining = False, returnSequenceNumber = False, returnStudentAutoSchedulerSectionID = False, returnStudentAutoSchedulerStudentCourseRequestID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSection/" + str(StudentAutoSchedulerStudentCourseRequestSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerStudentCourseRequestSection(EntityID = 1, setStudentAutoSchedulerStudentCourseRequestSectionID = None, setAssignedToThisSection = None, setCreatedTime = None, setEligibleToEnrollInSection = None, setModifiedTime = None, setPeriodDaySummary = None, setSeatsRemaining = None, setSequenceNumber = None, setStudentAutoSchedulerSectionID = None, setStudentAutoSchedulerStudentCourseRequestID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerStudentCourseRequestSectionID = False, returnAssignedToThisSection = False, returnCreatedTime = False, returnEligibleToEnrollInSection = False, returnModifiedTime = False, returnPeriodDaySummary = False, returnSeatsRemaining = False, returnSequenceNumber = False, returnStudentAutoSchedulerSectionID = False, returnStudentAutoSchedulerStudentCourseRequestID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerStudentCourseRequestSection(StudentAutoSchedulerStudentCourseRequestSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSection/" + str(StudentAutoSchedulerStudentCourseRequestSectionID), verb = "delete")


def getEveryStudentAutoSchedulerStudentCourseRequestSectionDetail(searchConditions = [], EntityID = 1, returnStudentAutoSchedulerStudentCourseRequestSectionDetailID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionConflictReason = False, returnSectionConflictReasonCode = False, returnSectionConflictReasonText = False, returnStudentAutoSchedulerStudentCourseRequestSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentAutoSchedulerStudentCourseRequestSectionDetail in the district.

    This function returns a dataframe of every StudentAutoSchedulerStudentCourseRequestSectionDetail in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSectionDetail/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSectionDetail/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentAutoSchedulerStudentCourseRequestSectionDetail(StudentAutoSchedulerStudentCourseRequestSectionDetailID, EntityID = 1, returnStudentAutoSchedulerStudentCourseRequestSectionDetailID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionConflictReason = False, returnSectionConflictReasonCode = False, returnSectionConflictReasonText = False, returnStudentAutoSchedulerStudentCourseRequestSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSectionDetail/" + str(StudentAutoSchedulerStudentCourseRequestSectionDetailID), verb = "get", return_params_list = return_params)

def modifyStudentAutoSchedulerStudentCourseRequestSectionDetail(StudentAutoSchedulerStudentCourseRequestSectionDetailID, EntityID = 1, setStudentAutoSchedulerStudentCourseRequestSectionDetailID = None, setCreatedTime = None, setModifiedTime = None, setSectionConflictReason = None, setSectionConflictReasonCode = None, setSectionConflictReasonText = None, setStudentAutoSchedulerStudentCourseRequestSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerStudentCourseRequestSectionDetailID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionConflictReason = False, returnSectionConflictReasonCode = False, returnSectionConflictReasonText = False, returnStudentAutoSchedulerStudentCourseRequestSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSectionDetail/" + str(StudentAutoSchedulerStudentCourseRequestSectionDetailID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentAutoSchedulerStudentCourseRequestSectionDetail(EntityID = 1, setStudentAutoSchedulerStudentCourseRequestSectionDetailID = None, setCreatedTime = None, setModifiedTime = None, setSectionConflictReason = None, setSectionConflictReasonCode = None, setSectionConflictReasonText = None, setStudentAutoSchedulerStudentCourseRequestSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentAutoSchedulerStudentCourseRequestSectionDetailID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionConflictReason = False, returnSectionConflictReasonCode = False, returnSectionConflictReasonText = False, returnStudentAutoSchedulerStudentCourseRequestSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSectionDetail/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentAutoSchedulerStudentCourseRequestSectionDetail(StudentAutoSchedulerStudentCourseRequestSectionDetailID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentAutoSchedulerStudentCourseRequestSectionDetail/" + str(StudentAutoSchedulerStudentCourseRequestSectionDetailID), verb = "delete")


def getEveryStudentCourseRequest(searchConditions = [], EntityID = 1, returnStudentCourseRequestID = False, returnAlternateRank = False, returnCountsAgainstRequestLimit = False, returnCourseConflict = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsNotDroppedManualOrTransfer = False, returnCourseNotScheduled = False, returnCourseNotScheduledAndIsRequestedFromViewingEntity = False, returnCourseRequested = False, returnCourseScheduled = False, returnCourseScheduledAndAllTransactionsCountTowardsViewingEntity = False, returnCourseScheduledAndAllTransactionsCountTowardsViewingEntityAndCourseIsNotDropOrTransfer = False, returnCourseScheduledAndCountsTowardsViewingEntity = False, returnCourseScheduledAndInProgress = False, returnCourseScheduledAndInProgressAndIsEffectiveToViewingEntity = False, returnCourseScheduledAndIsBeforeOrInProgress = False, returnCourseScheduledAndIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnCourseScheduledAndIsRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnCourseScheduledAndRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnCreatedTime = False, returnCrsIsNotDrpOrTransferAndNotScheduledOrCrsScheduledAndRequestedFromViewingEntityAndAllTransactionsCntTowardsViewingEntity = False, returnDisplayToViewingEntity = False, returnEarnedCreditsPossibleAnticipated = False, returnEarnedCreditsRequested = False, returnEntityIDRequestedFrom = False, returnIsAlternate = False, returnModifiedTime = False, returnPrerequisiteMet = False, returnRequestedFromOfferingEntity = False, returnRequestedFromViewingEntity = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetSummary = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentCourseRequestIDHash = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionIDHash = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentCourseRequest in the district.

    This function returns a dataframe of every StudentCourseRequest in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentCourseRequest(StudentCourseRequestID, EntityID = 1, returnStudentCourseRequestID = False, returnAlternateRank = False, returnCountsAgainstRequestLimit = False, returnCourseConflict = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsNotDroppedManualOrTransfer = False, returnCourseNotScheduled = False, returnCourseNotScheduledAndIsRequestedFromViewingEntity = False, returnCourseRequested = False, returnCourseScheduled = False, returnCourseScheduledAndAllTransactionsCountTowardsViewingEntity = False, returnCourseScheduledAndAllTransactionsCountTowardsViewingEntityAndCourseIsNotDropOrTransfer = False, returnCourseScheduledAndCountsTowardsViewingEntity = False, returnCourseScheduledAndInProgress = False, returnCourseScheduledAndInProgressAndIsEffectiveToViewingEntity = False, returnCourseScheduledAndIsBeforeOrInProgress = False, returnCourseScheduledAndIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnCourseScheduledAndIsRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnCourseScheduledAndRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnCreatedTime = False, returnCrsIsNotDrpOrTransferAndNotScheduledOrCrsScheduledAndRequestedFromViewingEntityAndAllTransactionsCntTowardsViewingEntity = False, returnDisplayToViewingEntity = False, returnEarnedCreditsPossibleAnticipated = False, returnEarnedCreditsRequested = False, returnEntityIDRequestedFrom = False, returnIsAlternate = False, returnModifiedTime = False, returnPrerequisiteMet = False, returnRequestedFromOfferingEntity = False, returnRequestedFromViewingEntity = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetSummary = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentCourseRequestIDHash = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionIDHash = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequest/" + str(StudentCourseRequestID), verb = "get", return_params_list = return_params)

def modifyStudentCourseRequest(StudentCourseRequestID, EntityID = 1, setStudentCourseRequestID = None, setAlternateRank = None, setCountsAgainstRequestLimit = None, setCourseConflict = None, setCourseEntityOfferedToID = None, setCourseID = None, setCourseIsNotDroppedManualOrTransfer = None, setCourseNotScheduled = None, setCourseNotScheduledAndIsRequestedFromViewingEntity = None, setCourseRequested = None, setCourseScheduled = None, setCourseScheduledAndAllTransactionsCountTowardsViewingEntity = None, setCourseScheduledAndAllTransactionsCountTowardsViewingEntityAndCourseIsNotDropOrTransfer = None, setCourseScheduledAndCountsTowardsViewingEntity = None, setCourseScheduledAndInProgress = None, setCourseScheduledAndInProgressAndIsEffectiveToViewingEntity = None, setCourseScheduledAndIsBeforeOrInProgress = None, setCourseScheduledAndIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = None, setCourseScheduledAndIsRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = None, setCourseScheduledAndRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = None, setCreatedTime = None, setCrsIsNotDrpOrTransferAndNotScheduledOrCrsScheduledAndRequestedFromViewingEntityAndAllTransactionsCntTowardsViewingEntity = None, setDisplayToViewingEntity = None, setEarnedCreditsPossibleAnticipated = None, setEarnedCreditsRequested = None, setEntityIDRequestedFrom = None, setIsAlternate = None, setModifiedTime = None, setPrerequisiteMet = None, setRequestedFromOfferingEntity = None, setRequestedFromViewingEntity = None, setRequestSource = None, setRequestSourceCode = None, setRequestStatus = None, setRequestStatusCode = None, setSchedulingMethod = None, setSchedulingMethodCode = None, setSectionLengthSubsetCode = None, setSectionLengthSubsetDescription = None, setSectionLengthSubsetSummary = None, setStudentCourseRequestIDAlternateFor = None, setStudentCourseRequestIDHash = None, setStudentID = None, setStudentSectionID = None, setStudentSectionIDHash = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferingEntity = None, returnStudentCourseRequestID = False, returnAlternateRank = False, returnCountsAgainstRequestLimit = False, returnCourseConflict = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsNotDroppedManualOrTransfer = False, returnCourseNotScheduled = False, returnCourseNotScheduledAndIsRequestedFromViewingEntity = False, returnCourseRequested = False, returnCourseScheduled = False, returnCourseScheduledAndAllTransactionsCountTowardsViewingEntity = False, returnCourseScheduledAndAllTransactionsCountTowardsViewingEntityAndCourseIsNotDropOrTransfer = False, returnCourseScheduledAndCountsTowardsViewingEntity = False, returnCourseScheduledAndInProgress = False, returnCourseScheduledAndInProgressAndIsEffectiveToViewingEntity = False, returnCourseScheduledAndIsBeforeOrInProgress = False, returnCourseScheduledAndIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnCourseScheduledAndIsRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnCourseScheduledAndRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnCreatedTime = False, returnCrsIsNotDrpOrTransferAndNotScheduledOrCrsScheduledAndRequestedFromViewingEntityAndAllTransactionsCntTowardsViewingEntity = False, returnDisplayToViewingEntity = False, returnEarnedCreditsPossibleAnticipated = False, returnEarnedCreditsRequested = False, returnEntityIDRequestedFrom = False, returnIsAlternate = False, returnModifiedTime = False, returnPrerequisiteMet = False, returnRequestedFromOfferingEntity = False, returnRequestedFromViewingEntity = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetSummary = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentCourseRequestIDHash = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionIDHash = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequest/" + str(StudentCourseRequestID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentCourseRequest(EntityID = 1, setStudentCourseRequestID = None, setAlternateRank = None, setCountsAgainstRequestLimit = None, setCourseConflict = None, setCourseEntityOfferedToID = None, setCourseID = None, setCourseIsNotDroppedManualOrTransfer = None, setCourseNotScheduled = None, setCourseNotScheduledAndIsRequestedFromViewingEntity = None, setCourseRequested = None, setCourseScheduled = None, setCourseScheduledAndAllTransactionsCountTowardsViewingEntity = None, setCourseScheduledAndAllTransactionsCountTowardsViewingEntityAndCourseIsNotDropOrTransfer = None, setCourseScheduledAndCountsTowardsViewingEntity = None, setCourseScheduledAndInProgress = None, setCourseScheduledAndInProgressAndIsEffectiveToViewingEntity = None, setCourseScheduledAndIsBeforeOrInProgress = None, setCourseScheduledAndIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = None, setCourseScheduledAndIsRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = None, setCourseScheduledAndRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = None, setCreatedTime = None, setCrsIsNotDrpOrTransferAndNotScheduledOrCrsScheduledAndRequestedFromViewingEntityAndAllTransactionsCntTowardsViewingEntity = None, setDisplayToViewingEntity = None, setEarnedCreditsPossibleAnticipated = None, setEarnedCreditsRequested = None, setEntityIDRequestedFrom = None, setIsAlternate = None, setModifiedTime = None, setPrerequisiteMet = None, setRequestedFromOfferingEntity = None, setRequestedFromViewingEntity = None, setRequestSource = None, setRequestSourceCode = None, setRequestStatus = None, setRequestStatusCode = None, setSchedulingMethod = None, setSchedulingMethodCode = None, setSectionLengthSubsetCode = None, setSectionLengthSubsetDescription = None, setSectionLengthSubsetSummary = None, setStudentCourseRequestIDAlternateFor = None, setStudentCourseRequestIDHash = None, setStudentID = None, setStudentSectionID = None, setStudentSectionIDHash = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferingEntity = None, returnStudentCourseRequestID = False, returnAlternateRank = False, returnCountsAgainstRequestLimit = False, returnCourseConflict = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsNotDroppedManualOrTransfer = False, returnCourseNotScheduled = False, returnCourseNotScheduledAndIsRequestedFromViewingEntity = False, returnCourseRequested = False, returnCourseScheduled = False, returnCourseScheduledAndAllTransactionsCountTowardsViewingEntity = False, returnCourseScheduledAndAllTransactionsCountTowardsViewingEntityAndCourseIsNotDropOrTransfer = False, returnCourseScheduledAndCountsTowardsViewingEntity = False, returnCourseScheduledAndInProgress = False, returnCourseScheduledAndInProgressAndIsEffectiveToViewingEntity = False, returnCourseScheduledAndIsBeforeOrInProgress = False, returnCourseScheduledAndIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnCourseScheduledAndIsRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnCourseScheduledAndRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnCreatedTime = False, returnCrsIsNotDrpOrTransferAndNotScheduledOrCrsScheduledAndRequestedFromViewingEntityAndAllTransactionsCntTowardsViewingEntity = False, returnDisplayToViewingEntity = False, returnEarnedCreditsPossibleAnticipated = False, returnEarnedCreditsRequested = False, returnEntityIDRequestedFrom = False, returnIsAlternate = False, returnModifiedTime = False, returnPrerequisiteMet = False, returnRequestedFromOfferingEntity = False, returnRequestedFromViewingEntity = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetSummary = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentCourseRequestIDHash = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionIDHash = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequest/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentCourseRequest(StudentCourseRequestID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequest/" + str(StudentCourseRequestID), verb = "delete")


def getEveryStudentCourseRequestSectionLengthSubset(searchConditions = [], EntityID = 1, returnStudentCourseRequestSectionLengthSubsetID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionLengthSubsetID = False, returnStudentCourseRequestID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentCourseRequestSectionLengthSubset in the district.

    This function returns a dataframe of every StudentCourseRequestSectionLengthSubset in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequestSectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequestSectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentCourseRequestSectionLengthSubset(StudentCourseRequestSectionLengthSubsetID, EntityID = 1, returnStudentCourseRequestSectionLengthSubsetID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionLengthSubsetID = False, returnStudentCourseRequestID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequestSectionLengthSubset/" + str(StudentCourseRequestSectionLengthSubsetID), verb = "get", return_params_list = return_params)

def modifyStudentCourseRequestSectionLengthSubset(StudentCourseRequestSectionLengthSubsetID, EntityID = 1, setStudentCourseRequestSectionLengthSubsetID = None, setCreatedTime = None, setModifiedTime = None, setSectionLengthSubsetID = None, setStudentCourseRequestID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentCourseRequestSectionLengthSubsetID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionLengthSubsetID = False, returnStudentCourseRequestID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequestSectionLengthSubset/" + str(StudentCourseRequestSectionLengthSubsetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentCourseRequestSectionLengthSubset(EntityID = 1, setStudentCourseRequestSectionLengthSubsetID = None, setCreatedTime = None, setModifiedTime = None, setSectionLengthSubsetID = None, setStudentCourseRequestID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentCourseRequestSectionLengthSubsetID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionLengthSubsetID = False, returnStudentCourseRequestID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequestSectionLengthSubset/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentCourseRequestSectionLengthSubset(StudentCourseRequestSectionLengthSubsetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentCourseRequestSectionLengthSubset/" + str(StudentCourseRequestSectionLengthSubsetID), verb = "delete")


def getEveryStudentEntityYearSchedulingCategory(searchConditions = [], EntityID = 1, returnStudentEntityYearSchedulingCategoryID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingCategoryID = False, returnStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentEntityYearSchedulingCategory in the district.

    This function returns a dataframe of every StudentEntityYearSchedulingCategory in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentEntityYearSchedulingCategory/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentEntityYearSchedulingCategory/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentEntityYearSchedulingCategory(StudentEntityYearSchedulingCategoryID, EntityID = 1, returnStudentEntityYearSchedulingCategoryID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingCategoryID = False, returnStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentEntityYearSchedulingCategory/" + str(StudentEntityYearSchedulingCategoryID), verb = "get", return_params_list = return_params)

def modifyStudentEntityYearSchedulingCategory(StudentEntityYearSchedulingCategoryID, EntityID = 1, setStudentEntityYearSchedulingCategoryID = None, setCreatedTime = None, setModifiedTime = None, setSchedulingCategoryID = None, setStudentEntityYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentEntityYearSchedulingCategoryID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingCategoryID = False, returnStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentEntityYearSchedulingCategory/" + str(StudentEntityYearSchedulingCategoryID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentEntityYearSchedulingCategory(EntityID = 1, setStudentEntityYearSchedulingCategoryID = None, setCreatedTime = None, setModifiedTime = None, setSchedulingCategoryID = None, setStudentEntityYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentEntityYearSchedulingCategoryID = False, returnCreatedTime = False, returnModifiedTime = False, returnSchedulingCategoryID = False, returnStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentEntityYearSchedulingCategory/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentEntityYearSchedulingCategory(StudentEntityYearSchedulingCategoryID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentEntityYearSchedulingCategory/" + str(StudentEntityYearSchedulingCategoryID), verb = "delete")


def getEveryStudentSection(searchConditions = [], EntityID = 1, returnStudentSectionID = False, returnAcademicHistoryHash = False, returnActiveStudentGroups = False, returnAllTransactionsCountTowardsViewingEntity = False, returnAssignmentDueDateAttendance = False, returnConversionKey = False, returnCountsForViewingEntity = False, returnCourseOrTransferDescription = False, returnCreatedTime = False, returnDisplayLinkedStudentSection = False, returnDisplayToViewingEntity = False, returnEarnedCreditAttempted = False, returnEarnedCreditAttemptedAllEntered = False, returnEarnedCreditAttemptedCompleted = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEarnedCreditsAllEntered = False, returnEarnedCreditsCompleted = False, returnEarnedCreditsPossible = False, returnEarnedCreditsPossibleAllEntered = False, returnEarnedCreditsPossibleCompleted = False, returnEndDate = False, returnEntityIDCourse = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnExistsStudentSectionGPAMethods = False, returnFailedCredits = False, returnFailedCreditsAllEntered = False, returnFailedCreditsCompleted = False, returnFilteredGradedAssignmentCount = False, returnFilteredMissingAssignmentCount = False, returnFilteredUnGradedAssignmentCount = False, returnGradebookSortCode = False, returnGradebookStudentNameToUse = False, returnGradeReferenceID = False, returnHasAtLeastOneCrossEntityStudentSectionTransaction = False, returnHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnHasLinkingConflicts = False, returnHasStudentGradingScaleGroupForGradingPeriodGradeBucket = False, returnHasStudentSectionNoteForCurrentUser = False, returnInProgress = False, returnInProgressAndIsEffectiveForViewingEntity = False, returnIsActiveAsOfDate = False, returnIsActiveForTodayOrForSectionStartOrEnd = False, returnIsAvailableForAssignmentStudentGroup = False, returnIsBeforeOrInProgress = False, returnIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnIsCurrentStudentSection = False, returnIsEffectiveForViewingEntity = False, returnIsFlaggedAsMissingAssignmentCount = False, returnIsForCurrentSchoolYear = False, returnIsStudentSectionScheduledToMeet = False, returnIsTransferCourse = False, returnIsTSAProficient = False, returnIsWorkInProgress = False, returnLastStudentSectionTransactionConsideredDropped = False, returnLinkedStudentSectionsEarnedCredit = False, returnLinkedStudentSectionsEarnedCreditAttempted = False, returnLinkedStudentSectionsFailedCredit = False, returnMissingAssignmentCount = False, returnModifiedTime = False, returnMultipleTransactions = False, returnRenderTransferGradesRowButton = False, returnRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnSchoolYearIDCourse = False, returnSectionID = False, returnSectionLengthSubsetSummary = False, returnStartDate = False, returnStatus = False, returnStatusCode = False, returnStatusString = False, returnStudentID = False, returnStudentSectionCode = False, returnStudentSectionIDHash = False, returnStudentSectionLink = False, returnStudentSectionMNID = False, returnStudentSectionNoteCountForCurrentUser = False, returnTotalDaysAbsent = False, returnTotalDaysExcused = False, returnTotalDaysOther = False, returnTotalDaysTardy = False, returnTotalDaysUnexcused = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransactionCountsForViewingEntity = False, returnTransferCourseName = False, returnUnscoredPastDueAssignmentCount = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentSection in the district.

    This function returns a dataframe of every StudentSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentSection(StudentSectionID, EntityID = 1, returnStudentSectionID = False, returnAcademicHistoryHash = False, returnActiveStudentGroups = False, returnAllTransactionsCountTowardsViewingEntity = False, returnAssignmentDueDateAttendance = False, returnConversionKey = False, returnCountsForViewingEntity = False, returnCourseOrTransferDescription = False, returnCreatedTime = False, returnDisplayLinkedStudentSection = False, returnDisplayToViewingEntity = False, returnEarnedCreditAttempted = False, returnEarnedCreditAttemptedAllEntered = False, returnEarnedCreditAttemptedCompleted = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEarnedCreditsAllEntered = False, returnEarnedCreditsCompleted = False, returnEarnedCreditsPossible = False, returnEarnedCreditsPossibleAllEntered = False, returnEarnedCreditsPossibleCompleted = False, returnEndDate = False, returnEntityIDCourse = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnExistsStudentSectionGPAMethods = False, returnFailedCredits = False, returnFailedCreditsAllEntered = False, returnFailedCreditsCompleted = False, returnFilteredGradedAssignmentCount = False, returnFilteredMissingAssignmentCount = False, returnFilteredUnGradedAssignmentCount = False, returnGradebookSortCode = False, returnGradebookStudentNameToUse = False, returnGradeReferenceID = False, returnHasAtLeastOneCrossEntityStudentSectionTransaction = False, returnHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnHasLinkingConflicts = False, returnHasStudentGradingScaleGroupForGradingPeriodGradeBucket = False, returnHasStudentSectionNoteForCurrentUser = False, returnInProgress = False, returnInProgressAndIsEffectiveForViewingEntity = False, returnIsActiveAsOfDate = False, returnIsActiveForTodayOrForSectionStartOrEnd = False, returnIsAvailableForAssignmentStudentGroup = False, returnIsBeforeOrInProgress = False, returnIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnIsCurrentStudentSection = False, returnIsEffectiveForViewingEntity = False, returnIsFlaggedAsMissingAssignmentCount = False, returnIsForCurrentSchoolYear = False, returnIsStudentSectionScheduledToMeet = False, returnIsTransferCourse = False, returnIsTSAProficient = False, returnIsWorkInProgress = False, returnLastStudentSectionTransactionConsideredDropped = False, returnLinkedStudentSectionsEarnedCredit = False, returnLinkedStudentSectionsEarnedCreditAttempted = False, returnLinkedStudentSectionsFailedCredit = False, returnMissingAssignmentCount = False, returnModifiedTime = False, returnMultipleTransactions = False, returnRenderTransferGradesRowButton = False, returnRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnSchoolYearIDCourse = False, returnSectionID = False, returnSectionLengthSubsetSummary = False, returnStartDate = False, returnStatus = False, returnStatusCode = False, returnStatusString = False, returnStudentID = False, returnStudentSectionCode = False, returnStudentSectionIDHash = False, returnStudentSectionLink = False, returnStudentSectionMNID = False, returnStudentSectionNoteCountForCurrentUser = False, returnTotalDaysAbsent = False, returnTotalDaysExcused = False, returnTotalDaysOther = False, returnTotalDaysTardy = False, returnTotalDaysUnexcused = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransactionCountsForViewingEntity = False, returnTransferCourseName = False, returnUnscoredPastDueAssignmentCount = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSection/" + str(StudentSectionID), verb = "get", return_params_list = return_params)

def modifyStudentSection(StudentSectionID, EntityID = 1, setStudentSectionID = None, setAcademicHistoryHash = None, setActiveStudentGroups = None, setAllTransactionsCountTowardsViewingEntity = None, setAssignmentDueDateAttendance = None, setConversionKey = None, setCountsForViewingEntity = None, setCourseOrTransferDescription = None, setCreatedTime = None, setDisplayLinkedStudentSection = None, setDisplayToViewingEntity = None, setEarnedCreditAttempted = None, setEarnedCreditAttemptedAllEntered = None, setEarnedCreditAttemptedCompleted = None, setEarnedCreditOverride = None, setEarnedCredits = None, setEarnedCreditsAllEntered = None, setEarnedCreditsCompleted = None, setEarnedCreditsPossible = None, setEarnedCreditsPossibleAllEntered = None, setEarnedCreditsPossibleCompleted = None, setEndDate = None, setEntityIDCourse = None, setExcludeFromReportCardsAndTranscripts = None, setExcludeFromStudentSectionLink = None, setExistsStudentSectionGPAMethods = None, setFailedCredits = None, setFailedCreditsAllEntered = None, setFailedCreditsCompleted = None, setFilteredGradedAssignmentCount = None, setFilteredMissingAssignmentCount = None, setFilteredUnGradedAssignmentCount = None, setGradebookSortCode = None, setGradebookStudentNameToUse = None, setGradeReferenceID = None, setHasAtLeastOneCrossEntityStudentSectionTransaction = None, setHasAtleastOneTransactionNotCountTowardsViewingEntity = None, setHasLinkingConflicts = None, setHasStudentGradingScaleGroupForGradingPeriodGradeBucket = None, setHasStudentSectionNoteForCurrentUser = None, setInProgress = None, setInProgressAndIsEffectiveForViewingEntity = None, setIsActiveAsOfDate = None, setIsActiveForTodayOrForSectionStartOrEnd = None, setIsAvailableForAssignmentStudentGroup = None, setIsBeforeOrInProgress = None, setIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = None, setIsCurrentStudentSection = None, setIsEffectiveForViewingEntity = None, setIsFlaggedAsMissingAssignmentCount = None, setIsForCurrentSchoolYear = None, setIsStudentSectionScheduledToMeet = None, setIsTransferCourse = None, setIsTSAProficient = None, setIsWorkInProgress = None, setLastStudentSectionTransactionConsideredDropped = None, setLinkedStudentSectionsEarnedCredit = None, setLinkedStudentSectionsEarnedCreditAttempted = None, setLinkedStudentSectionsFailedCredit = None, setMissingAssignmentCount = None, setModifiedTime = None, setMultipleTransactions = None, setRenderTransferGradesRowButton = None, setRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = None, setRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = None, setSchoolYearIDCourse = None, setSectionID = None, setSectionLengthSubsetSummary = None, setStartDate = None, setStatus = None, setStatusCode = None, setStatusString = None, setStudentID = None, setStudentSectionCode = None, setStudentSectionIDHash = None, setStudentSectionLink = None, setStudentSectionMNID = None, setStudentSectionNoteCountForCurrentUser = None, setTotalDaysAbsent = None, setTotalDaysExcused = None, setTotalDaysOther = None, setTotalDaysTardy = None, setTotalDaysUnexcused = None, setTotalEarnedCreditOverride = None, setTotalFailedCreditOverride = None, setTransactionCountsForViewingEntity = None, setTransferCourseName = None, setUnscoredPastDueAssignmentCount = None, setUseEarnedCreditOverride = None, setUseEarnedCreditTotalOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferingEntity = None, returnStudentSectionID = False, returnAcademicHistoryHash = False, returnActiveStudentGroups = False, returnAllTransactionsCountTowardsViewingEntity = False, returnAssignmentDueDateAttendance = False, returnConversionKey = False, returnCountsForViewingEntity = False, returnCourseOrTransferDescription = False, returnCreatedTime = False, returnDisplayLinkedStudentSection = False, returnDisplayToViewingEntity = False, returnEarnedCreditAttempted = False, returnEarnedCreditAttemptedAllEntered = False, returnEarnedCreditAttemptedCompleted = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEarnedCreditsAllEntered = False, returnEarnedCreditsCompleted = False, returnEarnedCreditsPossible = False, returnEarnedCreditsPossibleAllEntered = False, returnEarnedCreditsPossibleCompleted = False, returnEndDate = False, returnEntityIDCourse = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnExistsStudentSectionGPAMethods = False, returnFailedCredits = False, returnFailedCreditsAllEntered = False, returnFailedCreditsCompleted = False, returnFilteredGradedAssignmentCount = False, returnFilteredMissingAssignmentCount = False, returnFilteredUnGradedAssignmentCount = False, returnGradebookSortCode = False, returnGradebookStudentNameToUse = False, returnGradeReferenceID = False, returnHasAtLeastOneCrossEntityStudentSectionTransaction = False, returnHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnHasLinkingConflicts = False, returnHasStudentGradingScaleGroupForGradingPeriodGradeBucket = False, returnHasStudentSectionNoteForCurrentUser = False, returnInProgress = False, returnInProgressAndIsEffectiveForViewingEntity = False, returnIsActiveAsOfDate = False, returnIsActiveForTodayOrForSectionStartOrEnd = False, returnIsAvailableForAssignmentStudentGroup = False, returnIsBeforeOrInProgress = False, returnIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnIsCurrentStudentSection = False, returnIsEffectiveForViewingEntity = False, returnIsFlaggedAsMissingAssignmentCount = False, returnIsForCurrentSchoolYear = False, returnIsStudentSectionScheduledToMeet = False, returnIsTransferCourse = False, returnIsTSAProficient = False, returnIsWorkInProgress = False, returnLastStudentSectionTransactionConsideredDropped = False, returnLinkedStudentSectionsEarnedCredit = False, returnLinkedStudentSectionsEarnedCreditAttempted = False, returnLinkedStudentSectionsFailedCredit = False, returnMissingAssignmentCount = False, returnModifiedTime = False, returnMultipleTransactions = False, returnRenderTransferGradesRowButton = False, returnRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnSchoolYearIDCourse = False, returnSectionID = False, returnSectionLengthSubsetSummary = False, returnStartDate = False, returnStatus = False, returnStatusCode = False, returnStatusString = False, returnStudentID = False, returnStudentSectionCode = False, returnStudentSectionIDHash = False, returnStudentSectionLink = False, returnStudentSectionMNID = False, returnStudentSectionNoteCountForCurrentUser = False, returnTotalDaysAbsent = False, returnTotalDaysExcused = False, returnTotalDaysOther = False, returnTotalDaysTardy = False, returnTotalDaysUnexcused = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransactionCountsForViewingEntity = False, returnTransferCourseName = False, returnUnscoredPastDueAssignmentCount = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSection/" + str(StudentSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentSection(EntityID = 1, setStudentSectionID = None, setAcademicHistoryHash = None, setActiveStudentGroups = None, setAllTransactionsCountTowardsViewingEntity = None, setAssignmentDueDateAttendance = None, setConversionKey = None, setCountsForViewingEntity = None, setCourseOrTransferDescription = None, setCreatedTime = None, setDisplayLinkedStudentSection = None, setDisplayToViewingEntity = None, setEarnedCreditAttempted = None, setEarnedCreditAttemptedAllEntered = None, setEarnedCreditAttemptedCompleted = None, setEarnedCreditOverride = None, setEarnedCredits = None, setEarnedCreditsAllEntered = None, setEarnedCreditsCompleted = None, setEarnedCreditsPossible = None, setEarnedCreditsPossibleAllEntered = None, setEarnedCreditsPossibleCompleted = None, setEndDate = None, setEntityIDCourse = None, setExcludeFromReportCardsAndTranscripts = None, setExcludeFromStudentSectionLink = None, setExistsStudentSectionGPAMethods = None, setFailedCredits = None, setFailedCreditsAllEntered = None, setFailedCreditsCompleted = None, setFilteredGradedAssignmentCount = None, setFilteredMissingAssignmentCount = None, setFilteredUnGradedAssignmentCount = None, setGradebookSortCode = None, setGradebookStudentNameToUse = None, setGradeReferenceID = None, setHasAtLeastOneCrossEntityStudentSectionTransaction = None, setHasAtleastOneTransactionNotCountTowardsViewingEntity = None, setHasLinkingConflicts = None, setHasStudentGradingScaleGroupForGradingPeriodGradeBucket = None, setHasStudentSectionNoteForCurrentUser = None, setInProgress = None, setInProgressAndIsEffectiveForViewingEntity = None, setIsActiveAsOfDate = None, setIsActiveForTodayOrForSectionStartOrEnd = None, setIsAvailableForAssignmentStudentGroup = None, setIsBeforeOrInProgress = None, setIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = None, setIsCurrentStudentSection = None, setIsEffectiveForViewingEntity = None, setIsFlaggedAsMissingAssignmentCount = None, setIsForCurrentSchoolYear = None, setIsStudentSectionScheduledToMeet = None, setIsTransferCourse = None, setIsTSAProficient = None, setIsWorkInProgress = None, setLastStudentSectionTransactionConsideredDropped = None, setLinkedStudentSectionsEarnedCredit = None, setLinkedStudentSectionsEarnedCreditAttempted = None, setLinkedStudentSectionsFailedCredit = None, setMissingAssignmentCount = None, setModifiedTime = None, setMultipleTransactions = None, setRenderTransferGradesRowButton = None, setRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = None, setRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = None, setSchoolYearIDCourse = None, setSectionID = None, setSectionLengthSubsetSummary = None, setStartDate = None, setStatus = None, setStatusCode = None, setStatusString = None, setStudentID = None, setStudentSectionCode = None, setStudentSectionIDHash = None, setStudentSectionLink = None, setStudentSectionMNID = None, setStudentSectionNoteCountForCurrentUser = None, setTotalDaysAbsent = None, setTotalDaysExcused = None, setTotalDaysOther = None, setTotalDaysTardy = None, setTotalDaysUnexcused = None, setTotalEarnedCreditOverride = None, setTotalFailedCreditOverride = None, setTransactionCountsForViewingEntity = None, setTransferCourseName = None, setUnscoredPastDueAssignmentCount = None, setUseEarnedCreditOverride = None, setUseEarnedCreditTotalOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setViewingFromOfferingEntity = None, returnStudentSectionID = False, returnAcademicHistoryHash = False, returnActiveStudentGroups = False, returnAllTransactionsCountTowardsViewingEntity = False, returnAssignmentDueDateAttendance = False, returnConversionKey = False, returnCountsForViewingEntity = False, returnCourseOrTransferDescription = False, returnCreatedTime = False, returnDisplayLinkedStudentSection = False, returnDisplayToViewingEntity = False, returnEarnedCreditAttempted = False, returnEarnedCreditAttemptedAllEntered = False, returnEarnedCreditAttemptedCompleted = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEarnedCreditsAllEntered = False, returnEarnedCreditsCompleted = False, returnEarnedCreditsPossible = False, returnEarnedCreditsPossibleAllEntered = False, returnEarnedCreditsPossibleCompleted = False, returnEndDate = False, returnEntityIDCourse = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnExistsStudentSectionGPAMethods = False, returnFailedCredits = False, returnFailedCreditsAllEntered = False, returnFailedCreditsCompleted = False, returnFilteredGradedAssignmentCount = False, returnFilteredMissingAssignmentCount = False, returnFilteredUnGradedAssignmentCount = False, returnGradebookSortCode = False, returnGradebookStudentNameToUse = False, returnGradeReferenceID = False, returnHasAtLeastOneCrossEntityStudentSectionTransaction = False, returnHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnHasLinkingConflicts = False, returnHasStudentGradingScaleGroupForGradingPeriodGradeBucket = False, returnHasStudentSectionNoteForCurrentUser = False, returnInProgress = False, returnInProgressAndIsEffectiveForViewingEntity = False, returnIsActiveAsOfDate = False, returnIsActiveForTodayOrForSectionStartOrEnd = False, returnIsAvailableForAssignmentStudentGroup = False, returnIsBeforeOrInProgress = False, returnIsBeforeOrInProgressAndNotHasAtleastOneTransactionNotCountTowardsViewingEntity = False, returnIsCurrentStudentSection = False, returnIsEffectiveForViewingEntity = False, returnIsFlaggedAsMissingAssignmentCount = False, returnIsForCurrentSchoolYear = False, returnIsStudentSectionScheduledToMeet = False, returnIsTransferCourse = False, returnIsTSAProficient = False, returnIsWorkInProgress = False, returnLastStudentSectionTransactionConsideredDropped = False, returnLinkedStudentSectionsEarnedCredit = False, returnLinkedStudentSectionsEarnedCreditAttempted = False, returnLinkedStudentSectionsFailedCredit = False, returnMissingAssignmentCount = False, returnModifiedTime = False, returnMultipleTransactions = False, returnRenderTransferGradesRowButton = False, returnRequestedFromOfferingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnRequestedFromViewingEntityAndAllTransactionsCountTowardsViewingEntity = False, returnSchoolYearIDCourse = False, returnSectionID = False, returnSectionLengthSubsetSummary = False, returnStartDate = False, returnStatus = False, returnStatusCode = False, returnStatusString = False, returnStudentID = False, returnStudentSectionCode = False, returnStudentSectionIDHash = False, returnStudentSectionLink = False, returnStudentSectionMNID = False, returnStudentSectionNoteCountForCurrentUser = False, returnTotalDaysAbsent = False, returnTotalDaysExcused = False, returnTotalDaysOther = False, returnTotalDaysTardy = False, returnTotalDaysUnexcused = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransactionCountsForViewingEntity = False, returnTransferCourseName = False, returnUnscoredPastDueAssignmentCount = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnViewingFromOfferingEntity = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentSection(StudentSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSection/" + str(StudentSectionID), verb = "delete")


def getEveryStudentSectionTransaction(searchConditions = [], EntityID = 1, returnStudentSectionTransactionID = False, returnCalendarID = False, returnCountsTowardsViewingEntity = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEndsAfterSectionLengthStartDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnIsCECE = False, returnIsInProgress = False, returnIsInProgressAsOfToday = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnOverlapsSectionLength = False, returnSectionID = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionIDHash = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentSectionTransaction in the district.

    This function returns a dataframe of every StudentSectionTransaction in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransaction/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransaction/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentSectionTransaction(StudentSectionTransactionID, EntityID = 1, returnStudentSectionTransactionID = False, returnCalendarID = False, returnCountsTowardsViewingEntity = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEndsAfterSectionLengthStartDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnIsCECE = False, returnIsInProgress = False, returnIsInProgressAsOfToday = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnOverlapsSectionLength = False, returnSectionID = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionIDHash = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransaction/" + str(StudentSectionTransactionID), verb = "get", return_params_list = return_params)

def modifyStudentSectionTransaction(StudentSectionTransactionID, EntityID = 1, setStudentSectionTransactionID = None, setCalendarID = None, setCountsTowardsViewingEntity = None, setCreatedTime = None, setEarlyExitReasonID = None, setEndDate = None, setEndsAfterSectionLengthStartDate = None, setEntityIDCountsAs = None, setHideNewStudentButton = None, setIsCECE = None, setIsInProgress = None, setIsInProgressAsOfToday = None, setModifiedTime = None, setNameIDRequestedBy = None, setOverlapsSectionLength = None, setSectionID = None, setSectionLengthSubsetID = None, setStartDate = None, setStudentID = None, setStudentSectionID = None, setStudentSectionTransactionIDHash = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentSectionTransactionID = False, returnCalendarID = False, returnCountsTowardsViewingEntity = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEndsAfterSectionLengthStartDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnIsCECE = False, returnIsInProgress = False, returnIsInProgressAsOfToday = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnOverlapsSectionLength = False, returnSectionID = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionIDHash = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransaction/" + str(StudentSectionTransactionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentSectionTransaction(EntityID = 1, setStudentSectionTransactionID = None, setCalendarID = None, setCountsTowardsViewingEntity = None, setCreatedTime = None, setEarlyExitReasonID = None, setEndDate = None, setEndsAfterSectionLengthStartDate = None, setEntityIDCountsAs = None, setHideNewStudentButton = None, setIsCECE = None, setIsInProgress = None, setIsInProgressAsOfToday = None, setModifiedTime = None, setNameIDRequestedBy = None, setOverlapsSectionLength = None, setSectionID = None, setSectionLengthSubsetID = None, setStartDate = None, setStudentID = None, setStudentSectionID = None, setStudentSectionTransactionIDHash = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudentSectionTransactionID = False, returnCalendarID = False, returnCountsTowardsViewingEntity = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEndsAfterSectionLengthStartDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnIsCECE = False, returnIsInProgress = False, returnIsInProgressAsOfToday = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnOverlapsSectionLength = False, returnSectionID = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionIDHash = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransaction/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentSectionTransaction(StudentSectionTransactionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransaction/" + str(StudentSectionTransactionID), verb = "delete")


def getEveryStudentSectionTransactionRoomPeriod(searchConditions = [], EntityID = 1, returnStudentSectionTransactionID = False, returnCalendarID = False, returnDisplayPeriodID = False, returnEndDateMeet = False, returnEndDateSectionSectionTransaction = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsDefaultCalendar = False, returnMeetID = False, returnMeetSummaryID = False, returnRoomID = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDateMeet = False, returnStartDateStudentSectionTransaction = False, returnStudentID = False, returnStudentSectionID = False, returnUseRoomOverride = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudentSectionTransactionRoomPeriod in the district.

    This function returns a dataframe of every StudentSectionTransactionRoomPeriod in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransactionRoomPeriod/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransactionRoomPeriod/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudentSectionTransactionRoomPeriod(StudentSectionTransactionID, EntityID = 1, returnStudentSectionTransactionID = False, returnCalendarID = False, returnDisplayPeriodID = False, returnEndDateMeet = False, returnEndDateSectionSectionTransaction = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsDefaultCalendar = False, returnMeetID = False, returnMeetSummaryID = False, returnRoomID = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDateMeet = False, returnStartDateStudentSectionTransaction = False, returnStudentID = False, returnStudentSectionID = False, returnUseRoomOverride = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransactionRoomPeriod/" + str(StudentSectionTransactionID), verb = "get", return_params_list = return_params)

def modifyStudentSectionTransactionRoomPeriod(StudentSectionTransactionID, EntityID = 1, setStudentSectionTransactionID = None, setCalendarID = None, setDisplayPeriodID = None, setEndDateMeet = None, setEndDateSectionSectionTransaction = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setEntityIDFor = None, setEntityIDViewingCalculated = None, setEntityIDViewingMeetSummary = None, setIsDefaultCalendar = None, setMeetID = None, setMeetSummaryID = None, setRoomID = None, setSchedulingPeriodID = None, setSchoolYearID = None, setSectionID = None, setStartDateMeet = None, setStartDateStudentSectionTransaction = None, setStudentID = None, setStudentSectionID = None, setUseRoomOverride = None, returnStudentSectionTransactionID = False, returnCalendarID = False, returnDisplayPeriodID = False, returnEndDateMeet = False, returnEndDateSectionSectionTransaction = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsDefaultCalendar = False, returnMeetID = False, returnMeetSummaryID = False, returnRoomID = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDateMeet = False, returnStartDateStudentSectionTransaction = False, returnStudentID = False, returnStudentSectionID = False, returnUseRoomOverride = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransactionRoomPeriod/" + str(StudentSectionTransactionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudentSectionTransactionRoomPeriod(EntityID = 1, setStudentSectionTransactionID = None, setCalendarID = None, setDisplayPeriodID = None, setEndDateMeet = None, setEndDateSectionSectionTransaction = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setEntityIDFor = None, setEntityIDViewingCalculated = None, setEntityIDViewingMeetSummary = None, setIsDefaultCalendar = None, setMeetID = None, setMeetSummaryID = None, setRoomID = None, setSchedulingPeriodID = None, setSchoolYearID = None, setSectionID = None, setStartDateMeet = None, setStartDateStudentSectionTransaction = None, setStudentID = None, setStudentSectionID = None, setUseRoomOverride = None, returnStudentSectionTransactionID = False, returnCalendarID = False, returnDisplayPeriodID = False, returnEndDateMeet = False, returnEndDateSectionSectionTransaction = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDFor = False, returnEntityIDViewingCalculated = False, returnEntityIDViewingMeetSummary = False, returnIsDefaultCalendar = False, returnMeetID = False, returnMeetSummaryID = False, returnRoomID = False, returnSchedulingPeriodID = False, returnSchoolYearID = False, returnSectionID = False, returnStartDateMeet = False, returnStartDateStudentSectionTransaction = False, returnStudentID = False, returnStudentSectionID = False, returnUseRoomOverride = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransactionRoomPeriod/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudentSectionTransactionRoomPeriod(StudentSectionTransactionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudentSectionTransactionRoomPeriod/" + str(StudentSectionTransactionID), verb = "delete")


def getEveryStudyHallSchedulerRunAnalysis(searchConditions = [], EntityID = 1, returnStudyHallSchedulerRunAnalysisID = False, returnBaseRunAnalysisID = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnEndTimeFinalize = False, returnModifiedTime = False, returnRunInformation = False, returnStartTimeAnalysis = False, returnStartTimeFinalize = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every StudyHallSchedulerRunAnalysis in the district.

    This function returns a dataframe of every StudyHallSchedulerRunAnalysis in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudyHallSchedulerRunAnalysis/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudyHallSchedulerRunAnalysis/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getStudyHallSchedulerRunAnalysis(StudyHallSchedulerRunAnalysisID, EntityID = 1, returnStudyHallSchedulerRunAnalysisID = False, returnBaseRunAnalysisID = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnEndTimeFinalize = False, returnModifiedTime = False, returnRunInformation = False, returnStartTimeAnalysis = False, returnStartTimeFinalize = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudyHallSchedulerRunAnalysis/" + str(StudyHallSchedulerRunAnalysisID), verb = "get", return_params_list = return_params)

def modifyStudyHallSchedulerRunAnalysis(StudyHallSchedulerRunAnalysisID, EntityID = 1, setStudyHallSchedulerRunAnalysisID = None, setBaseRunAnalysisID = None, setCreatedTime = None, setEndTimeAnalysis = None, setEndTimeFinalize = None, setModifiedTime = None, setRunInformation = None, setStartTimeAnalysis = None, setStartTimeFinalize = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudyHallSchedulerRunAnalysisID = False, returnBaseRunAnalysisID = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnEndTimeFinalize = False, returnModifiedTime = False, returnRunInformation = False, returnStartTimeAnalysis = False, returnStartTimeFinalize = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudyHallSchedulerRunAnalysis/" + str(StudyHallSchedulerRunAnalysisID), verb = "post", return_params_list = return_params, payload = payload_params)

def createStudyHallSchedulerRunAnalysis(EntityID = 1, setStudyHallSchedulerRunAnalysisID = None, setBaseRunAnalysisID = None, setCreatedTime = None, setEndTimeAnalysis = None, setEndTimeFinalize = None, setModifiedTime = None, setRunInformation = None, setStartTimeAnalysis = None, setStartTimeFinalize = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnStudyHallSchedulerRunAnalysisID = False, returnBaseRunAnalysisID = False, returnCreatedTime = False, returnEndTimeAnalysis = False, returnEndTimeFinalize = False, returnModifiedTime = False, returnRunInformation = False, returnStartTimeAnalysis = False, returnStartTimeFinalize = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudyHallSchedulerRunAnalysis/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteStudyHallSchedulerRunAnalysis(StudyHallSchedulerRunAnalysisID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/StudyHallSchedulerRunAnalysis/" + str(StudyHallSchedulerRunAnalysisID), verb = "delete")


def getEveryTempCourse(searchConditions = [], EntityID = 1, returnTempCourseID = False, returnActiveSections = False, returnAveragePerSectionMinimumSectionsRequired = False, returnCodeDescription = False, returnCourseCode = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseLengthID = False, returnCourseSubjectCode = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurriculumCode = False, returnDefaultSectionLengthID = False, returnDescription = False, returnEarnedCredits = False, returnEntityCode = False, returnEstimatedNumberOfSections = False, returnEstimatedStudentsPerSection = False, returnGradeLevelSummary = False, returnGradingPeriodSetCode = False, returnGradingPeriodSetID = False, returnIsActive = False, returnMinimumSectionsRequired = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewGradingPeriodSetCode = False, returnNewGradingPeriodSetID = False, returnNote = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfSeatsAvailable = False, returnNumberOfTransferStudentSections = False, returnObjectIsDirty = False, returnObjectName = False, returnOriginalEstimatedNumberOfSections = False, returnRecordsUpdated = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempCourse in the district.

    This function returns a dataframe of every TempCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempCourse(TempCourseID, EntityID = 1, returnTempCourseID = False, returnActiveSections = False, returnAveragePerSectionMinimumSectionsRequired = False, returnCodeDescription = False, returnCourseCode = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseLengthID = False, returnCourseSubjectCode = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurriculumCode = False, returnDefaultSectionLengthID = False, returnDescription = False, returnEarnedCredits = False, returnEntityCode = False, returnEstimatedNumberOfSections = False, returnEstimatedStudentsPerSection = False, returnGradeLevelSummary = False, returnGradingPeriodSetCode = False, returnGradingPeriodSetID = False, returnIsActive = False, returnMinimumSectionsRequired = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewGradingPeriodSetCode = False, returnNewGradingPeriodSetID = False, returnNote = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfSeatsAvailable = False, returnNumberOfTransferStudentSections = False, returnObjectIsDirty = False, returnObjectName = False, returnOriginalEstimatedNumberOfSections = False, returnRecordsUpdated = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourse/" + str(TempCourseID), verb = "get", return_params_list = return_params)

def modifyTempCourse(TempCourseID, EntityID = 1, setTempCourseID = None, setActiveSections = None, setAveragePerSectionMinimumSectionsRequired = None, setCodeDescription = None, setCourseCode = None, setCourseID = None, setCourseLengthCode = None, setCourseLengthID = None, setCourseSubjectCode = None, setCourseTypeCode = None, setCreatedTime = None, setCurriculumCode = None, setDefaultSectionLengthID = None, setDescription = None, setEarnedCredits = None, setEntityCode = None, setEstimatedNumberOfSections = None, setEstimatedStudentsPerSection = None, setGradeLevelSummary = None, setGradingPeriodSetCode = None, setGradingPeriodSetID = None, setIsActive = None, setMinimumSectionsRequired = None, setModifiedTime = None, setNewCourseLengthCode = None, setNewCourseLengthID = None, setNewGradingPeriodSetCode = None, setNewGradingPeriodSetID = None, setNote = None, setNumberOfAlternateCourseRequests = None, setNumberOfCourseRequests = None, setNumberOfSeatsAvailable = None, setNumberOfTransferStudentSections = None, setObjectIsDirty = None, setObjectName = None, setOriginalEstimatedNumberOfSections = None, setRecordsUpdated = None, setRowIsReadOnly = None, setRowIsSelected = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempCourseID = False, returnActiveSections = False, returnAveragePerSectionMinimumSectionsRequired = False, returnCodeDescription = False, returnCourseCode = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseLengthID = False, returnCourseSubjectCode = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurriculumCode = False, returnDefaultSectionLengthID = False, returnDescription = False, returnEarnedCredits = False, returnEntityCode = False, returnEstimatedNumberOfSections = False, returnEstimatedStudentsPerSection = False, returnGradeLevelSummary = False, returnGradingPeriodSetCode = False, returnGradingPeriodSetID = False, returnIsActive = False, returnMinimumSectionsRequired = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewGradingPeriodSetCode = False, returnNewGradingPeriodSetID = False, returnNote = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfSeatsAvailable = False, returnNumberOfTransferStudentSections = False, returnObjectIsDirty = False, returnObjectName = False, returnOriginalEstimatedNumberOfSections = False, returnRecordsUpdated = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourse/" + str(TempCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempCourse(EntityID = 1, setTempCourseID = None, setActiveSections = None, setAveragePerSectionMinimumSectionsRequired = None, setCodeDescription = None, setCourseCode = None, setCourseID = None, setCourseLengthCode = None, setCourseLengthID = None, setCourseSubjectCode = None, setCourseTypeCode = None, setCreatedTime = None, setCurriculumCode = None, setDefaultSectionLengthID = None, setDescription = None, setEarnedCredits = None, setEntityCode = None, setEstimatedNumberOfSections = None, setEstimatedStudentsPerSection = None, setGradeLevelSummary = None, setGradingPeriodSetCode = None, setGradingPeriodSetID = None, setIsActive = None, setMinimumSectionsRequired = None, setModifiedTime = None, setNewCourseLengthCode = None, setNewCourseLengthID = None, setNewGradingPeriodSetCode = None, setNewGradingPeriodSetID = None, setNote = None, setNumberOfAlternateCourseRequests = None, setNumberOfCourseRequests = None, setNumberOfSeatsAvailable = None, setNumberOfTransferStudentSections = None, setObjectIsDirty = None, setObjectName = None, setOriginalEstimatedNumberOfSections = None, setRecordsUpdated = None, setRowIsReadOnly = None, setRowIsSelected = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempCourseID = False, returnActiveSections = False, returnAveragePerSectionMinimumSectionsRequired = False, returnCodeDescription = False, returnCourseCode = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseLengthID = False, returnCourseSubjectCode = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurriculumCode = False, returnDefaultSectionLengthID = False, returnDescription = False, returnEarnedCredits = False, returnEntityCode = False, returnEstimatedNumberOfSections = False, returnEstimatedStudentsPerSection = False, returnGradeLevelSummary = False, returnGradingPeriodSetCode = False, returnGradingPeriodSetID = False, returnIsActive = False, returnMinimumSectionsRequired = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewGradingPeriodSetCode = False, returnNewGradingPeriodSetID = False, returnNote = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfSeatsAvailable = False, returnNumberOfTransferStudentSections = False, returnObjectIsDirty = False, returnObjectName = False, returnOriginalEstimatedNumberOfSections = False, returnRecordsUpdated = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempCourse(TempCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourse/" + str(TempCourseID), verb = "delete")


def getEveryTempCourseEntityOfferedToSection(searchConditions = [], EntityID = 1, returnTempCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionRecordExists = False, returnCourseID = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnEntityOfferedToCode = False, returnEntityOfferedToName = False, returnIsActiveOverride = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnOriginalMaximumStudentCount = False, returnRowIsSelected = False, returnSchoolYearID = False, returnSeatsAvailable = False, returnSectionCode = False, returnSectionID = False, returnSectionIsActive = False, returnSectionMaximumStudentCount = False, returnSectionReservedSeatCount = False, returnSectionSectionLengthCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempCourseEntityOfferedToSection in the district.

    This function returns a dataframe of every TempCourseEntityOfferedToSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseEntityOfferedToSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseEntityOfferedToSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempCourseEntityOfferedToSection(TempCourseEntityOfferedToSectionID, EntityID = 1, returnTempCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionRecordExists = False, returnCourseID = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnEntityOfferedToCode = False, returnEntityOfferedToName = False, returnIsActiveOverride = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnOriginalMaximumStudentCount = False, returnRowIsSelected = False, returnSchoolYearID = False, returnSeatsAvailable = False, returnSectionCode = False, returnSectionID = False, returnSectionIsActive = False, returnSectionMaximumStudentCount = False, returnSectionReservedSeatCount = False, returnSectionSectionLengthCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseEntityOfferedToSection/" + str(TempCourseEntityOfferedToSectionID), verb = "get", return_params_list = return_params)

def modifyTempCourseEntityOfferedToSection(TempCourseEntityOfferedToSectionID, EntityID = 1, setTempCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToID = None, setCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToSectionRecordExists = None, setCourseID = None, setCreatedTime = None, setEntityIDOfferedTo = None, setEntityOfferedToCode = None, setEntityOfferedToName = None, setIsActiveOverride = None, setMaximumStudentCount = None, setModifiedTime = None, setOriginalMaximumStudentCount = None, setRowIsSelected = None, setSchoolYearID = None, setSeatsAvailable = None, setSectionCode = None, setSectionID = None, setSectionIsActive = None, setSectionMaximumStudentCount = None, setSectionReservedSeatCount = None, setSectionSectionLengthCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionRecordExists = False, returnCourseID = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnEntityOfferedToCode = False, returnEntityOfferedToName = False, returnIsActiveOverride = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnOriginalMaximumStudentCount = False, returnRowIsSelected = False, returnSchoolYearID = False, returnSeatsAvailable = False, returnSectionCode = False, returnSectionID = False, returnSectionIsActive = False, returnSectionMaximumStudentCount = False, returnSectionReservedSeatCount = False, returnSectionSectionLengthCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseEntityOfferedToSection/" + str(TempCourseEntityOfferedToSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempCourseEntityOfferedToSection(EntityID = 1, setTempCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToID = None, setCourseEntityOfferedToSectionID = None, setCourseEntityOfferedToSectionRecordExists = None, setCourseID = None, setCreatedTime = None, setEntityIDOfferedTo = None, setEntityOfferedToCode = None, setEntityOfferedToName = None, setIsActiveOverride = None, setMaximumStudentCount = None, setModifiedTime = None, setOriginalMaximumStudentCount = None, setRowIsSelected = None, setSchoolYearID = None, setSeatsAvailable = None, setSectionCode = None, setSectionID = None, setSectionIsActive = None, setSectionMaximumStudentCount = None, setSectionReservedSeatCount = None, setSectionSectionLengthCode = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToID = False, returnCourseEntityOfferedToSectionID = False, returnCourseEntityOfferedToSectionRecordExists = False, returnCourseID = False, returnCreatedTime = False, returnEntityIDOfferedTo = False, returnEntityOfferedToCode = False, returnEntityOfferedToName = False, returnIsActiveOverride = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnOriginalMaximumStudentCount = False, returnRowIsSelected = False, returnSchoolYearID = False, returnSeatsAvailable = False, returnSectionCode = False, returnSectionID = False, returnSectionIsActive = False, returnSectionMaximumStudentCount = False, returnSectionReservedSeatCount = False, returnSectionSectionLengthCode = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseEntityOfferedToSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempCourseEntityOfferedToSection(TempCourseEntityOfferedToSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseEntityOfferedToSection/" + str(TempCourseEntityOfferedToSectionID), verb = "delete")


def getEveryTempCourseMasterMassUpdateError(searchConditions = [], EntityID = 1, returnTempCourseMasterMassUpdateErrorID = False, returnBaseTableName = False, returnCreatedTime = False, returnModifiedTime = False, returnSourceDescription = False, returnTableName = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempCourseMasterMassUpdateError in the district.

    This function returns a dataframe of every TempCourseMasterMassUpdateError in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateError/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateError/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempCourseMasterMassUpdateError(TempCourseMasterMassUpdateErrorID, EntityID = 1, returnTempCourseMasterMassUpdateErrorID = False, returnBaseTableName = False, returnCreatedTime = False, returnModifiedTime = False, returnSourceDescription = False, returnTableName = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateError/" + str(TempCourseMasterMassUpdateErrorID), verb = "get", return_params_list = return_params)

def modifyTempCourseMasterMassUpdateError(TempCourseMasterMassUpdateErrorID, EntityID = 1, setTempCourseMasterMassUpdateErrorID = None, setBaseTableName = None, setCreatedTime = None, setModifiedTime = None, setSourceDescription = None, setTableName = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempCourseMasterMassUpdateErrorID = False, returnBaseTableName = False, returnCreatedTime = False, returnModifiedTime = False, returnSourceDescription = False, returnTableName = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateError/" + str(TempCourseMasterMassUpdateErrorID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempCourseMasterMassUpdateError(EntityID = 1, setTempCourseMasterMassUpdateErrorID = None, setBaseTableName = None, setCreatedTime = None, setModifiedTime = None, setSourceDescription = None, setTableName = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempCourseMasterMassUpdateErrorID = False, returnBaseTableName = False, returnCreatedTime = False, returnModifiedTime = False, returnSourceDescription = False, returnTableName = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateError/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempCourseMasterMassUpdateError(TempCourseMasterMassUpdateErrorID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateError/" + str(TempCourseMasterMassUpdateErrorID), verb = "delete")


def getEveryTempCourseMasterMassUpdateErrorDetail(searchConditions = [], EntityID = 1, returnTempCourseMasterMassUpdateErrorDetailID = False, returnCreatedTime = False, returnError = False, returnErrorName = False, returnModifiedTime = False, returnTempCourseMasterMassUpdateErrorID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempCourseMasterMassUpdateErrorDetail in the district.

    This function returns a dataframe of every TempCourseMasterMassUpdateErrorDetail in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateErrorDetail/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateErrorDetail/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempCourseMasterMassUpdateErrorDetail(TempCourseMasterMassUpdateErrorDetailID, EntityID = 1, returnTempCourseMasterMassUpdateErrorDetailID = False, returnCreatedTime = False, returnError = False, returnErrorName = False, returnModifiedTime = False, returnTempCourseMasterMassUpdateErrorID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateErrorDetail/" + str(TempCourseMasterMassUpdateErrorDetailID), verb = "get", return_params_list = return_params)

def modifyTempCourseMasterMassUpdateErrorDetail(TempCourseMasterMassUpdateErrorDetailID, EntityID = 1, setTempCourseMasterMassUpdateErrorDetailID = None, setCreatedTime = None, setError = None, setErrorName = None, setModifiedTime = None, setTempCourseMasterMassUpdateErrorID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempCourseMasterMassUpdateErrorDetailID = False, returnCreatedTime = False, returnError = False, returnErrorName = False, returnModifiedTime = False, returnTempCourseMasterMassUpdateErrorID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateErrorDetail/" + str(TempCourseMasterMassUpdateErrorDetailID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempCourseMasterMassUpdateErrorDetail(EntityID = 1, setTempCourseMasterMassUpdateErrorDetailID = None, setCreatedTime = None, setError = None, setErrorName = None, setModifiedTime = None, setTempCourseMasterMassUpdateErrorID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempCourseMasterMassUpdateErrorDetailID = False, returnCreatedTime = False, returnError = False, returnErrorName = False, returnModifiedTime = False, returnTempCourseMasterMassUpdateErrorID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateErrorDetail/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempCourseMasterMassUpdateErrorDetail(TempCourseMasterMassUpdateErrorDetailID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateErrorDetail/" + str(TempCourseMasterMassUpdateErrorDetailID), verb = "delete")


def getEveryTempCourseMasterMassUpdateField(searchConditions = [], EntityID = 1, returnTempCourseMasterMassUpdateFieldID = False, returnAffectedPrimaryKey = False, returnBaseTableName = False, returnCourseID = False, returnCreatedTime = False, returnFieldDisplayName = False, returnFieldName = False, returnFriendlyOriginalValue = False, returnFriendlyUpdatedValue = False, returnModifiedTime = False, returnOriginalValue = False, returnSourceDescription = False, returnTableName = False, returnUpdatedValue = False, returnUpdateRank = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempCourseMasterMassUpdateField in the district.

    This function returns a dataframe of every TempCourseMasterMassUpdateField in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateField/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateField/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempCourseMasterMassUpdateField(TempCourseMasterMassUpdateFieldID, EntityID = 1, returnTempCourseMasterMassUpdateFieldID = False, returnAffectedPrimaryKey = False, returnBaseTableName = False, returnCourseID = False, returnCreatedTime = False, returnFieldDisplayName = False, returnFieldName = False, returnFriendlyOriginalValue = False, returnFriendlyUpdatedValue = False, returnModifiedTime = False, returnOriginalValue = False, returnSourceDescription = False, returnTableName = False, returnUpdatedValue = False, returnUpdateRank = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateField/" + str(TempCourseMasterMassUpdateFieldID), verb = "get", return_params_list = return_params)

def modifyTempCourseMasterMassUpdateField(TempCourseMasterMassUpdateFieldID, EntityID = 1, setTempCourseMasterMassUpdateFieldID = None, setAffectedPrimaryKey = None, setBaseTableName = None, setCourseID = None, setCreatedTime = None, setFieldDisplayName = None, setFieldName = None, setFriendlyOriginalValue = None, setFriendlyUpdatedValue = None, setModifiedTime = None, setOriginalValue = None, setSourceDescription = None, setTableName = None, setUpdatedValue = None, setUpdateRank = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempCourseMasterMassUpdateFieldID = False, returnAffectedPrimaryKey = False, returnBaseTableName = False, returnCourseID = False, returnCreatedTime = False, returnFieldDisplayName = False, returnFieldName = False, returnFriendlyOriginalValue = False, returnFriendlyUpdatedValue = False, returnModifiedTime = False, returnOriginalValue = False, returnSourceDescription = False, returnTableName = False, returnUpdatedValue = False, returnUpdateRank = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateField/" + str(TempCourseMasterMassUpdateFieldID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempCourseMasterMassUpdateField(EntityID = 1, setTempCourseMasterMassUpdateFieldID = None, setAffectedPrimaryKey = None, setBaseTableName = None, setCourseID = None, setCreatedTime = None, setFieldDisplayName = None, setFieldName = None, setFriendlyOriginalValue = None, setFriendlyUpdatedValue = None, setModifiedTime = None, setOriginalValue = None, setSourceDescription = None, setTableName = None, setUpdatedValue = None, setUpdateRank = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempCourseMasterMassUpdateFieldID = False, returnAffectedPrimaryKey = False, returnBaseTableName = False, returnCourseID = False, returnCreatedTime = False, returnFieldDisplayName = False, returnFieldName = False, returnFriendlyOriginalValue = False, returnFriendlyUpdatedValue = False, returnModifiedTime = False, returnOriginalValue = False, returnSourceDescription = False, returnTableName = False, returnUpdatedValue = False, returnUpdateRank = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateField/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempCourseMasterMassUpdateField(TempCourseMasterMassUpdateFieldID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempCourseMasterMassUpdateField/" + str(TempCourseMasterMassUpdateFieldID), verb = "delete")


def getEveryTempDayRotation(searchConditions = [], EntityID = 1, returnTempDayRotationID = False, returnCode = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnObjectName = False, returnRecordsUpdated = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempDayRotation in the district.

    This function returns a dataframe of every TempDayRotation in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempDayRotation/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempDayRotation/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempDayRotation(TempDayRotationID, EntityID = 1, returnTempDayRotationID = False, returnCode = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnObjectName = False, returnRecordsUpdated = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempDayRotation/" + str(TempDayRotationID), verb = "get", return_params_list = return_params)

def modifyTempDayRotation(TempDayRotationID, EntityID = 1, setTempDayRotationID = None, setCode = None, setCreatedTime = None, setDayRotationID = None, setModifiedTime = None, setNote = None, setObjectIsDirty = None, setObjectName = None, setRecordsUpdated = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempDayRotationID = False, returnCode = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnObjectName = False, returnRecordsUpdated = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempDayRotation/" + str(TempDayRotationID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempDayRotation(EntityID = 1, setTempDayRotationID = None, setCode = None, setCreatedTime = None, setDayRotationID = None, setModifiedTime = None, setNote = None, setObjectIsDirty = None, setObjectName = None, setRecordsUpdated = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempDayRotationID = False, returnCode = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnObjectName = False, returnRecordsUpdated = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempDayRotation/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempDayRotation(TempDayRotationID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempDayRotation/" + str(TempDayRotationID), verb = "delete")


def getEveryTempException(searchConditions = [], EntityID = 1, returnTempExceptionID = False, returnCreatedTime = False, returnErrorDetail = False, returnErrorFieldName = False, returnFailedRecordPrimaryKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempException in the district.

    This function returns a dataframe of every TempException in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempException/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempException/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempException(TempExceptionID, EntityID = 1, returnTempExceptionID = False, returnCreatedTime = False, returnErrorDetail = False, returnErrorFieldName = False, returnFailedRecordPrimaryKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempException/" + str(TempExceptionID), verb = "get", return_params_list = return_params)

def modifyTempException(TempExceptionID, EntityID = 1, setTempExceptionID = None, setCreatedTime = None, setErrorDetail = None, setErrorFieldName = None, setFailedRecordPrimaryKey = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempExceptionID = False, returnCreatedTime = False, returnErrorDetail = False, returnErrorFieldName = False, returnFailedRecordPrimaryKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempException/" + str(TempExceptionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempException(EntityID = 1, setTempExceptionID = None, setCreatedTime = None, setErrorDetail = None, setErrorFieldName = None, setFailedRecordPrimaryKey = None, setModifiedTime = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempExceptionID = False, returnCreatedTime = False, returnErrorDetail = False, returnErrorFieldName = False, returnFailedRecordPrimaryKey = False, returnModifiedTime = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempException/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempException(TempExceptionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempException/" + str(TempExceptionID), verb = "delete")


def getEveryTempFailedCourse(searchConditions = [], EntityID = 1, returnTempFailedCourseID = False, returnActiveSections = False, returnAveragePerSectionMinimumSectionsRequired = False, returnCodeDescription = False, returnCourseCode = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseLengthID = False, returnCourseSubjectCode = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurriculumCode = False, returnDefaultSectionLengthID = False, returnDescription = False, returnEarnedCredits = False, returnEntityCode = False, returnEstimatedNumberOfSections = False, returnEstimatedStudentsPerSection = False, returnGradeLevelSummary = False, returnGradingPeriodSetCode = False, returnGradingPeriodSetID = False, returnIsActive = False, returnMinimumSectionsRequired = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewGradingPeriodSetCode = False, returnNewGradingPeriodSetID = False, returnNote = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfSeatsAvailable = False, returnNumberOfTransferStudentSections = False, returnObjectIsDirty = False, returnObjectName = False, returnOriginalEstimatedNumberOfSections = False, returnRecordsUpdated = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnTempCourseID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempFailedCourse in the district.

    This function returns a dataframe of every TempFailedCourse in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedCourse/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedCourse/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempFailedCourse(TempFailedCourseID, EntityID = 1, returnTempFailedCourseID = False, returnActiveSections = False, returnAveragePerSectionMinimumSectionsRequired = False, returnCodeDescription = False, returnCourseCode = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseLengthID = False, returnCourseSubjectCode = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurriculumCode = False, returnDefaultSectionLengthID = False, returnDescription = False, returnEarnedCredits = False, returnEntityCode = False, returnEstimatedNumberOfSections = False, returnEstimatedStudentsPerSection = False, returnGradeLevelSummary = False, returnGradingPeriodSetCode = False, returnGradingPeriodSetID = False, returnIsActive = False, returnMinimumSectionsRequired = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewGradingPeriodSetCode = False, returnNewGradingPeriodSetID = False, returnNote = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfSeatsAvailable = False, returnNumberOfTransferStudentSections = False, returnObjectIsDirty = False, returnObjectName = False, returnOriginalEstimatedNumberOfSections = False, returnRecordsUpdated = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnTempCourseID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedCourse/" + str(TempFailedCourseID), verb = "get", return_params_list = return_params)

def modifyTempFailedCourse(TempFailedCourseID, EntityID = 1, setTempFailedCourseID = None, setActiveSections = None, setAveragePerSectionMinimumSectionsRequired = None, setCodeDescription = None, setCourseCode = None, setCourseID = None, setCourseLengthCode = None, setCourseLengthID = None, setCourseSubjectCode = None, setCourseTypeCode = None, setCreatedTime = None, setCurriculumCode = None, setDefaultSectionLengthID = None, setDescription = None, setEarnedCredits = None, setEntityCode = None, setEstimatedNumberOfSections = None, setEstimatedStudentsPerSection = None, setGradeLevelSummary = None, setGradingPeriodSetCode = None, setGradingPeriodSetID = None, setIsActive = None, setMinimumSectionsRequired = None, setModifiedTime = None, setNewCourseLengthCode = None, setNewCourseLengthID = None, setNewGradingPeriodSetCode = None, setNewGradingPeriodSetID = None, setNote = None, setNumberOfAlternateCourseRequests = None, setNumberOfCourseRequests = None, setNumberOfSeatsAvailable = None, setNumberOfTransferStudentSections = None, setObjectIsDirty = None, setObjectName = None, setOriginalEstimatedNumberOfSections = None, setRecordsUpdated = None, setRowIsReadOnly = None, setRowIsSelected = None, setTempCourseID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedCourseID = False, returnActiveSections = False, returnAveragePerSectionMinimumSectionsRequired = False, returnCodeDescription = False, returnCourseCode = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseLengthID = False, returnCourseSubjectCode = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurriculumCode = False, returnDefaultSectionLengthID = False, returnDescription = False, returnEarnedCredits = False, returnEntityCode = False, returnEstimatedNumberOfSections = False, returnEstimatedStudentsPerSection = False, returnGradeLevelSummary = False, returnGradingPeriodSetCode = False, returnGradingPeriodSetID = False, returnIsActive = False, returnMinimumSectionsRequired = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewGradingPeriodSetCode = False, returnNewGradingPeriodSetID = False, returnNote = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfSeatsAvailable = False, returnNumberOfTransferStudentSections = False, returnObjectIsDirty = False, returnObjectName = False, returnOriginalEstimatedNumberOfSections = False, returnRecordsUpdated = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnTempCourseID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedCourse/" + str(TempFailedCourseID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempFailedCourse(EntityID = 1, setTempFailedCourseID = None, setActiveSections = None, setAveragePerSectionMinimumSectionsRequired = None, setCodeDescription = None, setCourseCode = None, setCourseID = None, setCourseLengthCode = None, setCourseLengthID = None, setCourseSubjectCode = None, setCourseTypeCode = None, setCreatedTime = None, setCurriculumCode = None, setDefaultSectionLengthID = None, setDescription = None, setEarnedCredits = None, setEntityCode = None, setEstimatedNumberOfSections = None, setEstimatedStudentsPerSection = None, setGradeLevelSummary = None, setGradingPeriodSetCode = None, setGradingPeriodSetID = None, setIsActive = None, setMinimumSectionsRequired = None, setModifiedTime = None, setNewCourseLengthCode = None, setNewCourseLengthID = None, setNewGradingPeriodSetCode = None, setNewGradingPeriodSetID = None, setNote = None, setNumberOfAlternateCourseRequests = None, setNumberOfCourseRequests = None, setNumberOfSeatsAvailable = None, setNumberOfTransferStudentSections = None, setObjectIsDirty = None, setObjectName = None, setOriginalEstimatedNumberOfSections = None, setRecordsUpdated = None, setRowIsReadOnly = None, setRowIsSelected = None, setTempCourseID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedCourseID = False, returnActiveSections = False, returnAveragePerSectionMinimumSectionsRequired = False, returnCodeDescription = False, returnCourseCode = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseLengthID = False, returnCourseSubjectCode = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurriculumCode = False, returnDefaultSectionLengthID = False, returnDescription = False, returnEarnedCredits = False, returnEntityCode = False, returnEstimatedNumberOfSections = False, returnEstimatedStudentsPerSection = False, returnGradeLevelSummary = False, returnGradingPeriodSetCode = False, returnGradingPeriodSetID = False, returnIsActive = False, returnMinimumSectionsRequired = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewGradingPeriodSetCode = False, returnNewGradingPeriodSetID = False, returnNote = False, returnNumberOfAlternateCourseRequests = False, returnNumberOfCourseRequests = False, returnNumberOfSeatsAvailable = False, returnNumberOfTransferStudentSections = False, returnObjectIsDirty = False, returnObjectName = False, returnOriginalEstimatedNumberOfSections = False, returnRecordsUpdated = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnTempCourseID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedCourse/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempFailedCourse(TempFailedCourseID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedCourse/" + str(TempFailedCourseID), verb = "delete")


def getEveryTempFailedDayRotation(searchConditions = [], EntityID = 1, returnTempFailedDayRotationID = False, returnCode = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnObjectName = False, returnRecordsUpdated = False, returnTempDayRotationID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempFailedDayRotation in the district.

    This function returns a dataframe of every TempFailedDayRotation in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedDayRotation/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedDayRotation/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempFailedDayRotation(TempFailedDayRotationID, EntityID = 1, returnTempFailedDayRotationID = False, returnCode = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnObjectName = False, returnRecordsUpdated = False, returnTempDayRotationID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedDayRotation/" + str(TempFailedDayRotationID), verb = "get", return_params_list = return_params)

def modifyTempFailedDayRotation(TempFailedDayRotationID, EntityID = 1, setTempFailedDayRotationID = None, setCode = None, setCreatedTime = None, setDayRotationID = None, setModifiedTime = None, setNote = None, setObjectIsDirty = None, setObjectName = None, setRecordsUpdated = None, setTempDayRotationID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedDayRotationID = False, returnCode = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnObjectName = False, returnRecordsUpdated = False, returnTempDayRotationID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedDayRotation/" + str(TempFailedDayRotationID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempFailedDayRotation(EntityID = 1, setTempFailedDayRotationID = None, setCode = None, setCreatedTime = None, setDayRotationID = None, setModifiedTime = None, setNote = None, setObjectIsDirty = None, setObjectName = None, setRecordsUpdated = None, setTempDayRotationID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedDayRotationID = False, returnCode = False, returnCreatedTime = False, returnDayRotationID = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnObjectName = False, returnRecordsUpdated = False, returnTempDayRotationID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedDayRotation/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempFailedDayRotation(TempFailedDayRotationID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedDayRotation/" + str(TempFailedDayRotationID), verb = "delete")


def getEveryTempFailedSection(searchConditions = [], EntityID = 1, returnTempFailedSectionID = False, returnCourse = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsActive = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnEntityIDCourse = False, returnEntityIDOfferedTo = False, returnErrorCount = False, returnGradeLevelSummary = False, returnHasErrors = False, returnIsActive = False, returnIsSourceSection = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewSectionLengthCode = False, returnNewSectionLengthID = False, returnNote = False, returnNumberOfTransferStudentSections = False, returnPeriodDaySummary = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnStaffFullNameFML = False, returnTargetCourse = False, returnTempSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempFailedSection in the district.

    This function returns a dataframe of every TempFailedSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempFailedSection(TempFailedSectionID, EntityID = 1, returnTempFailedSectionID = False, returnCourse = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsActive = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnEntityIDCourse = False, returnEntityIDOfferedTo = False, returnErrorCount = False, returnGradeLevelSummary = False, returnHasErrors = False, returnIsActive = False, returnIsSourceSection = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewSectionLengthCode = False, returnNewSectionLengthID = False, returnNote = False, returnNumberOfTransferStudentSections = False, returnPeriodDaySummary = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnStaffFullNameFML = False, returnTargetCourse = False, returnTempSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSection/" + str(TempFailedSectionID), verb = "get", return_params_list = return_params)

def modifyTempFailedSection(TempFailedSectionID, EntityID = 1, setTempFailedSectionID = None, setCourse = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseID = None, setCourseIsActive = None, setCourseTypeCode = None, setCreatedTime = None, setCurrentEnrollment = None, setEntityIDCourse = None, setEntityIDOfferedTo = None, setErrorCount = None, setGradeLevelSummary = None, setHasErrors = None, setIsActive = None, setIsSourceSection = None, setMaximumStudentCount = None, setModifiedTime = None, setNewCourseLengthCode = None, setNewCourseLengthID = None, setNewSectionLengthCode = None, setNewSectionLengthID = None, setNote = None, setNumberOfTransferStudentSections = None, setPeriodDaySummary = None, setPrimaryDays = None, setPrimaryDisplayPeriod = None, setRowIsReadOnly = None, setRowIsSelected = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionID = None, setSectionLengthCode = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setStaffFullNameFML = None, setTargetCourse = None, setTempSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedSectionID = False, returnCourse = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsActive = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnEntityIDCourse = False, returnEntityIDOfferedTo = False, returnErrorCount = False, returnGradeLevelSummary = False, returnHasErrors = False, returnIsActive = False, returnIsSourceSection = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewSectionLengthCode = False, returnNewSectionLengthID = False, returnNote = False, returnNumberOfTransferStudentSections = False, returnPeriodDaySummary = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnStaffFullNameFML = False, returnTargetCourse = False, returnTempSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSection/" + str(TempFailedSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempFailedSection(EntityID = 1, setTempFailedSectionID = None, setCourse = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseID = None, setCourseIsActive = None, setCourseTypeCode = None, setCreatedTime = None, setCurrentEnrollment = None, setEntityIDCourse = None, setEntityIDOfferedTo = None, setErrorCount = None, setGradeLevelSummary = None, setHasErrors = None, setIsActive = None, setIsSourceSection = None, setMaximumStudentCount = None, setModifiedTime = None, setNewCourseLengthCode = None, setNewCourseLengthID = None, setNewSectionLengthCode = None, setNewSectionLengthID = None, setNote = None, setNumberOfTransferStudentSections = None, setPeriodDaySummary = None, setPrimaryDays = None, setPrimaryDisplayPeriod = None, setRowIsReadOnly = None, setRowIsSelected = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionID = None, setSectionLengthCode = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setStaffFullNameFML = None, setTargetCourse = None, setTempSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedSectionID = False, returnCourse = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsActive = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnEntityIDCourse = False, returnEntityIDOfferedTo = False, returnErrorCount = False, returnGradeLevelSummary = False, returnHasErrors = False, returnIsActive = False, returnIsSourceSection = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewSectionLengthCode = False, returnNewSectionLengthID = False, returnNote = False, returnNumberOfTransferStudentSections = False, returnPeriodDaySummary = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnStaffFullNameFML = False, returnTargetCourse = False, returnTempSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempFailedSection(TempFailedSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSection/" + str(TempFailedSectionID), verb = "delete")


def getEveryTempFailedSectionLengthSubset(searchConditions = [], EntityID = 1, returnTempFailedSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthCode = False, returnCourseLengthCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEndDate = False, returnIsFullSectionLength = False, returnIsUpdated = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthCode = False, returnSectionLengthCodeDescription = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnTempSectionLengthSubsetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempFailedSectionLengthSubset in the district.

    This function returns a dataframe of every TempFailedSectionLengthSubset in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempFailedSectionLengthSubset(TempFailedSectionLengthSubsetID, EntityID = 1, returnTempFailedSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthCode = False, returnCourseLengthCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEndDate = False, returnIsFullSectionLength = False, returnIsUpdated = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthCode = False, returnSectionLengthCodeDescription = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnTempSectionLengthSubsetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSectionLengthSubset/" + str(TempFailedSectionLengthSubsetID), verb = "get", return_params_list = return_params)

def modifyTempFailedSectionLengthSubset(TempFailedSectionLengthSubsetID, EntityID = 1, setTempFailedSectionLengthSubsetID = None, setCode = None, setCodeDescription = None, setCourseLengthCode = None, setCourseLengthCodeDescription = None, setCourseLengthID = None, setCreatedTime = None, setDescription = None, setEndDate = None, setIsFullSectionLength = None, setIsUpdated = None, setModifiedTime = None, setNote = None, setObjectIsDirty = None, setOriginalEndDate = None, setOriginalStartDate = None, setProcessAction = None, setProcessActionCode = None, setSectionLengthCode = None, setSectionLengthCodeDescription = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setSectionLengthSubsetID = None, setStartDate = None, setTempSectionLengthSubsetID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthCode = False, returnCourseLengthCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEndDate = False, returnIsFullSectionLength = False, returnIsUpdated = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthCode = False, returnSectionLengthCodeDescription = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnTempSectionLengthSubsetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSectionLengthSubset/" + str(TempFailedSectionLengthSubsetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempFailedSectionLengthSubset(EntityID = 1, setTempFailedSectionLengthSubsetID = None, setCode = None, setCodeDescription = None, setCourseLengthCode = None, setCourseLengthCodeDescription = None, setCourseLengthID = None, setCreatedTime = None, setDescription = None, setEndDate = None, setIsFullSectionLength = None, setIsUpdated = None, setModifiedTime = None, setNote = None, setObjectIsDirty = None, setOriginalEndDate = None, setOriginalStartDate = None, setProcessAction = None, setProcessActionCode = None, setSectionLengthCode = None, setSectionLengthCodeDescription = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setSectionLengthSubsetID = None, setStartDate = None, setTempSectionLengthSubsetID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthCode = False, returnCourseLengthCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEndDate = False, returnIsFullSectionLength = False, returnIsUpdated = False, returnModifiedTime = False, returnNote = False, returnObjectIsDirty = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthCode = False, returnSectionLengthCodeDescription = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnTempSectionLengthSubsetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSectionLengthSubset/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempFailedSectionLengthSubset(TempFailedSectionLengthSubsetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedSectionLengthSubset/" + str(TempFailedSectionLengthSubsetID), verb = "delete")


def getEveryTempFailedStaffMeet(searchConditions = [], EntityID = 1, returnTempFailedStaffMeetID = False, returnConflicts = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnErrorCount = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasErrors = False, returnHasGradebookAccess = False, returnIsChecked = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnNewEffectiveEndDate = False, returnNewEffectiveStartDate = False, returnNewStaffFullNameFML = False, returnNewStaffID = False, returnNote = False, returnSectionCode = False, returnSectionID = False, returnStaffFullNameFML = False, returnStaffID = False, returnStaffMeetID = False, returnTempStaffMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempFailedStaffMeet in the district.

    This function returns a dataframe of every TempFailedStaffMeet in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStaffMeet/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStaffMeet/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempFailedStaffMeet(TempFailedStaffMeetID, EntityID = 1, returnTempFailedStaffMeetID = False, returnConflicts = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnErrorCount = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasErrors = False, returnHasGradebookAccess = False, returnIsChecked = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnNewEffectiveEndDate = False, returnNewEffectiveStartDate = False, returnNewStaffFullNameFML = False, returnNewStaffID = False, returnNote = False, returnSectionCode = False, returnSectionID = False, returnStaffFullNameFML = False, returnStaffID = False, returnStaffMeetID = False, returnTempStaffMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStaffMeet/" + str(TempFailedStaffMeetID), verb = "get", return_params_list = return_params)

def modifyTempFailedStaffMeet(TempFailedStaffMeetID, EntityID = 1, setTempFailedStaffMeetID = None, setConflicts = None, setCourseCode = None, setCourseDescription = None, setCreatedTime = None, setEffectiveEndDate = None, setEffectiveStartDate = None, setErrorCount = None, setHasAttendanceAccess = None, setHasConflicts = None, setHasErrors = None, setHasGradebookAccess = None, setIsChecked = None, setIsLongTermSubstitute = None, setIsPrimary = None, setIsSubstitute = None, setMeetID = None, setModifiedTime = None, setNewEffectiveEndDate = None, setNewEffectiveStartDate = None, setNewStaffFullNameFML = None, setNewStaffID = None, setNote = None, setSectionCode = None, setSectionID = None, setStaffFullNameFML = None, setStaffID = None, setStaffMeetID = None, setTempStaffMeetID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempFailedStaffMeetID = False, returnConflicts = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnErrorCount = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasErrors = False, returnHasGradebookAccess = False, returnIsChecked = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnNewEffectiveEndDate = False, returnNewEffectiveStartDate = False, returnNewStaffFullNameFML = False, returnNewStaffID = False, returnNote = False, returnSectionCode = False, returnSectionID = False, returnStaffFullNameFML = False, returnStaffID = False, returnStaffMeetID = False, returnTempStaffMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStaffMeet/" + str(TempFailedStaffMeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempFailedStaffMeet(EntityID = 1, setTempFailedStaffMeetID = None, setConflicts = None, setCourseCode = None, setCourseDescription = None, setCreatedTime = None, setEffectiveEndDate = None, setEffectiveStartDate = None, setErrorCount = None, setHasAttendanceAccess = None, setHasConflicts = None, setHasErrors = None, setHasGradebookAccess = None, setIsChecked = None, setIsLongTermSubstitute = None, setIsPrimary = None, setIsSubstitute = None, setMeetID = None, setModifiedTime = None, setNewEffectiveEndDate = None, setNewEffectiveStartDate = None, setNewStaffFullNameFML = None, setNewStaffID = None, setNote = None, setSectionCode = None, setSectionID = None, setStaffFullNameFML = None, setStaffID = None, setStaffMeetID = None, setTempStaffMeetID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempFailedStaffMeetID = False, returnConflicts = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnErrorCount = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasErrors = False, returnHasGradebookAccess = False, returnIsChecked = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnNewEffectiveEndDate = False, returnNewEffectiveStartDate = False, returnNewStaffFullNameFML = False, returnNewStaffID = False, returnNote = False, returnSectionCode = False, returnSectionID = False, returnStaffFullNameFML = False, returnStaffID = False, returnStaffMeetID = False, returnTempStaffMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStaffMeet/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempFailedStaffMeet(TempFailedStaffMeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStaffMeet/" + str(TempFailedStaffMeetID), verb = "delete")


def getEveryTempFailedStudentCourseRequest(searchConditions = [], EntityID = 1, returnTempFailedStudentCourseRequestID = False, returnCourseCode = False, returnCourseDepartmentCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseNumericSchoolYear = False, returnCourseSchoolYearDescription = False, returnCourseSubjectCodeDescription = False, returnCreatedTime = False, returnEarnedCredits = False, returnEntityIDRequestedFrom = False, returnErrorMessage = False, returnFailed = False, returnFullStudentNameLFM = False, returnModifiedTime = False, returnNote = False, returnSectionCode = False, returnSectionlengthSubsetCode = False, returnSectionLengthSubsetID = False, returnSelected = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionID = False, returnTempStudentCourseRequestID = False, returnTempStudentEnrollmentRecordID = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempFailedStudentCourseRequest in the district.

    This function returns a dataframe of every TempFailedStudentCourseRequest in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempFailedStudentCourseRequest(TempFailedStudentCourseRequestID, EntityID = 1, returnTempFailedStudentCourseRequestID = False, returnCourseCode = False, returnCourseDepartmentCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseNumericSchoolYear = False, returnCourseSchoolYearDescription = False, returnCourseSubjectCodeDescription = False, returnCreatedTime = False, returnEarnedCredits = False, returnEntityIDRequestedFrom = False, returnErrorMessage = False, returnFailed = False, returnFullStudentNameLFM = False, returnModifiedTime = False, returnNote = False, returnSectionCode = False, returnSectionlengthSubsetCode = False, returnSectionLengthSubsetID = False, returnSelected = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionID = False, returnTempStudentCourseRequestID = False, returnTempStudentEnrollmentRecordID = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequest/" + str(TempFailedStudentCourseRequestID), verb = "get", return_params_list = return_params)

def modifyTempFailedStudentCourseRequest(TempFailedStudentCourseRequestID, EntityID = 1, setTempFailedStudentCourseRequestID = None, setCourseCode = None, setCourseDepartmentCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCourseLengthCode = None, setCourseNumericSchoolYear = None, setCourseSchoolYearDescription = None, setCourseSubjectCodeDescription = None, setCreatedTime = None, setEarnedCredits = None, setEntityIDRequestedFrom = None, setErrorMessage = None, setFailed = None, setFullStudentNameLFM = None, setModifiedTime = None, setNote = None, setSectionCode = None, setSectionlengthSubsetCode = None, setSectionLengthSubsetID = None, setSelected = None, setStudentCourseRequestID = None, setStudentCourseRequestSectionLengthSubsetID = None, setStudentID = None, setStudentNumber = None, setStudentSectionID = None, setTempStudentCourseRequestID = None, setTempStudentEnrollmentRecordID = None, setTempStudentID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempFailedStudentCourseRequestID = False, returnCourseCode = False, returnCourseDepartmentCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseNumericSchoolYear = False, returnCourseSchoolYearDescription = False, returnCourseSubjectCodeDescription = False, returnCreatedTime = False, returnEarnedCredits = False, returnEntityIDRequestedFrom = False, returnErrorMessage = False, returnFailed = False, returnFullStudentNameLFM = False, returnModifiedTime = False, returnNote = False, returnSectionCode = False, returnSectionlengthSubsetCode = False, returnSectionLengthSubsetID = False, returnSelected = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionID = False, returnTempStudentCourseRequestID = False, returnTempStudentEnrollmentRecordID = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequest/" + str(TempFailedStudentCourseRequestID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempFailedStudentCourseRequest(EntityID = 1, setTempFailedStudentCourseRequestID = None, setCourseCode = None, setCourseDepartmentCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCourseLengthCode = None, setCourseNumericSchoolYear = None, setCourseSchoolYearDescription = None, setCourseSubjectCodeDescription = None, setCreatedTime = None, setEarnedCredits = None, setEntityIDRequestedFrom = None, setErrorMessage = None, setFailed = None, setFullStudentNameLFM = None, setModifiedTime = None, setNote = None, setSectionCode = None, setSectionlengthSubsetCode = None, setSectionLengthSubsetID = None, setSelected = None, setStudentCourseRequestID = None, setStudentCourseRequestSectionLengthSubsetID = None, setStudentID = None, setStudentNumber = None, setStudentSectionID = None, setTempStudentCourseRequestID = None, setTempStudentEnrollmentRecordID = None, setTempStudentID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempFailedStudentCourseRequestID = False, returnCourseCode = False, returnCourseDepartmentCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseNumericSchoolYear = False, returnCourseSchoolYearDescription = False, returnCourseSubjectCodeDescription = False, returnCreatedTime = False, returnEarnedCredits = False, returnEntityIDRequestedFrom = False, returnErrorMessage = False, returnFailed = False, returnFullStudentNameLFM = False, returnModifiedTime = False, returnNote = False, returnSectionCode = False, returnSectionlengthSubsetCode = False, returnSectionLengthSubsetID = False, returnSelected = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionID = False, returnTempStudentCourseRequestID = False, returnTempStudentEnrollmentRecordID = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequest/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempFailedStudentCourseRequest(TempFailedStudentCourseRequestID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequest/" + str(TempFailedStudentCourseRequestID), verb = "delete")


def getEveryTempFailedStudentCourseRequestToReactivate(searchConditions = [], EntityID = 1, returnTempFailedStudentCourseRequestToReactivateID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnNote = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTempRecordToReactivatePrimaryKeyValue = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempFailedStudentCourseRequestToReactivate in the district.

    This function returns a dataframe of every TempFailedStudentCourseRequestToReactivate in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivate/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivate/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempFailedStudentCourseRequestToReactivate(TempFailedStudentCourseRequestToReactivateID, EntityID = 1, returnTempFailedStudentCourseRequestToReactivateID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnNote = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTempRecordToReactivatePrimaryKeyValue = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivate/" + str(TempFailedStudentCourseRequestToReactivateID), verb = "get", return_params_list = return_params)

def modifyTempFailedStudentCourseRequestToReactivate(TempFailedStudentCourseRequestToReactivateID, EntityID = 1, setTempFailedStudentCourseRequestToReactivateID = None, setAlternateRank = None, setAuditRecordIsRequestable = None, setAuditRecordIsSchedulable = None, setCourseCode = None, setCourseCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCreatedTime = None, setCurrentEnrollment = None, setDateFrom = None, setDateTo = None, setDays = None, setEarlyExitReasonCodeDescription = None, setEarlyExitReasonID = None, setEarnedCreditOverride = None, setEarnedCredits = None, setEndDate = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setEntityIDRequestedFrom = None, setExcludeFromReportCardsAndTranscripts = None, setExcludeFromStudentSectionLink = None, setGradeReferenceID = None, setIsAlternate = None, setIsTransferCourse = None, setMaximumStudentCount = None, setModifiedTime = None, setNameIDRequestedBy = None, setNameRequestedByLFM = None, setNote = None, setPeriod = None, setPreventReactivateCheckboxFromBeingRendered = None, setRequestSource = None, setRequestSourceCode = None, setRequestStatus = None, setRequestStatusCode = None, setSchedulingMethod = None, setSchedulingMethodCode = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionID = None, setSectionLengthID = None, setSectionLengthSubsetCode = None, setSectionLengthSubsetDescription = None, setSectionLengthSubsetID = None, setStaffFullNameFML = None, setStartDate = None, setStudentCourseRequestID = None, setStudentCourseRequestIDAlternateFor = None, setStudentID = None, setStudentSectionID = None, setStudentSectionTransactionID = None, setTempRecordToReactivatePrimaryKeyValue = None, setTotalEarnedCreditOverride = None, setTotalFailedCreditOverride = None, setTransferCourseName = None, setUseEarnedCreditOverride = None, setUseEarnedCreditTotalOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedStudentCourseRequestToReactivateID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnNote = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTempRecordToReactivatePrimaryKeyValue = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivate/" + str(TempFailedStudentCourseRequestToReactivateID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempFailedStudentCourseRequestToReactivate(EntityID = 1, setTempFailedStudentCourseRequestToReactivateID = None, setAlternateRank = None, setAuditRecordIsRequestable = None, setAuditRecordIsSchedulable = None, setCourseCode = None, setCourseCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCreatedTime = None, setCurrentEnrollment = None, setDateFrom = None, setDateTo = None, setDays = None, setEarlyExitReasonCodeDescription = None, setEarlyExitReasonID = None, setEarnedCreditOverride = None, setEarnedCredits = None, setEndDate = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setEntityIDRequestedFrom = None, setExcludeFromReportCardsAndTranscripts = None, setExcludeFromStudentSectionLink = None, setGradeReferenceID = None, setIsAlternate = None, setIsTransferCourse = None, setMaximumStudentCount = None, setModifiedTime = None, setNameIDRequestedBy = None, setNameRequestedByLFM = None, setNote = None, setPeriod = None, setPreventReactivateCheckboxFromBeingRendered = None, setRequestSource = None, setRequestSourceCode = None, setRequestStatus = None, setRequestStatusCode = None, setSchedulingMethod = None, setSchedulingMethodCode = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionID = None, setSectionLengthID = None, setSectionLengthSubsetCode = None, setSectionLengthSubsetDescription = None, setSectionLengthSubsetID = None, setStaffFullNameFML = None, setStartDate = None, setStudentCourseRequestID = None, setStudentCourseRequestIDAlternateFor = None, setStudentID = None, setStudentSectionID = None, setStudentSectionTransactionID = None, setTempRecordToReactivatePrimaryKeyValue = None, setTotalEarnedCreditOverride = None, setTotalFailedCreditOverride = None, setTransferCourseName = None, setUseEarnedCreditOverride = None, setUseEarnedCreditTotalOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedStudentCourseRequestToReactivateID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnNote = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTempRecordToReactivatePrimaryKeyValue = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivate/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempFailedStudentCourseRequestToReactivate(TempFailedStudentCourseRequestToReactivateID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivate/" + str(TempFailedStudentCourseRequestToReactivateID), verb = "delete")


def getEveryTempFailedStudentCourseRequestToReactivateDetail(searchConditions = [], EntityID = 1, returnTempFailedStudentCourseRequestToReactivateDetailID = False, returnCreatedTime = False, returnModifiedTime = False, returnNote = False, returnTempRecordToReactivatePrimaryKeyValue = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempFailedStudentCourseRequestToReactivateDetail in the district.

    This function returns a dataframe of every TempFailedStudentCourseRequestToReactivateDetail in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivateDetail/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivateDetail/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempFailedStudentCourseRequestToReactivateDetail(TempFailedStudentCourseRequestToReactivateDetailID, EntityID = 1, returnTempFailedStudentCourseRequestToReactivateDetailID = False, returnCreatedTime = False, returnModifiedTime = False, returnNote = False, returnTempRecordToReactivatePrimaryKeyValue = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivateDetail/" + str(TempFailedStudentCourseRequestToReactivateDetailID), verb = "get", return_params_list = return_params)

def modifyTempFailedStudentCourseRequestToReactivateDetail(TempFailedStudentCourseRequestToReactivateDetailID, EntityID = 1, setTempFailedStudentCourseRequestToReactivateDetailID = None, setCreatedTime = None, setModifiedTime = None, setNote = None, setTempRecordToReactivatePrimaryKeyValue = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedStudentCourseRequestToReactivateDetailID = False, returnCreatedTime = False, returnModifiedTime = False, returnNote = False, returnTempRecordToReactivatePrimaryKeyValue = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivateDetail/" + str(TempFailedStudentCourseRequestToReactivateDetailID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempFailedStudentCourseRequestToReactivateDetail(EntityID = 1, setTempFailedStudentCourseRequestToReactivateDetailID = None, setCreatedTime = None, setModifiedTime = None, setNote = None, setTempRecordToReactivatePrimaryKeyValue = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedStudentCourseRequestToReactivateDetailID = False, returnCreatedTime = False, returnModifiedTime = False, returnNote = False, returnTempRecordToReactivatePrimaryKeyValue = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivateDetail/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempFailedStudentCourseRequestToReactivateDetail(TempFailedStudentCourseRequestToReactivateDetailID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentCourseRequestToReactivateDetail/" + str(TempFailedStudentCourseRequestToReactivateDetailID), verb = "delete")


def getEveryTempFailedStudentSection(searchConditions = [], EntityID = 1, returnTempFailedStudentSectionID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnEarlyExitReasonCodeDescription = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNote = False, returnRenderCheckbox = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnScheduleAllSectionsInGroupOrNone = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionCorequisiteGroupName = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentGenderCode = False, returnStudentGradeLevelCode = False, returnStudentGradYear = False, returnStudentID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionID = False, returnStudentSectionTransactionIDToUpdate = False, returnTempStudentID = False, returnTempStudentSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempFailedStudentSection in the district.

    This function returns a dataframe of every TempFailedStudentSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempFailedStudentSection(TempFailedStudentSectionID, EntityID = 1, returnTempFailedStudentSectionID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnEarlyExitReasonCodeDescription = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNote = False, returnRenderCheckbox = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnScheduleAllSectionsInGroupOrNone = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionCorequisiteGroupName = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentGenderCode = False, returnStudentGradeLevelCode = False, returnStudentGradYear = False, returnStudentID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionID = False, returnStudentSectionTransactionIDToUpdate = False, returnTempStudentID = False, returnTempStudentSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSection/" + str(TempFailedStudentSectionID), verb = "get", return_params_list = return_params)

def modifyTempFailedStudentSection(TempFailedStudentSectionID, EntityID = 1, setTempFailedStudentSectionID = None, setAutomaticRequestSetting = None, setAutomaticRequestSettingCode = None, setAutomaticScheduleSetting = None, setAutomaticScheduleSettingCode = None, setCourseCode = None, setCourseCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCreatedTime = None, setEarlyExitReasonCodeDescription = None, setEndDate = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setGradeReferenceID = None, setModifiedTime = None, setNote = None, setRenderCheckbox = None, setRowIsReadOnly = None, setRowIsSelected = None, setScheduleAllSectionsInGroupOrNone = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionCorequisiteGroupName = None, setSectionID = None, setSectionLengthCode = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setSectionLengthSubsetID = None, setStartDate = None, setStudentCourseRequestID = None, setStudentGenderCode = None, setStudentGradeLevelCode = None, setStudentGradYear = None, setStudentID = None, setStudentNameLFM = None, setStudentNumber = None, setStudentSectionID = None, setStudentSectionTransactionIDToUpdate = None, setTempStudentID = None, setTempStudentSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempFailedStudentSectionID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnEarlyExitReasonCodeDescription = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNote = False, returnRenderCheckbox = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnScheduleAllSectionsInGroupOrNone = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionCorequisiteGroupName = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentGenderCode = False, returnStudentGradeLevelCode = False, returnStudentGradYear = False, returnStudentID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionID = False, returnStudentSectionTransactionIDToUpdate = False, returnTempStudentID = False, returnTempStudentSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSection/" + str(TempFailedStudentSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempFailedStudentSection(EntityID = 1, setTempFailedStudentSectionID = None, setAutomaticRequestSetting = None, setAutomaticRequestSettingCode = None, setAutomaticScheduleSetting = None, setAutomaticScheduleSettingCode = None, setCourseCode = None, setCourseCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCreatedTime = None, setEarlyExitReasonCodeDescription = None, setEndDate = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setGradeReferenceID = None, setModifiedTime = None, setNote = None, setRenderCheckbox = None, setRowIsReadOnly = None, setRowIsSelected = None, setScheduleAllSectionsInGroupOrNone = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionCorequisiteGroupName = None, setSectionID = None, setSectionLengthCode = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setSectionLengthSubsetID = None, setStartDate = None, setStudentCourseRequestID = None, setStudentGenderCode = None, setStudentGradeLevelCode = None, setStudentGradYear = None, setStudentID = None, setStudentNameLFM = None, setStudentNumber = None, setStudentSectionID = None, setStudentSectionTransactionIDToUpdate = None, setTempStudentID = None, setTempStudentSectionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempFailedStudentSectionID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnEarlyExitReasonCodeDescription = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNote = False, returnRenderCheckbox = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnScheduleAllSectionsInGroupOrNone = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionCorequisiteGroupName = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentGenderCode = False, returnStudentGradeLevelCode = False, returnStudentGradYear = False, returnStudentID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionID = False, returnStudentSectionTransactionIDToUpdate = False, returnTempStudentID = False, returnTempStudentSectionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempFailedStudentSection(TempFailedStudentSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSection/" + str(TempFailedStudentSectionID), verb = "delete")


def getEveryTempFailedStudentSectionTransaction(searchConditions = [], EntityID = 1, returnTempFailedStudentSectionTransactionID = False, returnCourse = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNote = False, returnSectionCode = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionTransactionID = False, returnTempStudentCourseRequestID = False, returnTempStudentCourseRequestToReactivateID = False, returnTempStudentSectionTransactionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempFailedStudentSectionTransaction in the district.

    This function returns a dataframe of every TempFailedStudentSectionTransaction in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSectionTransaction/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSectionTransaction/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempFailedStudentSectionTransaction(TempFailedStudentSectionTransactionID, EntityID = 1, returnTempFailedStudentSectionTransactionID = False, returnCourse = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNote = False, returnSectionCode = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionTransactionID = False, returnTempStudentCourseRequestID = False, returnTempStudentCourseRequestToReactivateID = False, returnTempStudentSectionTransactionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSectionTransaction/" + str(TempFailedStudentSectionTransactionID), verb = "get", return_params_list = return_params)

def modifyTempFailedStudentSectionTransaction(TempFailedStudentSectionTransactionID, EntityID = 1, setTempFailedStudentSectionTransactionID = None, setCourse = None, setCreatedTime = None, setEarlyExitReasonID = None, setEndDate = None, setEntityIDCountsAs = None, setHideNewStudentButton = None, setModifiedTime = None, setNameIDRequestedBy = None, setNote = None, setSectionCode = None, setSectionLengthSubsetID = None, setStartDate = None, setStudentCourseRequestID = None, setStudentNameLFM = None, setStudentNumber = None, setStudentSectionTransactionID = None, setTempStudentCourseRequestID = None, setTempStudentCourseRequestToReactivateID = None, setTempStudentSectionTransactionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedStudentSectionTransactionID = False, returnCourse = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNote = False, returnSectionCode = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionTransactionID = False, returnTempStudentCourseRequestID = False, returnTempStudentCourseRequestToReactivateID = False, returnTempStudentSectionTransactionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSectionTransaction/" + str(TempFailedStudentSectionTransactionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempFailedStudentSectionTransaction(EntityID = 1, setTempFailedStudentSectionTransactionID = None, setCourse = None, setCreatedTime = None, setEarlyExitReasonID = None, setEndDate = None, setEntityIDCountsAs = None, setHideNewStudentButton = None, setModifiedTime = None, setNameIDRequestedBy = None, setNote = None, setSectionCode = None, setSectionLengthSubsetID = None, setStartDate = None, setStudentCourseRequestID = None, setStudentNameLFM = None, setStudentNumber = None, setStudentSectionTransactionID = None, setTempStudentCourseRequestID = None, setTempStudentCourseRequestToReactivateID = None, setTempStudentSectionTransactionID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempFailedStudentSectionTransactionID = False, returnCourse = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNote = False, returnSectionCode = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionTransactionID = False, returnTempStudentCourseRequestID = False, returnTempStudentCourseRequestToReactivateID = False, returnTempStudentSectionTransactionID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSectionTransaction/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempFailedStudentSectionTransaction(TempFailedStudentSectionTransactionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempFailedStudentSectionTransaction/" + str(TempFailedStudentSectionTransactionID), verb = "delete")


def getEveryTempMasterDateChangeDetail(searchConditions = [], EntityID = 1, returnTempMasterDateChangeDetailID = False, returnCreatedTime = False, returnCurrentDate = False, returnDateDescriptor = False, returnDateDescriptorCode = False, returnDisplayLowHighDates = False, returnHighDate = False, returnLowDate = False, returnModifiedTime = False, returnNewDate = False, returnUsedBy = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempMasterDateChangeDetail in the district.

    This function returns a dataframe of every TempMasterDateChangeDetail in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMasterDateChangeDetail/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMasterDateChangeDetail/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempMasterDateChangeDetail(TempMasterDateChangeDetailID, EntityID = 1, returnTempMasterDateChangeDetailID = False, returnCreatedTime = False, returnCurrentDate = False, returnDateDescriptor = False, returnDateDescriptorCode = False, returnDisplayLowHighDates = False, returnHighDate = False, returnLowDate = False, returnModifiedTime = False, returnNewDate = False, returnUsedBy = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMasterDateChangeDetail/" + str(TempMasterDateChangeDetailID), verb = "get", return_params_list = return_params)

def modifyTempMasterDateChangeDetail(TempMasterDateChangeDetailID, EntityID = 1, setTempMasterDateChangeDetailID = None, setCreatedTime = None, setCurrentDate = None, setDateDescriptor = None, setDateDescriptorCode = None, setDisplayLowHighDates = None, setHighDate = None, setLowDate = None, setModifiedTime = None, setNewDate = None, setUsedBy = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempMasterDateChangeDetailID = False, returnCreatedTime = False, returnCurrentDate = False, returnDateDescriptor = False, returnDateDescriptorCode = False, returnDisplayLowHighDates = False, returnHighDate = False, returnLowDate = False, returnModifiedTime = False, returnNewDate = False, returnUsedBy = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMasterDateChangeDetail/" + str(TempMasterDateChangeDetailID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempMasterDateChangeDetail(EntityID = 1, setTempMasterDateChangeDetailID = None, setCreatedTime = None, setCurrentDate = None, setDateDescriptor = None, setDateDescriptorCode = None, setDisplayLowHighDates = None, setHighDate = None, setLowDate = None, setModifiedTime = None, setNewDate = None, setUsedBy = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempMasterDateChangeDetailID = False, returnCreatedTime = False, returnCurrentDate = False, returnDateDescriptor = False, returnDateDescriptorCode = False, returnDisplayLowHighDates = False, returnHighDate = False, returnLowDate = False, returnModifiedTime = False, returnNewDate = False, returnUsedBy = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMasterDateChangeDetail/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempMasterDateChangeDetail(TempMasterDateChangeDetailID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMasterDateChangeDetail/" + str(TempMasterDateChangeDetailID), verb = "delete")


def getEveryTempMeet(searchConditions = [], EntityID = 1, returnTempMeetID = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEndDate = False, returnMeetID = False, returnModifiedTime = False, returnNewEndDate = False, returnNewSectionLengthCode = False, returnNewStartDate = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnPrimaryStaffFullNameFML = False, returnRoomNumberDescription = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempMeet in the district.

    This function returns a dataframe of every TempMeet in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMeet/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMeet/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempMeet(TempMeetID, EntityID = 1, returnTempMeetID = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEndDate = False, returnMeetID = False, returnModifiedTime = False, returnNewEndDate = False, returnNewSectionLengthCode = False, returnNewStartDate = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnPrimaryStaffFullNameFML = False, returnRoomNumberDescription = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMeet/" + str(TempMeetID), verb = "get", return_params_list = return_params)

def modifyTempMeet(TempMeetID, EntityID = 1, setTempMeetID = None, setCourseCode = None, setCourseDescription = None, setCreatedTime = None, setEndDate = None, setMeetID = None, setModifiedTime = None, setNewEndDate = None, setNewSectionLengthCode = None, setNewStartDate = None, setPrimaryDays = None, setPrimaryDisplayPeriod = None, setPrimaryStaffFullNameFML = None, setRoomNumberDescription = None, setSectionCode = None, setSectionID = None, setSectionLengthCode = None, setStartDate = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempMeetID = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEndDate = False, returnMeetID = False, returnModifiedTime = False, returnNewEndDate = False, returnNewSectionLengthCode = False, returnNewStartDate = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnPrimaryStaffFullNameFML = False, returnRoomNumberDescription = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMeet/" + str(TempMeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempMeet(EntityID = 1, setTempMeetID = None, setCourseCode = None, setCourseDescription = None, setCreatedTime = None, setEndDate = None, setMeetID = None, setModifiedTime = None, setNewEndDate = None, setNewSectionLengthCode = None, setNewStartDate = None, setPrimaryDays = None, setPrimaryDisplayPeriod = None, setPrimaryStaffFullNameFML = None, setRoomNumberDescription = None, setSectionCode = None, setSectionID = None, setSectionLengthCode = None, setStartDate = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempMeetID = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEndDate = False, returnMeetID = False, returnModifiedTime = False, returnNewEndDate = False, returnNewSectionLengthCode = False, returnNewStartDate = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnPrimaryStaffFullNameFML = False, returnRoomNumberDescription = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMeet/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempMeet(TempMeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempMeet/" + str(TempMeetID), verb = "delete")


def getEveryTempSchedulingTeamGradeReference(searchConditions = [], EntityID = 1, returnTempSchedulingTeamGradeReferenceID = False, returnCode = False, returnCreatedTime = False, returnCurrentStudentCount = False, returnDescription = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnOverrideTotalToBeAssignedCount = False, returnOverrideTotalToBeAssignedPercent = False, returnSchedulingTeamGradeReferenceID = False, returnSchedulingTeamID = False, returnSortOrder = False, returnTotalStudents = False, returnTotalToBeAssignedCount = False, returnTotalToBeAssignedPercent = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempSchedulingTeamGradeReference in the district.

    This function returns a dataframe of every TempSchedulingTeamGradeReference in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSchedulingTeamGradeReference/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSchedulingTeamGradeReference/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempSchedulingTeamGradeReference(TempSchedulingTeamGradeReferenceID, EntityID = 1, returnTempSchedulingTeamGradeReferenceID = False, returnCode = False, returnCreatedTime = False, returnCurrentStudentCount = False, returnDescription = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnOverrideTotalToBeAssignedCount = False, returnOverrideTotalToBeAssignedPercent = False, returnSchedulingTeamGradeReferenceID = False, returnSchedulingTeamID = False, returnSortOrder = False, returnTotalStudents = False, returnTotalToBeAssignedCount = False, returnTotalToBeAssignedPercent = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSchedulingTeamGradeReference/" + str(TempSchedulingTeamGradeReferenceID), verb = "get", return_params_list = return_params)

def modifyTempSchedulingTeamGradeReference(TempSchedulingTeamGradeReferenceID, EntityID = 1, setTempSchedulingTeamGradeReferenceID = None, setCode = None, setCreatedTime = None, setCurrentStudentCount = None, setDescription = None, setMaximumStudentCount = None, setModifiedTime = None, setOverrideTotalToBeAssignedCount = None, setOverrideTotalToBeAssignedPercent = None, setSchedulingTeamGradeReferenceID = None, setSchedulingTeamID = None, setSortOrder = None, setTotalStudents = None, setTotalToBeAssignedCount = None, setTotalToBeAssignedPercent = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempSchedulingTeamGradeReferenceID = False, returnCode = False, returnCreatedTime = False, returnCurrentStudentCount = False, returnDescription = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnOverrideTotalToBeAssignedCount = False, returnOverrideTotalToBeAssignedPercent = False, returnSchedulingTeamGradeReferenceID = False, returnSchedulingTeamID = False, returnSortOrder = False, returnTotalStudents = False, returnTotalToBeAssignedCount = False, returnTotalToBeAssignedPercent = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSchedulingTeamGradeReference/" + str(TempSchedulingTeamGradeReferenceID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempSchedulingTeamGradeReference(EntityID = 1, setTempSchedulingTeamGradeReferenceID = None, setCode = None, setCreatedTime = None, setCurrentStudentCount = None, setDescription = None, setMaximumStudentCount = None, setModifiedTime = None, setOverrideTotalToBeAssignedCount = None, setOverrideTotalToBeAssignedPercent = None, setSchedulingTeamGradeReferenceID = None, setSchedulingTeamID = None, setSortOrder = None, setTotalStudents = None, setTotalToBeAssignedCount = None, setTotalToBeAssignedPercent = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempSchedulingTeamGradeReferenceID = False, returnCode = False, returnCreatedTime = False, returnCurrentStudentCount = False, returnDescription = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnOverrideTotalToBeAssignedCount = False, returnOverrideTotalToBeAssignedPercent = False, returnSchedulingTeamGradeReferenceID = False, returnSchedulingTeamID = False, returnSortOrder = False, returnTotalStudents = False, returnTotalToBeAssignedCount = False, returnTotalToBeAssignedPercent = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSchedulingTeamGradeReference/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempSchedulingTeamGradeReference(TempSchedulingTeamGradeReferenceID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSchedulingTeamGradeReference/" + str(TempSchedulingTeamGradeReferenceID), verb = "delete")


def getEveryTempSection(searchConditions = [], EntityID = 1, returnTempSectionID = False, returnCourse = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsActive = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnEntityIDCourse = False, returnEntityIDOfferedTo = False, returnGradeLevelSummary = False, returnIsActive = False, returnIsSourceSection = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewSectionLengthCode = False, returnNewSectionLengthID = False, returnNote = False, returnNumberOfTransferStudentSections = False, returnPeriodDaySummary = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnStaffFullNameFML = False, returnTargetCourse = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempSection in the district.

    This function returns a dataframe of every TempSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempSection(TempSectionID, EntityID = 1, returnTempSectionID = False, returnCourse = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsActive = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnEntityIDCourse = False, returnEntityIDOfferedTo = False, returnGradeLevelSummary = False, returnIsActive = False, returnIsSourceSection = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewSectionLengthCode = False, returnNewSectionLengthID = False, returnNote = False, returnNumberOfTransferStudentSections = False, returnPeriodDaySummary = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnStaffFullNameFML = False, returnTargetCourse = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSection/" + str(TempSectionID), verb = "get", return_params_list = return_params)

def modifyTempSection(TempSectionID, EntityID = 1, setTempSectionID = None, setCourse = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseID = None, setCourseIsActive = None, setCourseTypeCode = None, setCreatedTime = None, setCurrentEnrollment = None, setEntityIDCourse = None, setEntityIDOfferedTo = None, setGradeLevelSummary = None, setIsActive = None, setIsSourceSection = None, setMaximumStudentCount = None, setModifiedTime = None, setNewCourseLengthCode = None, setNewCourseLengthID = None, setNewSectionLengthCode = None, setNewSectionLengthID = None, setNote = None, setNumberOfTransferStudentSections = None, setPeriodDaySummary = None, setPrimaryDays = None, setPrimaryDisplayPeriod = None, setRowIsReadOnly = None, setRowIsSelected = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionID = None, setSectionLengthCode = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setStaffFullNameFML = None, setTargetCourse = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempSectionID = False, returnCourse = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsActive = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnEntityIDCourse = False, returnEntityIDOfferedTo = False, returnGradeLevelSummary = False, returnIsActive = False, returnIsSourceSection = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewSectionLengthCode = False, returnNewSectionLengthID = False, returnNote = False, returnNumberOfTransferStudentSections = False, returnPeriodDaySummary = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnStaffFullNameFML = False, returnTargetCourse = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSection/" + str(TempSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempSection(EntityID = 1, setTempSectionID = None, setCourse = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseID = None, setCourseIsActive = None, setCourseTypeCode = None, setCreatedTime = None, setCurrentEnrollment = None, setEntityIDCourse = None, setEntityIDOfferedTo = None, setGradeLevelSummary = None, setIsActive = None, setIsSourceSection = None, setMaximumStudentCount = None, setModifiedTime = None, setNewCourseLengthCode = None, setNewCourseLengthID = None, setNewSectionLengthCode = None, setNewSectionLengthID = None, setNote = None, setNumberOfTransferStudentSections = None, setPeriodDaySummary = None, setPrimaryDays = None, setPrimaryDisplayPeriod = None, setRowIsReadOnly = None, setRowIsSelected = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionID = None, setSectionLengthCode = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setStaffFullNameFML = None, setTargetCourse = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempSectionID = False, returnCourse = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseID = False, returnCourseIsActive = False, returnCourseTypeCode = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnEntityIDCourse = False, returnEntityIDOfferedTo = False, returnGradeLevelSummary = False, returnIsActive = False, returnIsSourceSection = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNewCourseLengthCode = False, returnNewCourseLengthID = False, returnNewSectionLengthCode = False, returnNewSectionLengthID = False, returnNote = False, returnNumberOfTransferStudentSections = False, returnPeriodDaySummary = False, returnPrimaryDays = False, returnPrimaryDisplayPeriod = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnStaffFullNameFML = False, returnTargetCourse = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempSection(TempSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSection/" + str(TempSectionID), verb = "delete")


def getEveryTempSectionLength(searchConditions = [], EntityID = 1, returnTempSectionLengthID = False, returnCode = False, returnCourseLengthCode = False, returnCreatedTime = False, returnEndDate = False, returnIsUpdated = False, returnModifiedTime = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempSectionLength in the district.

    This function returns a dataframe of every TempSectionLength in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLength/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLength/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempSectionLength(TempSectionLengthID, EntityID = 1, returnTempSectionLengthID = False, returnCode = False, returnCourseLengthCode = False, returnCreatedTime = False, returnEndDate = False, returnIsUpdated = False, returnModifiedTime = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLength/" + str(TempSectionLengthID), verb = "get", return_params_list = return_params)

def modifyTempSectionLength(TempSectionLengthID, EntityID = 1, setTempSectionLengthID = None, setCode = None, setCourseLengthCode = None, setCreatedTime = None, setEndDate = None, setIsUpdated = None, setModifiedTime = None, setOriginalEndDate = None, setOriginalStartDate = None, setProcessAction = None, setProcessActionCode = None, setSectionLengthID = None, setStartDate = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempSectionLengthID = False, returnCode = False, returnCourseLengthCode = False, returnCreatedTime = False, returnEndDate = False, returnIsUpdated = False, returnModifiedTime = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLength/" + str(TempSectionLengthID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempSectionLength(EntityID = 1, setTempSectionLengthID = None, setCode = None, setCourseLengthCode = None, setCreatedTime = None, setEndDate = None, setIsUpdated = None, setModifiedTime = None, setOriginalEndDate = None, setOriginalStartDate = None, setProcessAction = None, setProcessActionCode = None, setSectionLengthID = None, setStartDate = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempSectionLengthID = False, returnCode = False, returnCourseLengthCode = False, returnCreatedTime = False, returnEndDate = False, returnIsUpdated = False, returnModifiedTime = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLength/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempSectionLength(TempSectionLengthID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLength/" + str(TempSectionLengthID), verb = "delete")


def getEveryTempSectionLengthSubset(searchConditions = [], EntityID = 1, returnTempSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthCode = False, returnCourseLengthCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEndDate = False, returnIsFullSectionLength = False, returnIsUpdated = False, returnModifiedTime = False, returnObjectIsDirty = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthCode = False, returnSectionLengthCodeDescription = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempSectionLengthSubset in the district.

    This function returns a dataframe of every TempSectionLengthSubset in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempSectionLengthSubset(TempSectionLengthSubsetID, EntityID = 1, returnTempSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthCode = False, returnCourseLengthCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEndDate = False, returnIsFullSectionLength = False, returnIsUpdated = False, returnModifiedTime = False, returnObjectIsDirty = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthCode = False, returnSectionLengthCodeDescription = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLengthSubset/" + str(TempSectionLengthSubsetID), verb = "get", return_params_list = return_params)

def modifyTempSectionLengthSubset(TempSectionLengthSubsetID, EntityID = 1, setTempSectionLengthSubsetID = None, setCode = None, setCodeDescription = None, setCourseLengthCode = None, setCourseLengthCodeDescription = None, setCourseLengthID = None, setCreatedTime = None, setDescription = None, setEndDate = None, setIsFullSectionLength = None, setIsUpdated = None, setModifiedTime = None, setObjectIsDirty = None, setOriginalEndDate = None, setOriginalStartDate = None, setProcessAction = None, setProcessActionCode = None, setSectionLengthCode = None, setSectionLengthCodeDescription = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setSectionLengthSubsetID = None, setStartDate = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthCode = False, returnCourseLengthCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEndDate = False, returnIsFullSectionLength = False, returnIsUpdated = False, returnModifiedTime = False, returnObjectIsDirty = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthCode = False, returnSectionLengthCodeDescription = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLengthSubset/" + str(TempSectionLengthSubsetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempSectionLengthSubset(EntityID = 1, setTempSectionLengthSubsetID = None, setCode = None, setCodeDescription = None, setCourseLengthCode = None, setCourseLengthCodeDescription = None, setCourseLengthID = None, setCreatedTime = None, setDescription = None, setEndDate = None, setIsFullSectionLength = None, setIsUpdated = None, setModifiedTime = None, setObjectIsDirty = None, setOriginalEndDate = None, setOriginalStartDate = None, setProcessAction = None, setProcessActionCode = None, setSectionLengthCode = None, setSectionLengthCodeDescription = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setSectionLengthSubsetID = None, setStartDate = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempSectionLengthSubsetID = False, returnCode = False, returnCodeDescription = False, returnCourseLengthCode = False, returnCourseLengthCodeDescription = False, returnCourseLengthID = False, returnCreatedTime = False, returnDescription = False, returnEndDate = False, returnIsFullSectionLength = False, returnIsUpdated = False, returnModifiedTime = False, returnObjectIsDirty = False, returnOriginalEndDate = False, returnOriginalStartDate = False, returnProcessAction = False, returnProcessActionCode = False, returnSectionLengthCode = False, returnSectionLengthCodeDescription = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLengthSubset/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempSectionLengthSubset(TempSectionLengthSubsetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSectionLengthSubset/" + str(TempSectionLengthSubsetID), verb = "delete")


def getEveryTempStaffMeet(searchConditions = [], EntityID = 1, returnTempStaffMeetID = False, returnConflicts = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasGradebookAccess = False, returnIsChecked = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnNewEffectiveEndDate = False, returnNewEffectiveStartDate = False, returnNewStaffFullNameFML = False, returnNewStaffID = False, returnNote = False, returnSectionCode = False, returnSectionID = False, returnStaffFullNameFML = False, returnStaffID = False, returnStaffMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempStaffMeet in the district.

    This function returns a dataframe of every TempStaffMeet in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStaffMeet/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStaffMeet/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempStaffMeet(TempStaffMeetID, EntityID = 1, returnTempStaffMeetID = False, returnConflicts = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasGradebookAccess = False, returnIsChecked = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnNewEffectiveEndDate = False, returnNewEffectiveStartDate = False, returnNewStaffFullNameFML = False, returnNewStaffID = False, returnNote = False, returnSectionCode = False, returnSectionID = False, returnStaffFullNameFML = False, returnStaffID = False, returnStaffMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStaffMeet/" + str(TempStaffMeetID), verb = "get", return_params_list = return_params)

def modifyTempStaffMeet(TempStaffMeetID, EntityID = 1, setTempStaffMeetID = None, setConflicts = None, setCourseCode = None, setCourseDescription = None, setCreatedTime = None, setEffectiveEndDate = None, setEffectiveStartDate = None, setHasAttendanceAccess = None, setHasConflicts = None, setHasGradebookAccess = None, setIsChecked = None, setIsLongTermSubstitute = None, setIsPrimary = None, setIsSubstitute = None, setMeetID = None, setModifiedTime = None, setNewEffectiveEndDate = None, setNewEffectiveStartDate = None, setNewStaffFullNameFML = None, setNewStaffID = None, setNote = None, setSectionCode = None, setSectionID = None, setStaffFullNameFML = None, setStaffID = None, setStaffMeetID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempStaffMeetID = False, returnConflicts = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasGradebookAccess = False, returnIsChecked = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnNewEffectiveEndDate = False, returnNewEffectiveStartDate = False, returnNewStaffFullNameFML = False, returnNewStaffID = False, returnNote = False, returnSectionCode = False, returnSectionID = False, returnStaffFullNameFML = False, returnStaffID = False, returnStaffMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStaffMeet/" + str(TempStaffMeetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempStaffMeet(EntityID = 1, setTempStaffMeetID = None, setConflicts = None, setCourseCode = None, setCourseDescription = None, setCreatedTime = None, setEffectiveEndDate = None, setEffectiveStartDate = None, setHasAttendanceAccess = None, setHasConflicts = None, setHasGradebookAccess = None, setIsChecked = None, setIsLongTermSubstitute = None, setIsPrimary = None, setIsSubstitute = None, setMeetID = None, setModifiedTime = None, setNewEffectiveEndDate = None, setNewEffectiveStartDate = None, setNewStaffFullNameFML = None, setNewStaffID = None, setNote = None, setSectionCode = None, setSectionID = None, setStaffFullNameFML = None, setStaffID = None, setStaffMeetID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempStaffMeetID = False, returnConflicts = False, returnCourseCode = False, returnCourseDescription = False, returnCreatedTime = False, returnEffectiveEndDate = False, returnEffectiveStartDate = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasGradebookAccess = False, returnIsChecked = False, returnIsLongTermSubstitute = False, returnIsPrimary = False, returnIsSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnNewEffectiveEndDate = False, returnNewEffectiveStartDate = False, returnNewStaffFullNameFML = False, returnNewStaffID = False, returnNote = False, returnSectionCode = False, returnSectionID = False, returnStaffFullNameFML = False, returnStaffID = False, returnStaffMeetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStaffMeet/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempStaffMeet(TempStaffMeetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStaffMeet/" + str(TempStaffMeetID), verb = "delete")


def getEveryTempStudent(searchConditions = [], EntityID = 1, returnTempStudentID = False, returnCourseRequestCount = False, returnCreatedTime = False, returnCurrentActive = False, returnFullNameLFM = False, returnGenderCode = False, returnGradeLevelCode = False, returnGradeReferenceID = False, returnGradYear = False, returnHasConflictedStudentCourseRequest = False, returnHasFailedUpdate = False, returnHomeRoomCode = False, returnIsSelected = False, returnModifiedTime = False, returnSchoolName = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionCount = False, returnStudentTypeCodeDescription = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempStudent in the district.

    This function returns a dataframe of every TempStudent in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudent/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudent/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempStudent(TempStudentID, EntityID = 1, returnTempStudentID = False, returnCourseRequestCount = False, returnCreatedTime = False, returnCurrentActive = False, returnFullNameLFM = False, returnGenderCode = False, returnGradeLevelCode = False, returnGradeReferenceID = False, returnGradYear = False, returnHasConflictedStudentCourseRequest = False, returnHasFailedUpdate = False, returnHomeRoomCode = False, returnIsSelected = False, returnModifiedTime = False, returnSchoolName = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionCount = False, returnStudentTypeCodeDescription = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudent/" + str(TempStudentID), verb = "get", return_params_list = return_params)

def modifyTempStudent(TempStudentID, EntityID = 1, setTempStudentID = None, setCourseRequestCount = None, setCreatedTime = None, setCurrentActive = None, setFullNameLFM = None, setGenderCode = None, setGradeLevelCode = None, setGradeReferenceID = None, setGradYear = None, setHasConflictedStudentCourseRequest = None, setHasFailedUpdate = None, setHomeRoomCode = None, setIsSelected = None, setModifiedTime = None, setSchoolName = None, setStudentID = None, setStudentNumber = None, setStudentSectionCount = None, setStudentTypeCodeDescription = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentID = False, returnCourseRequestCount = False, returnCreatedTime = False, returnCurrentActive = False, returnFullNameLFM = False, returnGenderCode = False, returnGradeLevelCode = False, returnGradeReferenceID = False, returnGradYear = False, returnHasConflictedStudentCourseRequest = False, returnHasFailedUpdate = False, returnHomeRoomCode = False, returnIsSelected = False, returnModifiedTime = False, returnSchoolName = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionCount = False, returnStudentTypeCodeDescription = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudent/" + str(TempStudentID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempStudent(EntityID = 1, setTempStudentID = None, setCourseRequestCount = None, setCreatedTime = None, setCurrentActive = None, setFullNameLFM = None, setGenderCode = None, setGradeLevelCode = None, setGradeReferenceID = None, setGradYear = None, setHasConflictedStudentCourseRequest = None, setHasFailedUpdate = None, setHomeRoomCode = None, setIsSelected = None, setModifiedTime = None, setSchoolName = None, setStudentID = None, setStudentNumber = None, setStudentSectionCount = None, setStudentTypeCodeDescription = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentID = False, returnCourseRequestCount = False, returnCreatedTime = False, returnCurrentActive = False, returnFullNameLFM = False, returnGenderCode = False, returnGradeLevelCode = False, returnGradeReferenceID = False, returnGradYear = False, returnHasConflictedStudentCourseRequest = False, returnHasFailedUpdate = False, returnHomeRoomCode = False, returnIsSelected = False, returnModifiedTime = False, returnSchoolName = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionCount = False, returnStudentTypeCodeDescription = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudent/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempStudent(TempStudentID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudent/" + str(TempStudentID), verb = "delete")


def getEveryTempStudentCourseRequest(searchConditions = [], EntityID = 1, returnTempStudentCourseRequestID = False, returnCourseCode = False, returnCourseDepartmentCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseNumericSchoolYear = False, returnCourseSchoolYearDescription = False, returnCourseSubjectCodeDescription = False, returnCreatedTime = False, returnEarnedCredits = False, returnEntityIDRequestedFrom = False, returnErrorMessage = False, returnFailed = False, returnFullStudentNameLFM = False, returnModifiedTime = False, returnSectionCode = False, returnSectionlengthSubsetCode = False, returnSectionLengthSubsetID = False, returnSelected = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionID = False, returnTempStudentEnrollmentRecordID = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempStudentCourseRequest in the district.

    This function returns a dataframe of every TempStudentCourseRequest in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequest/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempStudentCourseRequest(TempStudentCourseRequestID, EntityID = 1, returnTempStudentCourseRequestID = False, returnCourseCode = False, returnCourseDepartmentCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseNumericSchoolYear = False, returnCourseSchoolYearDescription = False, returnCourseSubjectCodeDescription = False, returnCreatedTime = False, returnEarnedCredits = False, returnEntityIDRequestedFrom = False, returnErrorMessage = False, returnFailed = False, returnFullStudentNameLFM = False, returnModifiedTime = False, returnSectionCode = False, returnSectionlengthSubsetCode = False, returnSectionLengthSubsetID = False, returnSelected = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionID = False, returnTempStudentEnrollmentRecordID = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequest/" + str(TempStudentCourseRequestID), verb = "get", return_params_list = return_params)

def modifyTempStudentCourseRequest(TempStudentCourseRequestID, EntityID = 1, setTempStudentCourseRequestID = None, setCourseCode = None, setCourseDepartmentCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCourseLengthCode = None, setCourseNumericSchoolYear = None, setCourseSchoolYearDescription = None, setCourseSubjectCodeDescription = None, setCreatedTime = None, setEarnedCredits = None, setEntityIDRequestedFrom = None, setErrorMessage = None, setFailed = None, setFullStudentNameLFM = None, setModifiedTime = None, setSectionCode = None, setSectionlengthSubsetCode = None, setSectionLengthSubsetID = None, setSelected = None, setStudentCourseRequestID = None, setStudentCourseRequestSectionLengthSubsetID = None, setStudentID = None, setStudentNumber = None, setStudentSectionID = None, setTempStudentEnrollmentRecordID = None, setTempStudentID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempStudentCourseRequestID = False, returnCourseCode = False, returnCourseDepartmentCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseNumericSchoolYear = False, returnCourseSchoolYearDescription = False, returnCourseSubjectCodeDescription = False, returnCreatedTime = False, returnEarnedCredits = False, returnEntityIDRequestedFrom = False, returnErrorMessage = False, returnFailed = False, returnFullStudentNameLFM = False, returnModifiedTime = False, returnSectionCode = False, returnSectionlengthSubsetCode = False, returnSectionLengthSubsetID = False, returnSelected = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionID = False, returnTempStudentEnrollmentRecordID = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequest/" + str(TempStudentCourseRequestID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempStudentCourseRequest(EntityID = 1, setTempStudentCourseRequestID = None, setCourseCode = None, setCourseDepartmentCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCourseLengthCode = None, setCourseNumericSchoolYear = None, setCourseSchoolYearDescription = None, setCourseSubjectCodeDescription = None, setCreatedTime = None, setEarnedCredits = None, setEntityIDRequestedFrom = None, setErrorMessage = None, setFailed = None, setFullStudentNameLFM = None, setModifiedTime = None, setSectionCode = None, setSectionlengthSubsetCode = None, setSectionLengthSubsetID = None, setSelected = None, setStudentCourseRequestID = None, setStudentCourseRequestSectionLengthSubsetID = None, setStudentID = None, setStudentNumber = None, setStudentSectionID = None, setTempStudentEnrollmentRecordID = None, setTempStudentID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempStudentCourseRequestID = False, returnCourseCode = False, returnCourseDepartmentCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCourseLengthCode = False, returnCourseNumericSchoolYear = False, returnCourseSchoolYearDescription = False, returnCourseSubjectCodeDescription = False, returnCreatedTime = False, returnEarnedCredits = False, returnEntityIDRequestedFrom = False, returnErrorMessage = False, returnFailed = False, returnFullStudentNameLFM = False, returnModifiedTime = False, returnSectionCode = False, returnSectionlengthSubsetCode = False, returnSectionLengthSubsetID = False, returnSelected = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnStudentID = False, returnStudentNumber = False, returnStudentSectionID = False, returnTempStudentEnrollmentRecordID = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequest/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempStudentCourseRequest(TempStudentCourseRequestID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequest/" + str(TempStudentCourseRequestID), verb = "delete")


def getEveryTempStudentCourseRequestSectionLengthSubset(searchConditions = [], EntityID = 1, returnTempStudentCourseRequestSectionLengthSubsetID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionLengthSubsetID = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempStudentCourseRequestSectionLengthSubset in the district.

    This function returns a dataframe of every TempStudentCourseRequestSectionLengthSubset in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestSectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestSectionLengthSubset/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempStudentCourseRequestSectionLengthSubset(TempStudentCourseRequestSectionLengthSubsetID, EntityID = 1, returnTempStudentCourseRequestSectionLengthSubsetID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionLengthSubsetID = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestSectionLengthSubset/" + str(TempStudentCourseRequestSectionLengthSubsetID), verb = "get", return_params_list = return_params)

def modifyTempStudentCourseRequestSectionLengthSubset(TempStudentCourseRequestSectionLengthSubsetID, EntityID = 1, setTempStudentCourseRequestSectionLengthSubsetID = None, setCreatedTime = None, setModifiedTime = None, setSectionLengthSubsetID = None, setStudentCourseRequestID = None, setStudentCourseRequestSectionLengthSubsetID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentCourseRequestSectionLengthSubsetID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionLengthSubsetID = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestSectionLengthSubset/" + str(TempStudentCourseRequestSectionLengthSubsetID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempStudentCourseRequestSectionLengthSubset(EntityID = 1, setTempStudentCourseRequestSectionLengthSubsetID = None, setCreatedTime = None, setModifiedTime = None, setSectionLengthSubsetID = None, setStudentCourseRequestID = None, setStudentCourseRequestSectionLengthSubsetID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentCourseRequestSectionLengthSubsetID = False, returnCreatedTime = False, returnModifiedTime = False, returnSectionLengthSubsetID = False, returnStudentCourseRequestID = False, returnStudentCourseRequestSectionLengthSubsetID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestSectionLengthSubset/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempStudentCourseRequestSectionLengthSubset(TempStudentCourseRequestSectionLengthSubsetID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestSectionLengthSubset/" + str(TempStudentCourseRequestSectionLengthSubsetID), verb = "delete")


def getEveryTempStudentCourseRequestToReactivateMN(searchConditions = [], EntityID = 1, returnTempStudentCourseRequestToReactivateMNID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnIsTSAProficient = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempStudentCourseRequestToReactivateMN in the district.

    This function returns a dataframe of every TempStudentCourseRequestToReactivateMN in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateMN/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateMN/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempStudentCourseRequestToReactivateMN(TempStudentCourseRequestToReactivateMNID, EntityID = 1, returnTempStudentCourseRequestToReactivateMNID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnIsTSAProficient = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateMN/" + str(TempStudentCourseRequestToReactivateMNID), verb = "get", return_params_list = return_params)

def modifyTempStudentCourseRequestToReactivateMN(TempStudentCourseRequestToReactivateMNID, EntityID = 1, setTempStudentCourseRequestToReactivateMNID = None, setAlternateRank = None, setAuditRecordIsRequestable = None, setAuditRecordIsSchedulable = None, setCourseCode = None, setCourseCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCreatedTime = None, setCurrentEnrollment = None, setDateFrom = None, setDateTo = None, setDays = None, setEarlyExitReasonCodeDescription = None, setEarlyExitReasonID = None, setEarnedCreditOverride = None, setEarnedCredits = None, setEndDate = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setEntityIDRequestedFrom = None, setExcludeFromReportCardsAndTranscripts = None, setExcludeFromStudentSectionLink = None, setGradeReferenceID = None, setIsAlternate = None, setIsTransferCourse = None, setIsTSAProficient = None, setMaximumStudentCount = None, setModifiedTime = None, setNameIDRequestedBy = None, setNameRequestedByLFM = None, setPeriod = None, setPreventReactivateCheckboxFromBeingRendered = None, setRequestSource = None, setRequestSourceCode = None, setRequestStatus = None, setRequestStatusCode = None, setSchedulingMethod = None, setSchedulingMethodCode = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionID = None, setSectionLengthID = None, setSectionLengthSubsetCode = None, setSectionLengthSubsetDescription = None, setSectionLengthSubsetID = None, setStaffFullNameFML = None, setStartDate = None, setStudentCourseRequestID = None, setStudentCourseRequestIDAlternateFor = None, setStudentID = None, setStudentSectionID = None, setStudentSectionTransactionID = None, setTotalEarnedCreditOverride = None, setTotalFailedCreditOverride = None, setTransferCourseName = None, setUseEarnedCreditOverride = None, setUseEarnedCreditTotalOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentCourseRequestToReactivateMNID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnIsTSAProficient = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateMN/" + str(TempStudentCourseRequestToReactivateMNID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempStudentCourseRequestToReactivateMN(EntityID = 1, setTempStudentCourseRequestToReactivateMNID = None, setAlternateRank = None, setAuditRecordIsRequestable = None, setAuditRecordIsSchedulable = None, setCourseCode = None, setCourseCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCreatedTime = None, setCurrentEnrollment = None, setDateFrom = None, setDateTo = None, setDays = None, setEarlyExitReasonCodeDescription = None, setEarlyExitReasonID = None, setEarnedCreditOverride = None, setEarnedCredits = None, setEndDate = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setEntityIDRequestedFrom = None, setExcludeFromReportCardsAndTranscripts = None, setExcludeFromStudentSectionLink = None, setGradeReferenceID = None, setIsAlternate = None, setIsTransferCourse = None, setIsTSAProficient = None, setMaximumStudentCount = None, setModifiedTime = None, setNameIDRequestedBy = None, setNameRequestedByLFM = None, setPeriod = None, setPreventReactivateCheckboxFromBeingRendered = None, setRequestSource = None, setRequestSourceCode = None, setRequestStatus = None, setRequestStatusCode = None, setSchedulingMethod = None, setSchedulingMethodCode = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionID = None, setSectionLengthID = None, setSectionLengthSubsetCode = None, setSectionLengthSubsetDescription = None, setSectionLengthSubsetID = None, setStaffFullNameFML = None, setStartDate = None, setStudentCourseRequestID = None, setStudentCourseRequestIDAlternateFor = None, setStudentID = None, setStudentSectionID = None, setStudentSectionTransactionID = None, setTotalEarnedCreditOverride = None, setTotalFailedCreditOverride = None, setTransferCourseName = None, setUseEarnedCreditOverride = None, setUseEarnedCreditTotalOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentCourseRequestToReactivateMNID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnIsTSAProficient = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateMN/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempStudentCourseRequestToReactivateMN(TempStudentCourseRequestToReactivateMNID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateMN/" + str(TempStudentCourseRequestToReactivateMNID), verb = "delete")


def getEveryTempStudentCourseRequestToReactivateNonState(searchConditions = [], EntityID = 1, returnTempStudentCourseRequestToReactivateNonStateID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempStudentCourseRequestToReactivateNonState in the district.

    This function returns a dataframe of every TempStudentCourseRequestToReactivateNonState in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateNonState/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateNonState/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempStudentCourseRequestToReactivateNonState(TempStudentCourseRequestToReactivateNonStateID, EntityID = 1, returnTempStudentCourseRequestToReactivateNonStateID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateNonState/" + str(TempStudentCourseRequestToReactivateNonStateID), verb = "get", return_params_list = return_params)

def modifyTempStudentCourseRequestToReactivateNonState(TempStudentCourseRequestToReactivateNonStateID, EntityID = 1, setTempStudentCourseRequestToReactivateNonStateID = None, setAlternateRank = None, setAuditRecordIsRequestable = None, setAuditRecordIsSchedulable = None, setCourseCode = None, setCourseCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCreatedTime = None, setCurrentEnrollment = None, setDateFrom = None, setDateTo = None, setDays = None, setEarlyExitReasonCodeDescription = None, setEarlyExitReasonID = None, setEarnedCreditOverride = None, setEarnedCredits = None, setEndDate = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setEntityIDRequestedFrom = None, setExcludeFromReportCardsAndTranscripts = None, setExcludeFromStudentSectionLink = None, setGradeReferenceID = None, setIsAlternate = None, setIsTransferCourse = None, setMaximumStudentCount = None, setModifiedTime = None, setNameIDRequestedBy = None, setNameRequestedByLFM = None, setPeriod = None, setPreventReactivateCheckboxFromBeingRendered = None, setRequestSource = None, setRequestSourceCode = None, setRequestStatus = None, setRequestStatusCode = None, setSchedulingMethod = None, setSchedulingMethodCode = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionID = None, setSectionLengthID = None, setSectionLengthSubsetCode = None, setSectionLengthSubsetDescription = None, setSectionLengthSubsetID = None, setStaffFullNameFML = None, setStartDate = None, setStudentCourseRequestID = None, setStudentCourseRequestIDAlternateFor = None, setStudentID = None, setStudentSectionID = None, setStudentSectionTransactionID = None, setTotalEarnedCreditOverride = None, setTotalFailedCreditOverride = None, setTransferCourseName = None, setUseEarnedCreditOverride = None, setUseEarnedCreditTotalOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentCourseRequestToReactivateNonStateID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateNonState/" + str(TempStudentCourseRequestToReactivateNonStateID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempStudentCourseRequestToReactivateNonState(EntityID = 1, setTempStudentCourseRequestToReactivateNonStateID = None, setAlternateRank = None, setAuditRecordIsRequestable = None, setAuditRecordIsSchedulable = None, setCourseCode = None, setCourseCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCreatedTime = None, setCurrentEnrollment = None, setDateFrom = None, setDateTo = None, setDays = None, setEarlyExitReasonCodeDescription = None, setEarlyExitReasonID = None, setEarnedCreditOverride = None, setEarnedCredits = None, setEndDate = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setEntityIDRequestedFrom = None, setExcludeFromReportCardsAndTranscripts = None, setExcludeFromStudentSectionLink = None, setGradeReferenceID = None, setIsAlternate = None, setIsTransferCourse = None, setMaximumStudentCount = None, setModifiedTime = None, setNameIDRequestedBy = None, setNameRequestedByLFM = None, setPeriod = None, setPreventReactivateCheckboxFromBeingRendered = None, setRequestSource = None, setRequestSourceCode = None, setRequestStatus = None, setRequestStatusCode = None, setSchedulingMethod = None, setSchedulingMethodCode = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionID = None, setSectionLengthID = None, setSectionLengthSubsetCode = None, setSectionLengthSubsetDescription = None, setSectionLengthSubsetID = None, setStaffFullNameFML = None, setStartDate = None, setStudentCourseRequestID = None, setStudentCourseRequestIDAlternateFor = None, setStudentID = None, setStudentSectionID = None, setStudentSectionTransactionID = None, setTotalEarnedCreditOverride = None, setTotalFailedCreditOverride = None, setTransferCourseName = None, setUseEarnedCreditOverride = None, setUseEarnedCreditTotalOverride = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentCourseRequestToReactivateNonStateID = False, returnAlternateRank = False, returnAuditRecordIsRequestable = False, returnAuditRecordIsSchedulable = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnCurrentEnrollment = False, returnDateFrom = False, returnDateTo = False, returnDays = False, returnEarlyExitReasonCodeDescription = False, returnEarlyExitReasonID = False, returnEarnedCreditOverride = False, returnEarnedCredits = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnEntityIDRequestedFrom = False, returnExcludeFromReportCardsAndTranscripts = False, returnExcludeFromStudentSectionLink = False, returnGradeReferenceID = False, returnIsAlternate = False, returnIsTransferCourse = False, returnMaximumStudentCount = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnNameRequestedByLFM = False, returnPeriod = False, returnPreventReactivateCheckboxFromBeingRendered = False, returnRequestSource = False, returnRequestSourceCode = False, returnRequestStatus = False, returnRequestStatusCode = False, returnSchedulingMethod = False, returnSchedulingMethodCode = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionID = False, returnSectionLengthID = False, returnSectionLengthSubsetCode = False, returnSectionLengthSubsetDescription = False, returnSectionLengthSubsetID = False, returnStaffFullNameFML = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentCourseRequestIDAlternateFor = False, returnStudentID = False, returnStudentSectionID = False, returnStudentSectionTransactionID = False, returnTotalEarnedCreditOverride = False, returnTotalFailedCreditOverride = False, returnTransferCourseName = False, returnUseEarnedCreditOverride = False, returnUseEarnedCreditTotalOverride = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateNonState/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempStudentCourseRequestToReactivateNonState(TempStudentCourseRequestToReactivateNonStateID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentCourseRequestToReactivateNonState/" + str(TempStudentCourseRequestToReactivateNonStateID), verb = "delete")


def getEveryTempStudentSchedulingCategory(searchConditions = [], EntityID = 1, returnTempStudentSchedulingCategoryID = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnProposedCategoriesDisplayValue = False, returnProposedTargetCategoryIDsToDeleteCSV = False, returnProposedTargetCategoryIDsToInsertCSV = False, returnSourceCategoriesDisplayValue = False, returnSourceCategoryIDsCSV = False, returnSourceStudentEntityYearID = False, returnStudentNameLFM = False, returnTargetCategoriesDisplayValue = False, returnTargetCategoryIDsCSV = False, returnTargetStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempStudentSchedulingCategory in the district.

    This function returns a dataframe of every TempStudentSchedulingCategory in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingCategory/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingCategory/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempStudentSchedulingCategory(TempStudentSchedulingCategoryID, EntityID = 1, returnTempStudentSchedulingCategoryID = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnProposedCategoriesDisplayValue = False, returnProposedTargetCategoryIDsToDeleteCSV = False, returnProposedTargetCategoryIDsToInsertCSV = False, returnSourceCategoriesDisplayValue = False, returnSourceCategoryIDsCSV = False, returnSourceStudentEntityYearID = False, returnStudentNameLFM = False, returnTargetCategoriesDisplayValue = False, returnTargetCategoryIDsCSV = False, returnTargetStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingCategory/" + str(TempStudentSchedulingCategoryID), verb = "get", return_params_list = return_params)

def modifyTempStudentSchedulingCategory(TempStudentSchedulingCategoryID, EntityID = 1, setTempStudentSchedulingCategoryID = None, setCreatedTime = None, setMessage = None, setModifiedTime = None, setProposedCategoriesDisplayValue = None, setProposedTargetCategoryIDsToDeleteCSV = None, setProposedTargetCategoryIDsToInsertCSV = None, setSourceCategoriesDisplayValue = None, setSourceCategoryIDsCSV = None, setSourceStudentEntityYearID = None, setStudentNameLFM = None, setTargetCategoriesDisplayValue = None, setTargetCategoryIDsCSV = None, setTargetStudentEntityYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentSchedulingCategoryID = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnProposedCategoriesDisplayValue = False, returnProposedTargetCategoryIDsToDeleteCSV = False, returnProposedTargetCategoryIDsToInsertCSV = False, returnSourceCategoriesDisplayValue = False, returnSourceCategoryIDsCSV = False, returnSourceStudentEntityYearID = False, returnStudentNameLFM = False, returnTargetCategoriesDisplayValue = False, returnTargetCategoryIDsCSV = False, returnTargetStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingCategory/" + str(TempStudentSchedulingCategoryID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempStudentSchedulingCategory(EntityID = 1, setTempStudentSchedulingCategoryID = None, setCreatedTime = None, setMessage = None, setModifiedTime = None, setProposedCategoriesDisplayValue = None, setProposedTargetCategoryIDsToDeleteCSV = None, setProposedTargetCategoryIDsToInsertCSV = None, setSourceCategoriesDisplayValue = None, setSourceCategoryIDsCSV = None, setSourceStudentEntityYearID = None, setStudentNameLFM = None, setTargetCategoriesDisplayValue = None, setTargetCategoryIDsCSV = None, setTargetStudentEntityYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentSchedulingCategoryID = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnProposedCategoriesDisplayValue = False, returnProposedTargetCategoryIDsToDeleteCSV = False, returnProposedTargetCategoryIDsToInsertCSV = False, returnSourceCategoriesDisplayValue = False, returnSourceCategoryIDsCSV = False, returnSourceStudentEntityYearID = False, returnStudentNameLFM = False, returnTargetCategoriesDisplayValue = False, returnTargetCategoryIDsCSV = False, returnTargetStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingCategory/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempStudentSchedulingCategory(TempStudentSchedulingCategoryID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingCategory/" + str(TempStudentSchedulingCategoryID), verb = "delete")


def getEveryTempStudentSchedulingTeam(searchConditions = [], EntityID = 1, returnTempStudentSchedulingTeamID = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnSourceSchedulingTeamCode = False, returnSourceSchedulingTeamDescription = False, returnSourceSchedulingTeamID = False, returnSourceSchoolYearDescription = False, returnSourceStudentEntityYearID = False, returnStudentNameLFM = False, returnTargetSchedulingTeamCode = False, returnTargetSchedulingTeamDescription = False, returnTargetSchedulingTeamID = False, returnTargetSchoolYearDescription = False, returnTargetStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempStudentSchedulingTeam in the district.

    This function returns a dataframe of every TempStudentSchedulingTeam in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingTeam/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingTeam/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempStudentSchedulingTeam(TempStudentSchedulingTeamID, EntityID = 1, returnTempStudentSchedulingTeamID = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnSourceSchedulingTeamCode = False, returnSourceSchedulingTeamDescription = False, returnSourceSchedulingTeamID = False, returnSourceSchoolYearDescription = False, returnSourceStudentEntityYearID = False, returnStudentNameLFM = False, returnTargetSchedulingTeamCode = False, returnTargetSchedulingTeamDescription = False, returnTargetSchedulingTeamID = False, returnTargetSchoolYearDescription = False, returnTargetStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingTeam/" + str(TempStudentSchedulingTeamID), verb = "get", return_params_list = return_params)

def modifyTempStudentSchedulingTeam(TempStudentSchedulingTeamID, EntityID = 1, setTempStudentSchedulingTeamID = None, setCreatedTime = None, setMessage = None, setModifiedTime = None, setSourceSchedulingTeamCode = None, setSourceSchedulingTeamDescription = None, setSourceSchedulingTeamID = None, setSourceSchoolYearDescription = None, setSourceStudentEntityYearID = None, setStudentNameLFM = None, setTargetSchedulingTeamCode = None, setTargetSchedulingTeamDescription = None, setTargetSchedulingTeamID = None, setTargetSchoolYearDescription = None, setTargetStudentEntityYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentSchedulingTeamID = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnSourceSchedulingTeamCode = False, returnSourceSchedulingTeamDescription = False, returnSourceSchedulingTeamID = False, returnSourceSchoolYearDescription = False, returnSourceStudentEntityYearID = False, returnStudentNameLFM = False, returnTargetSchedulingTeamCode = False, returnTargetSchedulingTeamDescription = False, returnTargetSchedulingTeamID = False, returnTargetSchoolYearDescription = False, returnTargetStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingTeam/" + str(TempStudentSchedulingTeamID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempStudentSchedulingTeam(EntityID = 1, setTempStudentSchedulingTeamID = None, setCreatedTime = None, setMessage = None, setModifiedTime = None, setSourceSchedulingTeamCode = None, setSourceSchedulingTeamDescription = None, setSourceSchedulingTeamID = None, setSourceSchoolYearDescription = None, setSourceStudentEntityYearID = None, setStudentNameLFM = None, setTargetSchedulingTeamCode = None, setTargetSchedulingTeamDescription = None, setTargetSchedulingTeamID = None, setTargetSchoolYearDescription = None, setTargetStudentEntityYearID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentSchedulingTeamID = False, returnCreatedTime = False, returnMessage = False, returnModifiedTime = False, returnSourceSchedulingTeamCode = False, returnSourceSchedulingTeamDescription = False, returnSourceSchedulingTeamID = False, returnSourceSchoolYearDescription = False, returnSourceStudentEntityYearID = False, returnStudentNameLFM = False, returnTargetSchedulingTeamCode = False, returnTargetSchedulingTeamDescription = False, returnTargetSchedulingTeamID = False, returnTargetSchoolYearDescription = False, returnTargetStudentEntityYearID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingTeam/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempStudentSchedulingTeam(TempStudentSchedulingTeamID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSchedulingTeam/" + str(TempStudentSchedulingTeamID), verb = "delete")


def getEveryTempStudentSection(searchConditions = [], EntityID = 1, returnTempStudentSectionID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnEarlyExitReasonCodeDescription = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNote = False, returnRenderCheckbox = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnScheduleAllSectionsInGroupOrNone = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionCorequisiteGroupName = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentGenderCode = False, returnStudentGradeLevelCode = False, returnStudentGradYear = False, returnStudentID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionID = False, returnStudentSectionTransactionIDToUpdate = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempStudentSection in the district.

    This function returns a dataframe of every TempStudentSection in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSection/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSection/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempStudentSection(TempStudentSectionID, EntityID = 1, returnTempStudentSectionID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnEarlyExitReasonCodeDescription = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNote = False, returnRenderCheckbox = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnScheduleAllSectionsInGroupOrNone = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionCorequisiteGroupName = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentGenderCode = False, returnStudentGradeLevelCode = False, returnStudentGradYear = False, returnStudentID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionID = False, returnStudentSectionTransactionIDToUpdate = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSection/" + str(TempStudentSectionID), verb = "get", return_params_list = return_params)

def modifyTempStudentSection(TempStudentSectionID, EntityID = 1, setTempStudentSectionID = None, setAutomaticRequestSetting = None, setAutomaticRequestSettingCode = None, setAutomaticScheduleSetting = None, setAutomaticScheduleSettingCode = None, setCourseCode = None, setCourseCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCreatedTime = None, setEarlyExitReasonCodeDescription = None, setEndDate = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setGradeReferenceID = None, setModifiedTime = None, setNote = None, setRenderCheckbox = None, setRowIsReadOnly = None, setRowIsSelected = None, setScheduleAllSectionsInGroupOrNone = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionCorequisiteGroupName = None, setSectionID = None, setSectionLengthCode = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setSectionLengthSubsetID = None, setStartDate = None, setStudentCourseRequestID = None, setStudentGenderCode = None, setStudentGradeLevelCode = None, setStudentGradYear = None, setStudentID = None, setStudentNameLFM = None, setStudentNumber = None, setStudentSectionID = None, setStudentSectionTransactionIDToUpdate = None, setTempStudentID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempStudentSectionID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnEarlyExitReasonCodeDescription = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNote = False, returnRenderCheckbox = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnScheduleAllSectionsInGroupOrNone = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionCorequisiteGroupName = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentGenderCode = False, returnStudentGradeLevelCode = False, returnStudentGradYear = False, returnStudentID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionID = False, returnStudentSectionTransactionIDToUpdate = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSection/" + str(TempStudentSectionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempStudentSection(EntityID = 1, setTempStudentSectionID = None, setAutomaticRequestSetting = None, setAutomaticRequestSettingCode = None, setAutomaticScheduleSetting = None, setAutomaticScheduleSettingCode = None, setCourseCode = None, setCourseCodeDescription = None, setCourseDescription = None, setCourseEntityOfferedToID = None, setCourseGradeLevelSummary = None, setCourseID = None, setCreatedTime = None, setEarlyExitReasonCodeDescription = None, setEndDate = None, setEntityIDCountsAs = None, setEntityIDCourse = None, setGradeReferenceID = None, setModifiedTime = None, setNote = None, setRenderCheckbox = None, setRowIsReadOnly = None, setRowIsSelected = None, setScheduleAllSectionsInGroupOrNone = None, setSchoolYearIDCourse = None, setSectionCode = None, setSectionCorequisiteGroupName = None, setSectionID = None, setSectionLengthCode = None, setSectionLengthEndDate = None, setSectionLengthID = None, setSectionLengthStartDate = None, setSectionLengthSubsetID = None, setStartDate = None, setStudentCourseRequestID = None, setStudentGenderCode = None, setStudentGradeLevelCode = None, setStudentGradYear = None, setStudentID = None, setStudentNameLFM = None, setStudentNumber = None, setStudentSectionID = None, setStudentSectionTransactionIDToUpdate = None, setTempStudentID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, setWorkflowAction = None, setWorkflowActionCode = None, returnTempStudentSectionID = False, returnAutomaticRequestSetting = False, returnAutomaticRequestSettingCode = False, returnAutomaticScheduleSetting = False, returnAutomaticScheduleSettingCode = False, returnCourseCode = False, returnCourseCodeDescription = False, returnCourseDescription = False, returnCourseEntityOfferedToID = False, returnCourseGradeLevelSummary = False, returnCourseID = False, returnCreatedTime = False, returnEarlyExitReasonCodeDescription = False, returnEndDate = False, returnEntityIDCountsAs = False, returnEntityIDCourse = False, returnGradeReferenceID = False, returnModifiedTime = False, returnNote = False, returnRenderCheckbox = False, returnRowIsReadOnly = False, returnRowIsSelected = False, returnScheduleAllSectionsInGroupOrNone = False, returnSchoolYearIDCourse = False, returnSectionCode = False, returnSectionCorequisiteGroupName = False, returnSectionID = False, returnSectionLengthCode = False, returnSectionLengthEndDate = False, returnSectionLengthID = False, returnSectionLengthStartDate = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentGenderCode = False, returnStudentGradeLevelCode = False, returnStudentGradYear = False, returnStudentID = False, returnStudentNameLFM = False, returnStudentNumber = False, returnStudentSectionID = False, returnStudentSectionTransactionIDToUpdate = False, returnTempStudentID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, returnWorkflowAction = False, returnWorkflowActionCode = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSection/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempStudentSection(TempStudentSectionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSection/" + str(TempStudentSectionID), verb = "delete")


def getEveryTempStudentSectionTransaction(searchConditions = [], EntityID = 1, returnTempStudentSectionTransactionID = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentSectionTransactionID = False, returnTempStudentCourseRequestID = False, returnTempStudentCourseRequestToReactivateID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempStudentSectionTransaction in the district.

    This function returns a dataframe of every TempStudentSectionTransaction in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSectionTransaction/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSectionTransaction/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempStudentSectionTransaction(TempStudentSectionTransactionID, EntityID = 1, returnTempStudentSectionTransactionID = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentSectionTransactionID = False, returnTempStudentCourseRequestID = False, returnTempStudentCourseRequestToReactivateID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSectionTransaction/" + str(TempStudentSectionTransactionID), verb = "get", return_params_list = return_params)

def modifyTempStudentSectionTransaction(TempStudentSectionTransactionID, EntityID = 1, setTempStudentSectionTransactionID = None, setCreatedTime = None, setEarlyExitReasonID = None, setEndDate = None, setEntityIDCountsAs = None, setHideNewStudentButton = None, setModifiedTime = None, setNameIDRequestedBy = None, setSectionLengthSubsetID = None, setStartDate = None, setStudentCourseRequestID = None, setStudentSectionTransactionID = None, setTempStudentCourseRequestID = None, setTempStudentCourseRequestToReactivateID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentSectionTransactionID = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentSectionTransactionID = False, returnTempStudentCourseRequestID = False, returnTempStudentCourseRequestToReactivateID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSectionTransaction/" + str(TempStudentSectionTransactionID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempStudentSectionTransaction(EntityID = 1, setTempStudentSectionTransactionID = None, setCreatedTime = None, setEarlyExitReasonID = None, setEndDate = None, setEntityIDCountsAs = None, setHideNewStudentButton = None, setModifiedTime = None, setNameIDRequestedBy = None, setSectionLengthSubsetID = None, setStartDate = None, setStudentCourseRequestID = None, setStudentSectionTransactionID = None, setTempStudentCourseRequestID = None, setTempStudentCourseRequestToReactivateID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempStudentSectionTransactionID = False, returnCreatedTime = False, returnEarlyExitReasonID = False, returnEndDate = False, returnEntityIDCountsAs = False, returnHideNewStudentButton = False, returnModifiedTime = False, returnNameIDRequestedBy = False, returnSectionLengthSubsetID = False, returnStartDate = False, returnStudentCourseRequestID = False, returnStudentSectionTransactionID = False, returnTempStudentCourseRequestID = False, returnTempStudentCourseRequestToReactivateID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSectionTransaction/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempStudentSectionTransaction(TempStudentSectionTransactionID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempStudentSectionTransaction/" + str(TempStudentSectionTransactionID), verb = "delete")


def getEveryTempSubstituteAssignment(searchConditions = [], EntityID = 1, returnTempSubstituteAssignmentID = False, returnConflicts = False, returnCourseCodeSectionCode = False, returnCreatedTime = False, returnDate = False, returnDisplayPeriodID = False, returnDisplayPeriodSortNumber = False, returnEntityID = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasGradebookAccess = False, returnIsLongTermSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnPeriod = False, returnSchoolYearID = False, returnSectionAlreadyCovered = False, returnSectionID = False, returnSourceStaffID = False, returnStaffMeetID = False, returnStaffName = False, returnSubstituteStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False, page = 1, pageSize = 100000, conditionGroupType = "And"):

    """Get every TempSubstituteAssignment in the district.

    This function returns a dataframe of every TempSubstituteAssignment in the district filtered by search conditions.

    """

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):
        return_params = list(return_params.assign(Value = True).Param)
    else:
        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    if len(searchConditions) > 0:

        searchConditions = params.query('Param == "searchConditions"').Value[0]

        payload_params = formatSearchConditionsPayload(searchConditions, conditionGroupType)

        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSubstituteAssignment/" + str(page) + "/" + str(pageSize), verb = "post", return_params_list = return_params, payload = payload_params)

    else:
        return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSubstituteAssignment/" + str(page) + "/" + str(pageSize), verb = "get", return_params_list = return_params)

def getTempSubstituteAssignment(TempSubstituteAssignmentID, EntityID = 1, returnTempSubstituteAssignmentID = False, returnConflicts = False, returnCourseCodeSectionCode = False, returnCreatedTime = False, returnDate = False, returnDisplayPeriodID = False, returnDisplayPeriodSortNumber = False, returnEntityID = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasGradebookAccess = False, returnIsLongTermSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnPeriod = False, returnSchoolYearID = False, returnSectionAlreadyCovered = False, returnSectionID = False, returnSourceStaffID = False, returnStaffMeetID = False, returnStaffName = False, returnSubstituteStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSubstituteAssignment/" + str(TempSubstituteAssignmentID), verb = "get", return_params_list = return_params)

def modifyTempSubstituteAssignment(TempSubstituteAssignmentID, EntityID = 1, setTempSubstituteAssignmentID = None, setConflicts = None, setCourseCodeSectionCode = None, setCreatedTime = None, setDate = None, setDisplayPeriodID = None, setDisplayPeriodSortNumber = None, setEntityID = None, setHasAttendanceAccess = None, setHasConflicts = None, setHasGradebookAccess = None, setIsLongTermSubstitute = None, setMeetID = None, setModifiedTime = None, setPeriod = None, setSchoolYearID = None, setSectionAlreadyCovered = None, setSectionID = None, setSourceStaffID = None, setStaffMeetID = None, setStaffName = None, setSubstituteStaffID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempSubstituteAssignmentID = False, returnConflicts = False, returnCourseCodeSectionCode = False, returnCreatedTime = False, returnDate = False, returnDisplayPeriodID = False, returnDisplayPeriodSortNumber = False, returnEntityID = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasGradebookAccess = False, returnIsLongTermSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnPeriod = False, returnSchoolYearID = False, returnSectionAlreadyCovered = False, returnSectionID = False, returnSourceStaffID = False, returnStaffMeetID = False, returnStaffName = False, returnSubstituteStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    payload_params["DataObject"].update(dict({params.Param[0]:params.Value[0]}))

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSubstituteAssignment/" + str(TempSubstituteAssignmentID), verb = "post", return_params_list = return_params, payload = payload_params)

def createTempSubstituteAssignment(EntityID = 1, setTempSubstituteAssignmentID = None, setConflicts = None, setCourseCodeSectionCode = None, setCreatedTime = None, setDate = None, setDisplayPeriodID = None, setDisplayPeriodSortNumber = None, setEntityID = None, setHasAttendanceAccess = None, setHasConflicts = None, setHasGradebookAccess = None, setIsLongTermSubstitute = None, setMeetID = None, setModifiedTime = None, setPeriod = None, setSchoolYearID = None, setSectionAlreadyCovered = None, setSectionID = None, setSourceStaffID = None, setStaffMeetID = None, setStaffName = None, setSubstituteStaffID = None, setUserIDCreatedBy = None, setUserIDModifiedBy = None, returnTempSubstituteAssignmentID = False, returnConflicts = False, returnCourseCodeSectionCode = False, returnCreatedTime = False, returnDate = False, returnDisplayPeriodID = False, returnDisplayPeriodSortNumber = False, returnEntityID = False, returnHasAttendanceAccess = False, returnHasConflicts = False, returnHasGradebookAccess = False, returnIsLongTermSubstitute = False, returnMeetID = False, returnModifiedTime = False, returnPeriod = False, returnSchoolYearID = False, returnSectionAlreadyCovered = False, returnSectionID = False, returnSourceStaffID = False, returnStaffMeetID = False, returnStaffName = False, returnSubstituteStaffID = False, returnUserIDCreatedBy = False, returnUserIDModifiedBy = False):

    params = locals()

    params = pd.DataFrame(list(zip(params.keys(), params.values())), columns = ["Param", "Value"])

    return_params = params.query('Param.str.startswith("return")', engine = 'python')

    if not any(return_params.Value):

        return_params = list(return_params.assign(Value = True).Param)
    else:

        return_params = list(return_params.query('Value == True').Param)

    return_params = [re.sub("^return", '', param) for param in return_params]

    payload_params = params.query('Param.str.startswith("set") and not Value.isnull()', engine = 'python')

    payload_params = payload_params.assign(Param = payload_params["Param"].str.replace("^set", ""))

    payload_params = pd.DataFrame(list(payload_params.Value), index = list(payload_params.Param)).transpose()

    payload_params = json.loads(payload_params.to_json(orient = "records"))[0]

    payload_params = dict({"DataObject": payload_params})

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSubstituteAssignment/", verb = "put", return_params_list = return_params, payload = payload_params)

def deleteTempSubstituteAssignment(TempSubstituteAssignmentID, EntityID = 1):

    return make_request(endpoint = "/Generic/" + str(EntityID) + "/Scheduling/TempSubstituteAssignment/" + str(TempSubstituteAssignmentID), verb = "delete")